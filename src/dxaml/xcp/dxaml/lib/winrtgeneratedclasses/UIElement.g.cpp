// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.
//------------------------------------------------------------------------
//
//  Abstract:
//
//      XAML types.
//      NOTE: This file was generated by a tool.
//
//------------------------------------------------------------------------

#include "UIElement.g.h"
#include "AutomationPeer.g.h"
#include "BringIntoViewOptions.g.h"
#include "BringIntoViewRequestedEventArgs.g.h"
#include "CacheMode.g.h"
#include "FlyoutBase.g.h"
#include "GeneralTransform.g.h"
#include "KeyboardAcceleratorInvokedEventArgs.g.h"
#include "Pointer.g.h"
#include "ProcessKeyboardAcceleratorEventArgs.g.h"
#include "Projection.g.h"
#include "RectangleGeometry.g.h"
#include "RoutedEvent.g.h"
#include "ScalarTransition.g.h"
#include "Shadow.g.h"
#include "Transform.g.h"
#include "Transform3D.g.h"
#include "TransitionCollection.g.h"
#include "TransitionTarget.g.h"
#include "UIElementCollection.g.h"
#include "Vector3Transition.g.h"
#include "XamlRoot.g.h"
#include "XamlTelemetry.h"

// Constructors/destructors.
DirectUI::UIElementGenerated::UIElementGenerated()
{
}

DirectUI::UIElementGenerated::~UIElementGenerated()
{
}

HRESULT DirectUI::UIElementGenerated::QueryInterfaceImpl(_In_ REFIID iid, _Outptr_ void** ppObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(DirectUI::UIElement)))
    {
        *ppObject = static_cast<DirectUI::UIElement*>(this);
    }
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Xaml::IUIElement)))
    {
        *ppObject = static_cast<ABI::Microsoft::UI::Xaml::IUIElement*>(this);
    }
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Xaml::IUIElementProtected)))
    {
        *ppObject = static_cast<ABI::Microsoft::UI::Xaml::IUIElementProtected*>(this);
    }
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Xaml::IUIElementOverrides)))
    {
        *ppObject = static_cast<ABI::Microsoft::UI::Xaml::IUIElementOverrides*>(this);
    }
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Composition::IAnimationObject)))
    {
        *ppObject = static_cast<ABI::Microsoft::UI::Composition::IAnimationObject*>(this);
    }
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Composition::IVisualElement)))
    {
        *ppObject = static_cast<ABI::Microsoft::UI::Composition::IVisualElement*>(this);
    }
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Composition::IVisualElement2)))
    {
        *ppObject = static_cast<ABI::Microsoft::UI::Composition::IVisualElement2*>(this);
    }
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Xaml::IUIElementPrivate)))
    {
        *ppObject = static_cast<ABI::Microsoft::UI::Xaml::IUIElementPrivate*>(this);
    }
#if WI_IS_FEATURE_PRESENT(Feature_Xaml2018)
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Xaml::IUIElementFeature_Xaml2018)) && Feature_Xaml2018::IsEnabled())
    {
        *ppObject = ctl::interface_cast<ABI::Microsoft::UI::Xaml::IUIElementFeature_Xaml2018>(this);
    }
#endif
#if WI_IS_FEATURE_PRESENT(Feature_XamlMotionSystemHoldbacks)
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Xaml::IUIElementFeature_XamlMotionSystemHoldbacks)) && Feature_XamlMotionSystemHoldbacks::IsEnabled())
    {
        *ppObject = ctl::interface_cast<ABI::Microsoft::UI::Xaml::IUIElementFeature_XamlMotionSystemHoldbacks>(this);
    }
#endif
    else
    {
        RRETURN(DirectUI::DependencyObject::QueryInterfaceImpl(iid, ppObject));
    }

    AddRefOuter();
    RRETURN(S_OK);
}

// Properties.
IFACEMETHODIMP DirectUI::UIElementGenerated::get_AccessKey(_Out_ HSTRING* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_AccessKey, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_AccessKey(_In_opt_ HSTRING value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_AccessKey, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_AccessKeyScopeOwner(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IDependencyObject** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_AccessKeyScopeOwnerImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_AccessKeyScopeOwner(_In_opt_ ABI::Microsoft::UI::Xaml::IDependencyObject* pValue)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->put_AccessKeyScopeOwnerImpl(pValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_ActualOffset(_Out_ ABI::Windows::Foundation::Numerics::Vector3* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_ActualOffsetImpl(pValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_ActualSize(_Out_ ABI::Windows::Foundation::Numerics::Vector2* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_ActualSizeImpl(pValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_AllowDrop(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_AllowDrop, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_AllowDrop(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_AllowDrop, value));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_AnimatedCenterPoint(_Out_ ABI::Windows::Foundation::Numerics::Vector3* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_AnimatedCenterPointImpl(pValue));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_AnimatedCenterPoint(_In_ ABI::Windows::Foundation::Numerics::Vector3 value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->put_AnimatedCenterPointImpl(value));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_AnimatedRotation(_Out_ FLOAT* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_AnimatedRotationImpl(pValue));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_AnimatedRotation(_In_ FLOAT value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->put_AnimatedRotationImpl(value));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_AnimatedRotationAxis(_Out_ ABI::Windows::Foundation::Numerics::Vector3* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_AnimatedRotationAxisImpl(pValue));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_AnimatedRotationAxis(_In_ ABI::Windows::Foundation::Numerics::Vector3 value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->put_AnimatedRotationAxisImpl(value));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_AnimatedScale(_Out_ ABI::Windows::Foundation::Numerics::Vector3* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_AnimatedScaleImpl(pValue));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_AnimatedScale(_In_ ABI::Windows::Foundation::Numerics::Vector3 value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->put_AnimatedScaleImpl(value));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_AnimatedTransformMatrix(_Out_ ABI::Windows::Foundation::Numerics::Matrix4x4* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_AnimatedTransformMatrixImpl(pValue));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_AnimatedTransformMatrix(_In_ ABI::Windows::Foundation::Numerics::Matrix4x4 value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->put_AnimatedTransformMatrixImpl(value));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_AnimatedTranslation(_Out_ ABI::Windows::Foundation::Numerics::Vector3* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_AnimatedTranslationImpl(pValue));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_AnimatedTranslation(_In_ ABI::Windows::Foundation::Numerics::Vector3 value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->put_AnimatedTranslationImpl(value));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_CacheMode(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::Media::ICacheMode** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_CacheMode, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_CacheMode(_In_opt_ ABI::Microsoft::UI::Xaml::Media::ICacheMode* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_CacheMode, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_CanBeScrollAnchor(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_CanBeScrollAnchor, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_CanBeScrollAnchor(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_CanBeScrollAnchor, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_CanDrag(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_CanDrag, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_CanDrag(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_CanDrag, value));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_CanvasOffset(_Outptr_result_maybenull_ IInspectable** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_CanvasOffset, ppValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_CanvasOffset(_In_opt_ IInspectable* pValue)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_CanvasOffset, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_CenterPoint(_Out_ ABI::Windows::Foundation::Numerics::Vector3* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_CenterPointImpl(pValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_CenterPoint(_In_ ABI::Windows::Foundation::Numerics::Vector3 value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(StrictOnlyApiCheck(this, L"CenterPoint"));
    IFC(static_cast<UIElement*>(this)->put_CenterPointImpl(value));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_ChildrenInternal(_Outptr_result_maybenull_ ABI::Windows::Foundation::Collections::IVector<ABI::Microsoft::UI::Xaml::UIElement*>** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_ChildrenInternal, ppValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_ChildrenInternal(_In_opt_ ABI::Windows::Foundation::Collections::IVector<ABI::Microsoft::UI::Xaml::UIElement*>* pValue)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_ChildrenInternal, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_Clip(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::Media::IRectangleGeometry** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_Clip, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_Clip(_In_opt_ ABI::Microsoft::UI::Xaml::Media::IRectangleGeometry* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_Clip, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_CompositeMode(_Out_ ABI::Microsoft::UI::Xaml::Media::ElementCompositeMode* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_CompositeMode, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_CompositeMode(_In_ ABI::Microsoft::UI::Xaml::Media::ElementCompositeMode value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_CompositeMode, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_ContextFlyout(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::Controls::Primitives::IFlyoutBase** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_ContextFlyout, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_ContextFlyout(_In_opt_ ABI::Microsoft::UI::Xaml::Controls::Primitives::IFlyoutBase* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_ContextFlyout, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_DesiredSize(_Out_ ABI::Windows::Foundation::Size* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_DesiredSizeImpl(pValue));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_DirectManipulationContainer(_Outptr_result_maybenull_ IInspectable** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_DirectManipulationContainer, ppValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_DirectManipulationContainer(_In_opt_ IInspectable* pValue)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_DirectManipulationContainer, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_ExitDisplayModeOnAccessKeyInvoked(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_ExitDisplayModeOnAccessKeyInvoked, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_ExitDisplayModeOnAccessKeyInvoked(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_ExitDisplayModeOnAccessKeyInvoked, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_FocusState(_Out_ ABI::Microsoft::UI::Xaml::FocusState* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_FocusState, pValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_GlobalScaleFactor(_Out_ FLOAT* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_GlobalScaleFactor, pValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_GlobalScaleFactor(_In_ FLOAT value)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_GlobalScaleFactor, value));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_HandOffVisualClip(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::Media::IRectangleGeometry** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_HandOffVisualClip, ppValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_HandOffVisualClip(_In_opt_ ABI::Microsoft::UI::Xaml::Media::IRectangleGeometry* pValue)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_HandOffVisualClip, pValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_HandOffVisualTransform(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::Media::ITransform** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_HandOffVisualTransform, ppValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_HandOffVisualTransform(_In_opt_ ABI::Microsoft::UI::Xaml::Media::ITransform* pValue)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_HandOffVisualTransform, pValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_HandOffVisualTransformMatrix3D(_Out_ ABI::Microsoft::UI::Xaml::Media::Media3D::Matrix3D* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_HandOffVisualTransformMatrix3D, pValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_HandOffVisualTransformMatrix3D(_In_ ABI::Microsoft::UI::Xaml::Media::Media3D::Matrix3D value)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_HandOffVisualTransformMatrix3D, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_HighContrastAdjustment(_Out_ ABI::Microsoft::UI::Xaml::ElementHighContrastAdjustment* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_HighContrastAdjustment, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_HighContrastAdjustment(_In_ ABI::Microsoft::UI::Xaml::ElementHighContrastAdjustment value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_HighContrastAdjustment, value));
}
_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::get_Interactions(_Outptr_result_maybenull_ ABI::Windows::Foundation::Collections::IVector<ABI::Microsoft::UI::Xaml::InteractionBase*>** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_InteractionsImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_IsAccessKeyScope(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_IsAccessKeyScope, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_IsAccessKeyScope(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_IsAccessKeyScope, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_IsDoubleTapEnabled(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_IsDoubleTapEnabled, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_IsDoubleTapEnabled(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_IsDoubleTapEnabled, value));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_IsGamepadFocusCandidate(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_IsGamepadFocusCandidate, pValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_IsGamepadFocusCandidate(_In_ BOOLEAN value)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_IsGamepadFocusCandidate, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_IsHitTestVisible(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_IsHitTestVisible, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_IsHitTestVisible(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_IsHitTestVisible, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_IsHoldingEnabled(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_IsHoldingEnabled, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_IsHoldingEnabled(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_IsHoldingEnabled, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_IsRightTapEnabled(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_IsRightTapEnabled, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_IsRightTapEnabled(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_IsRightTapEnabled, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_IsTabStop(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_IsTabStop, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_IsTabStop(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_IsTabStop, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_IsTapEnabled(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_IsTapEnabled, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_IsTapEnabled(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_IsTapEnabled, value));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_KeepAliveCount(_Out_ INT* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_KeepAliveCountImpl(pValue));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_KeepAliveCount(_In_ INT value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->put_KeepAliveCountImpl(value));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_KeyboardAcceleratorPlacementMode(_Out_ ABI::Microsoft::UI::Xaml::Input::KeyboardAcceleratorPlacementMode* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyboardAcceleratorPlacementMode, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_KeyboardAcceleratorPlacementMode(_In_ ABI::Microsoft::UI::Xaml::Input::KeyboardAcceleratorPlacementMode value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyboardAcceleratorPlacementMode, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_KeyboardAcceleratorPlacementTarget(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IDependencyObject** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyboardAcceleratorPlacementTarget, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_KeyboardAcceleratorPlacementTarget(_In_opt_ ABI::Microsoft::UI::Xaml::IDependencyObject* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyboardAcceleratorPlacementTarget, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_KeyboardAccelerators(_Outptr_result_maybenull_ ABI::Windows::Foundation::Collections::IVector<ABI::Microsoft::UI::Xaml::Input::KeyboardAccelerator*>** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyboardAccelerators, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_KeyTipHorizontalOffset(_Out_ DOUBLE* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyTipHorizontalOffset, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_KeyTipHorizontalOffset(_In_ DOUBLE value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyTipHorizontalOffset, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_KeyTipPlacementMode(_Out_ ABI::Microsoft::UI::Xaml::Input::KeyTipPlacementMode* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyTipPlacementMode, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_KeyTipPlacementMode(_In_ ABI::Microsoft::UI::Xaml::Input::KeyTipPlacementMode value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyTipPlacementMode, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_KeyTipTarget(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IDependencyObject** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyTipTarget, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_KeyTipTarget(_In_opt_ ABI::Microsoft::UI::Xaml::IDependencyObject* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyTipTarget, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_KeyTipVerticalOffset(_Out_ DOUBLE* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyTipVerticalOffset, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_KeyTipVerticalOffset(_In_ DOUBLE value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_KeyTipVerticalOffset, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_Lights(_Outptr_result_maybenull_ ABI::Windows::Foundation::Collections::IVector<ABI::Microsoft::UI::Xaml::Media::XamlLight*>** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_LightsImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_ManipulationMode(_Out_ ABI::Microsoft::UI::Xaml::Input::ManipulationModes* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_ManipulationMode, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_ManipulationMode(_In_ ABI::Microsoft::UI::Xaml::Input::ManipulationModes value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_ManipulationMode, value));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_OffsetXAnimation(_Outptr_result_maybenull_ IInspectable** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_OffsetXAnimation, ppValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_OffsetXAnimation(_In_opt_ IInspectable* pValue)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_OffsetXAnimation, pValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_OffsetYAnimation(_Outptr_result_maybenull_ IInspectable** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_OffsetYAnimation, ppValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_OffsetYAnimation(_In_opt_ IInspectable* pValue)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_OffsetYAnimation, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_Opacity(_Out_ DOUBLE* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_Opacity, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_Opacity(_In_ DOUBLE value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_Opacity, value));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_OpacityAnimation(_Outptr_result_maybenull_ IInspectable** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_OpacityAnimation, ppValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_OpacityAnimation(_In_opt_ IInspectable* pValue)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_OpacityAnimation, pValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_OpacityExpression(_Outptr_result_maybenull_ IInspectable** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_OpacityExpression, ppValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_OpacityExpression(_In_opt_ IInspectable* pValue)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_OpacityExpression, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_OpacityTransition(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IScalarTransition** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_OpacityTransition, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_OpacityTransition(_In_opt_ ABI::Microsoft::UI::Xaml::IScalarTransition* pValue)
{
    IFC_RETURN(StrictOnlyApiCheck(this, L"OpacityTransition"));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_OpacityTransition, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_PointerCaptures(_Outptr_result_maybenull_ ABI::Windows::Foundation::Collections::IVectorView<ABI::Microsoft::UI::Xaml::Input::Pointer*>** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_PointerCaptures, ppValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_PointerCaptures(_In_opt_ ABI::Windows::Foundation::Collections::IVectorView<ABI::Microsoft::UI::Xaml::Input::Pointer*>* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_PointerCaptures, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_Projection(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::Media::IProjection** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_Projection, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_Projection(_In_opt_ ABI::Microsoft::UI::Xaml::Media::IProjection* pValue)
{
    IFC_RETURN(NonStrictOnlyApiCheck(this, L"Projection"));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_Projection, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_ProtectedCursor(_Outptr_result_maybenull_ ABI::Microsoft::UI::Input::IInputCursor** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_ProtectedCursor, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_ProtectedCursor(_In_opt_ ABI::Microsoft::UI::Input::IInputCursor* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_ProtectedCursor, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_RasterizationScale(_Out_ DOUBLE* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_RasterizationScaleImpl(pValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_RasterizationScale(_In_ DOUBLE value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->put_RasterizationScaleImpl(value));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_RenderSize(_Out_ ABI::Windows::Foundation::Size* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_RenderSize, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_RenderTransform(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::Media::ITransform** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_RenderTransform, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_RenderTransform(_In_opt_ ABI::Microsoft::UI::Xaml::Media::ITransform* pValue)
{
    IFC_RETURN(NonStrictOnlyApiCheck(this, L"RenderTransform"));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_RenderTransform, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_RenderTransformOrigin(_Out_ ABI::Windows::Foundation::Point* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_RenderTransformOrigin, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_RenderTransformOrigin(_In_ ABI::Windows::Foundation::Point value)
{
    IFC_RETURN(NonStrictOnlyApiCheck(this, L"RenderTransformOrigin"));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_RenderTransformOrigin, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_Rotation(_Out_ FLOAT* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_RotationImpl(pValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_Rotation(_In_ FLOAT value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(StrictOnlyApiCheck(this, L"Rotation"));
    IFC(static_cast<UIElement*>(this)->put_RotationImpl(value));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_RotationAxis(_Out_ ABI::Windows::Foundation::Numerics::Vector3* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_RotationAxisImpl(pValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_RotationAxis(_In_ ABI::Windows::Foundation::Numerics::Vector3 value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(StrictOnlyApiCheck(this, L"RotationAxis"));
    IFC(static_cast<UIElement*>(this)->put_RotationAxisImpl(value));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_RotationTransition(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IScalarTransition** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_RotationTransition, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_RotationTransition(_In_opt_ ABI::Microsoft::UI::Xaml::IScalarTransition* pValue)
{
    IFC_RETURN(StrictOnlyApiCheck(this, L"RotationTransition"));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_RotationTransition, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_Scale(_Out_ ABI::Windows::Foundation::Numerics::Vector3* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_ScaleImpl(pValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_Scale(_In_ ABI::Windows::Foundation::Numerics::Vector3 value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(StrictOnlyApiCheck(this, L"Scale"));
    IFC(static_cast<UIElement*>(this)->put_ScaleImpl(value));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_ScaleTransition(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IVector3Transition** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_ScaleTransition, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_ScaleTransition(_In_opt_ ABI::Microsoft::UI::Xaml::IVector3Transition* pValue)
{
    IFC_RETURN(StrictOnlyApiCheck(this, L"ScaleTransition"));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_ScaleTransition, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_Shadow(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::Media::IShadow** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_Shadow, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_Shadow(_In_opt_ ABI::Microsoft::UI::Xaml::Media::IShadow* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_Shadow, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_TabFocusNavigation(_Out_ ABI::Microsoft::UI::Xaml::Input::KeyboardNavigationMode* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_TabFocusNavigation, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_TabFocusNavigation(_In_ ABI::Microsoft::UI::Xaml::Input::KeyboardNavigationMode value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_TabFocusNavigation, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_TabIndex(_Out_ INT* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_TabIndex, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_TabIndex(_In_ INT value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_TabIndex, value));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_ThemeShadowReceiverCount(_Out_ INT* pValue)
{
    *pValue = SimpleProperty::Property::id<KnownPropertyIndex::UIElement_ThemeShadowReceiverCount>::Get(GetHandle());
    return S_OK;
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_ThemeShadowReceiverCount(_In_ INT value)
{
    SimpleProperty::Property::id<KnownPropertyIndex::UIElement_ThemeShadowReceiverCount>::Set(GetHandle(), value);
    return S_OK;
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_Transform3D(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::Media::Media3D::ITransform3D** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_Transform3D, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_Transform3D(_In_opt_ ABI::Microsoft::UI::Xaml::Media::Media3D::ITransform3D* pValue)
{
    IFC_RETURN(NonStrictOnlyApiCheck(this, L"Transform3D"));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_Transform3D, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_TransformMatrix(_Out_ ABI::Windows::Foundation::Numerics::Matrix4x4* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_TransformMatrixImpl(pValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_TransformMatrix(_In_ ABI::Windows::Foundation::Numerics::Matrix4x4 value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(StrictOnlyApiCheck(this, L"TransformMatrix"));
    IFC(static_cast<UIElement*>(this)->put_TransformMatrixImpl(value));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_Transitions(_Outptr_result_maybenull_ ABI::Windows::Foundation::Collections::IVector<ABI::Microsoft::UI::Xaml::Media::Animation::Transition*>** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_Transitions, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_Transitions(_In_opt_ ABI::Windows::Foundation::Collections::IVector<ABI::Microsoft::UI::Xaml::Media::Animation::Transition*>* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_Transitions, pValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::get_TransitionTarget(_Outptr_result_maybenull_ DirectUI::TransitionTarget** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_TransitionTarget, ppValue));
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::put_TransitionTarget(_In_opt_ DirectUI::TransitionTarget* pValue)
{
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_TransitionTarget, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_Translation(_Out_ ABI::Windows::Foundation::Numerics::Vector3* pValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(pValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_TranslationImpl(pValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_Translation(_In_ ABI::Windows::Foundation::Numerics::Vector3 value)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->put_TranslationImpl(value));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_TranslationTransition(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IVector3Transition** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_TranslationTransition, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_TranslationTransition(_In_opt_ ABI::Microsoft::UI::Xaml::IVector3Transition* pValue)
{
    IFC_RETURN(StrictOnlyApiCheck(this, L"TranslationTransition"));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_TranslationTransition, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_UseLayoutRounding(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_UseLayoutRounding, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_UseLayoutRounding(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_UseLayoutRounding, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_UseSystemFocusVisuals(_Out_ BOOLEAN* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_UseSystemFocusVisuals, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_UseSystemFocusVisuals(_In_ BOOLEAN value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_UseSystemFocusVisuals, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_Visibility(_Out_ ABI::Microsoft::UI::Xaml::Visibility* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_Visibility, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_Visibility(_In_ ABI::Microsoft::UI::Xaml::Visibility value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_Visibility, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_XamlRoot(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IXamlRoot** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    IFC(CheckThread());
    IFC(static_cast<UIElement*>(this)->get_XamlRootImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_XamlRoot(_In_opt_ ABI::Microsoft::UI::Xaml::IXamlRoot* pValue)
{
    HRESULT hr = S_OK;
    
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->put_XamlRootImpl(pValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_XYFocusDown(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IDependencyObject** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusDown, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_XYFocusDown(_In_opt_ ABI::Microsoft::UI::Xaml::IDependencyObject* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusDown, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_XYFocusDownNavigationStrategy(_Out_ ABI::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusDownNavigationStrategy, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_XYFocusDownNavigationStrategy(_In_ ABI::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusDownNavigationStrategy, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_XYFocusKeyboardNavigation(_Out_ ABI::Microsoft::UI::Xaml::Input::XYFocusKeyboardNavigationMode* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusKeyboardNavigation, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_XYFocusKeyboardNavigation(_In_ ABI::Microsoft::UI::Xaml::Input::XYFocusKeyboardNavigationMode value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusKeyboardNavigation, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_XYFocusLeft(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IDependencyObject** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusLeft, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_XYFocusLeft(_In_opt_ ABI::Microsoft::UI::Xaml::IDependencyObject* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusLeft, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_XYFocusLeftNavigationStrategy(_Out_ ABI::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusLeftNavigationStrategy, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_XYFocusLeftNavigationStrategy(_In_ ABI::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusLeftNavigationStrategy, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_XYFocusRight(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IDependencyObject** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusRight, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_XYFocusRight(_In_opt_ ABI::Microsoft::UI::Xaml::IDependencyObject* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusRight, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_XYFocusRightNavigationStrategy(_Out_ ABI::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusRightNavigationStrategy, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_XYFocusRightNavigationStrategy(_In_ ABI::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusRightNavigationStrategy, value));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_XYFocusUp(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IDependencyObject** ppValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusUp, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_XYFocusUp(_In_opt_ ABI::Microsoft::UI::Xaml::IDependencyObject* pValue)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusUp, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::get_XYFocusUpNavigationStrategy(_Out_ ABI::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy* pValue)
{
    RRETURN(GetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusUpNavigationStrategy, pValue));
}
IFACEMETHODIMP DirectUI::UIElementGenerated::put_XYFocusUpNavigationStrategy(_In_ ABI::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy value)
{
    IFC_RETURN(DefaultStrictApiCheck(this));
    RRETURN(SetValueByKnownIndex(KnownPropertyIndex::UIElement_XYFocusUpNavigationStrategy, value));
}

// Events.
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetAccessKeyDisplayDismissedEventSourceNoRef(_Outptr_ AccessKeyDisplayDismissedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_AccessKeyDisplayDismissed, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<AccessKeyDisplayDismissedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_AccessKeyDisplayDismissed, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_AccessKeyDisplayDismissed, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_AccessKeyDisplayDismissed(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    AccessKeyDisplayDismissedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetAccessKeyDisplayDismissedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_AccessKeyDisplayDismissed(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    AccessKeyDisplayDismissedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetAccessKeyDisplayDismissedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_AccessKeyDisplayDismissed));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetAccessKeyDisplayRequestedEventSourceNoRef(_Outptr_ AccessKeyDisplayRequestedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_AccessKeyDisplayRequested, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<AccessKeyDisplayRequestedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_AccessKeyDisplayRequested, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_AccessKeyDisplayRequested, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_AccessKeyDisplayRequested(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    AccessKeyDisplayRequestedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetAccessKeyDisplayRequestedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_AccessKeyDisplayRequested(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    AccessKeyDisplayRequestedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetAccessKeyDisplayRequestedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_AccessKeyDisplayRequested));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetAccessKeyInvokedEventSourceNoRef(_Outptr_ AccessKeyInvokedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_AccessKeyInvoked, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<AccessKeyInvokedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_AccessKeyInvoked, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_AccessKeyInvoked, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_AccessKeyInvoked(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::AccessKeyInvokedEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    AccessKeyInvokedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetAccessKeyInvokedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_AccessKeyInvoked(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    AccessKeyInvokedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::AccessKeyInvokedEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::AccessKeyInvokedEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetAccessKeyInvokedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_AccessKeyInvoked));
    }

Cleanup:
    RRETURN(hr);
}
void DirectUI::UIElementGenerated::SimplePropertyChangedHandler_AnimatedCenterPointChanged(SimpleProperty::objid_t obj)
{
    IFCFAILFAST((DependencyObject::RaiseSimplePropertyChangedNotification<UIElement, AnimatedCenterPointChangedEventSourceType>(
        obj,
        KnownEventIndex::UIElement_AnimatedCenterPointChanged,
        nullptr)));
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetAnimatedCenterPointChangedEventSourceNoRef(_Outptr_ AnimatedCenterPointChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_AnimatedCenterPointChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<AnimatedCenterPointChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_AnimatedCenterPointChanged, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_AnimatedCenterPointChanged, *ppEventSource));
        SimpleProperty::Property::RegisterHandler(KnownPropertyIndex::UIElement_AnimatedCenterPoint, &SimplePropertyChangedHandler_AnimatedCenterPointChanged);

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::add_AnimatedCenterPointChanged(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    AnimatedCenterPointChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));

    IFC(GetAnimatedCenterPointChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::remove_AnimatedCenterPointChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    AnimatedCenterPointChangedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(GetAnimatedCenterPointChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        SimpleProperty::Property::UnregisterHandler(KnownPropertyIndex::UIElement_AnimatedCenterPoint, &SimplePropertyChangedHandler_AnimatedCenterPointChanged);
        IFC(RemoveEventSource(KnownEventIndex::UIElement_AnimatedCenterPointChanged));
    }

Cleanup:
    RRETURN(hr);
}
void DirectUI::UIElementGenerated::SimplePropertyChangedHandler_AnimatedRotationAxisChanged(SimpleProperty::objid_t obj)
{
    IFCFAILFAST((DependencyObject::RaiseSimplePropertyChangedNotification<UIElement, AnimatedRotationAxisChangedEventSourceType>(
        obj,
        KnownEventIndex::UIElement_AnimatedRotationAxisChanged,
        nullptr)));
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetAnimatedRotationAxisChangedEventSourceNoRef(_Outptr_ AnimatedRotationAxisChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_AnimatedRotationAxisChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<AnimatedRotationAxisChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_AnimatedRotationAxisChanged, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_AnimatedRotationAxisChanged, *ppEventSource));
        SimpleProperty::Property::RegisterHandler(KnownPropertyIndex::UIElement_AnimatedRotationAxis, &SimplePropertyChangedHandler_AnimatedRotationAxisChanged);

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::add_AnimatedRotationAxisChanged(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    AnimatedRotationAxisChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));

    IFC(GetAnimatedRotationAxisChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::remove_AnimatedRotationAxisChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    AnimatedRotationAxisChangedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(GetAnimatedRotationAxisChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        SimpleProperty::Property::UnregisterHandler(KnownPropertyIndex::UIElement_AnimatedRotationAxis, &SimplePropertyChangedHandler_AnimatedRotationAxisChanged);
        IFC(RemoveEventSource(KnownEventIndex::UIElement_AnimatedRotationAxisChanged));
    }

Cleanup:
    RRETURN(hr);
}
void DirectUI::UIElementGenerated::SimplePropertyChangedHandler_AnimatedRotationChanged(SimpleProperty::objid_t obj)
{
    IFCFAILFAST((DependencyObject::RaiseSimplePropertyChangedNotification<UIElement, AnimatedRotationChangedEventSourceType>(
        obj,
        KnownEventIndex::UIElement_AnimatedRotationChanged,
        nullptr)));
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetAnimatedRotationChangedEventSourceNoRef(_Outptr_ AnimatedRotationChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_AnimatedRotationChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<AnimatedRotationChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_AnimatedRotationChanged, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_AnimatedRotationChanged, *ppEventSource));
        SimpleProperty::Property::RegisterHandler(KnownPropertyIndex::UIElement_AnimatedRotation, &SimplePropertyChangedHandler_AnimatedRotationChanged);

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::add_AnimatedRotationChanged(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    AnimatedRotationChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));

    IFC(GetAnimatedRotationChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::remove_AnimatedRotationChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    AnimatedRotationChangedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(GetAnimatedRotationChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        SimpleProperty::Property::UnregisterHandler(KnownPropertyIndex::UIElement_AnimatedRotation, &SimplePropertyChangedHandler_AnimatedRotationChanged);
        IFC(RemoveEventSource(KnownEventIndex::UIElement_AnimatedRotationChanged));
    }

Cleanup:
    RRETURN(hr);
}
void DirectUI::UIElementGenerated::SimplePropertyChangedHandler_AnimatedScaleChanged(SimpleProperty::objid_t obj)
{
    IFCFAILFAST((DependencyObject::RaiseSimplePropertyChangedNotification<UIElement, AnimatedScaleChangedEventSourceType>(
        obj,
        KnownEventIndex::UIElement_AnimatedScaleChanged,
        nullptr)));
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetAnimatedScaleChangedEventSourceNoRef(_Outptr_ AnimatedScaleChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_AnimatedScaleChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<AnimatedScaleChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_AnimatedScaleChanged, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_AnimatedScaleChanged, *ppEventSource));
        SimpleProperty::Property::RegisterHandler(KnownPropertyIndex::UIElement_AnimatedScale, &SimplePropertyChangedHandler_AnimatedScaleChanged);

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::add_AnimatedScaleChanged(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    AnimatedScaleChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));

    IFC(GetAnimatedScaleChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::remove_AnimatedScaleChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    AnimatedScaleChangedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(GetAnimatedScaleChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        SimpleProperty::Property::UnregisterHandler(KnownPropertyIndex::UIElement_AnimatedScale, &SimplePropertyChangedHandler_AnimatedScaleChanged);
        IFC(RemoveEventSource(KnownEventIndex::UIElement_AnimatedScaleChanged));
    }

Cleanup:
    RRETURN(hr);
}
void DirectUI::UIElementGenerated::SimplePropertyChangedHandler_AnimatedTransformMatrixChanged(SimpleProperty::objid_t obj)
{
    IFCFAILFAST((DependencyObject::RaiseSimplePropertyChangedNotification<UIElement, AnimatedTransformMatrixChangedEventSourceType>(
        obj,
        KnownEventIndex::UIElement_AnimatedTransformMatrixChanged,
        nullptr)));
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetAnimatedTransformMatrixChangedEventSourceNoRef(_Outptr_ AnimatedTransformMatrixChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_AnimatedTransformMatrixChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<AnimatedTransformMatrixChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_AnimatedTransformMatrixChanged, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_AnimatedTransformMatrixChanged, *ppEventSource));
        SimpleProperty::Property::RegisterHandler(KnownPropertyIndex::UIElement_AnimatedTransformMatrix, &SimplePropertyChangedHandler_AnimatedTransformMatrixChanged);

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::add_AnimatedTransformMatrixChanged(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    AnimatedTransformMatrixChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));

    IFC(GetAnimatedTransformMatrixChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::remove_AnimatedTransformMatrixChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    AnimatedTransformMatrixChangedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(GetAnimatedTransformMatrixChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        SimpleProperty::Property::UnregisterHandler(KnownPropertyIndex::UIElement_AnimatedTransformMatrix, &SimplePropertyChangedHandler_AnimatedTransformMatrixChanged);
        IFC(RemoveEventSource(KnownEventIndex::UIElement_AnimatedTransformMatrixChanged));
    }

Cleanup:
    RRETURN(hr);
}
void DirectUI::UIElementGenerated::SimplePropertyChangedHandler_AnimatedTranslationChanged(SimpleProperty::objid_t obj)
{
    IFCFAILFAST((DependencyObject::RaiseSimplePropertyChangedNotification<UIElement, AnimatedTranslationChangedEventSourceType>(
        obj,
        KnownEventIndex::UIElement_AnimatedTranslationChanged,
        nullptr)));
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetAnimatedTranslationChangedEventSourceNoRef(_Outptr_ AnimatedTranslationChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_AnimatedTranslationChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<AnimatedTranslationChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_AnimatedTranslationChanged, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_AnimatedTranslationChanged, *ppEventSource));
        SimpleProperty::Property::RegisterHandler(KnownPropertyIndex::UIElement_AnimatedTranslation, &SimplePropertyChangedHandler_AnimatedTranslationChanged);

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::add_AnimatedTranslationChanged(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    AnimatedTranslationChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));

    IFC(GetAnimatedTranslationChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::remove_AnimatedTranslationChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    AnimatedTranslationChangedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(GetAnimatedTranslationChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        SimpleProperty::Property::UnregisterHandler(KnownPropertyIndex::UIElement_AnimatedTranslation, &SimplePropertyChangedHandler_AnimatedTranslationChanged);
        IFC(RemoveEventSource(KnownEventIndex::UIElement_AnimatedTranslationChanged));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetBringIntoViewRequestedEventSourceNoRef(_Outptr_ BringIntoViewRequestedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_BringIntoViewRequested, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<BringIntoViewRequestedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_BringIntoViewRequested, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_BringIntoViewRequested, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_BringIntoViewRequested(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::BringIntoViewRequestedEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    BringIntoViewRequestedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetBringIntoViewRequestedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_BringIntoViewRequested(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    BringIntoViewRequestedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::BringIntoViewRequestedEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::BringIntoViewRequestedEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetBringIntoViewRequestedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_BringIntoViewRequested));
    }

Cleanup:
    RRETURN(hr);
}
#if WI_IS_FEATURE_PRESENT(Feature_XamlMotionSystemHoldbacks)
void DirectUI::UIElementGenerated::SimplePropertyChangedHandler_CenterPointChanged(SimpleProperty::objid_t obj)
{
    IFCFAILFAST((DependencyObject::RaiseSimplePropertyChangedNotification<UIElement, CenterPointChangedEventSourceType>(
        obj,
        KnownEventIndex::UIElement_CenterPointChanged,
        nullptr)));
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetCenterPointChangedEventSourceNoRef(_Outptr_ CenterPointChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_CenterPointChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<CenterPointChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_CenterPointChanged, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_CenterPointChanged, *ppEventSource));
        SimpleProperty::Property::RegisterHandler(KnownPropertyIndex::UIElement_CenterPoint, &SimplePropertyChangedHandler_CenterPointChanged);

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::add_CenterPointChanged(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    CenterPointChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(StrictOnlyApiCheck(this, L"CenterPointChanged"));
    IFC(GetCenterPointChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::remove_CenterPointChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    CenterPointChangedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(StrictOnlyApiCheck(this, L"CenterPointChanged"));
    IFC(GetCenterPointChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        SimpleProperty::Property::UnregisterHandler(KnownPropertyIndex::UIElement_CenterPoint, &SimplePropertyChangedHandler_CenterPointChanged);
        IFC(RemoveEventSource(KnownEventIndex::UIElement_CenterPointChanged));
    }

Cleanup:
    RRETURN(hr);
}
#endif
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetCharacterReceivedEventSourceNoRef(_Outptr_ CharacterReceivedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_CharacterReceived, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<CharacterReceivedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_CharacterReceived, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_CharacterReceived, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_CharacterReceived(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    CharacterReceivedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetCharacterReceivedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_CharacterReceived(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    CharacterReceivedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetCharacterReceivedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_CharacterReceived));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetContextCanceledEventSourceNoRef(_Outptr_ ContextCanceledEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_ContextCanceled, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<ContextCanceledEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_ContextCanceled, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_ContextCanceled, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_ContextCanceled(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::RoutedEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    ContextCanceledEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetContextCanceledEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_ContextCanceled(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    ContextCanceledEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::RoutedEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::RoutedEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetContextCanceledEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_ContextCanceled));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetContextRequestedEventSourceNoRef(_Outptr_ ContextRequestedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_ContextRequested, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<ContextRequestedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_ContextRequested, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_ContextRequested, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_ContextRequested(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    ContextRequestedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetContextRequestedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_ContextRequested(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    ContextRequestedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetContextRequestedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_ContextRequested));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetDoubleTappedEventSourceNoRef(_Outptr_ DoubleTappedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_DoubleTapped, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<DoubleTappedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_DoubleTapped, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_DoubleTapped, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_DoubleTapped(_In_ ABI::Microsoft::UI::Xaml::Input::IDoubleTappedEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    DoubleTappedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDoubleTappedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_DoubleTapped(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    DoubleTappedEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IDoubleTappedEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IDoubleTappedEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDoubleTappedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_DoubleTapped));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetDragEnterEventSourceNoRef(_Outptr_ DragEnterEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_DragEnter, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<DragEnterEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_DragEnter, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_DragEnter, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_DragEnter(_In_ ABI::Microsoft::UI::Xaml::IDragEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    DragEnterEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDragEnterEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_DragEnter(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    DragEnterEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::IDragEventHandler* pValue = (ABI::Microsoft::UI::Xaml::IDragEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDragEnterEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_DragEnter));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetDragLeaveEventSourceNoRef(_Outptr_ DragLeaveEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_DragLeave, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<DragLeaveEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_DragLeave, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_DragLeave, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_DragLeave(_In_ ABI::Microsoft::UI::Xaml::IDragEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    DragLeaveEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDragLeaveEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_DragLeave(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    DragLeaveEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::IDragEventHandler* pValue = (ABI::Microsoft::UI::Xaml::IDragEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDragLeaveEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_DragLeave));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetDragOverEventSourceNoRef(_Outptr_ DragOverEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_DragOver, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<DragOverEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_DragOver, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_DragOver, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_DragOver(_In_ ABI::Microsoft::UI::Xaml::IDragEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    DragOverEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDragOverEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_DragOver(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    DragOverEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::IDragEventHandler* pValue = (ABI::Microsoft::UI::Xaml::IDragEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDragOverEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_DragOver));
    }

Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::add_DragStarting(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::DragStartingEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    DragStartingEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDragStartingEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_DragStarting(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    DragStartingEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::DragStartingEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::DragStartingEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDragStartingEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_DragStarting));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetDropEventSourceNoRef(_Outptr_ DropEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_Drop, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<DropEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_Drop, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_Drop, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_Drop(_In_ ABI::Microsoft::UI::Xaml::IDragEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    DropEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDropEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_Drop(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    DropEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::IDragEventHandler* pValue = (ABI::Microsoft::UI::Xaml::IDragEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDropEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_Drop));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetDropCompletedEventSourceNoRef(_Outptr_ DropCompletedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_DropCompleted, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<DropCompletedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_DropCompleted, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_DropCompleted, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_DropCompleted(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::DropCompletedEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    DropCompletedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDropCompletedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_DropCompleted(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    DropCompletedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::DropCompletedEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::DropCompletedEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetDropCompletedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_DropCompleted));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetGettingFocusEventSourceNoRef(_Outptr_ GettingFocusEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_GettingFocus, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<GettingFocusEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_GettingFocus, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_GettingFocus, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_GettingFocus(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::GettingFocusEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    GettingFocusEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetGettingFocusEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_GettingFocus(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    GettingFocusEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::GettingFocusEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::GettingFocusEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetGettingFocusEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_GettingFocus));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetGotFocusEventSourceNoRef(_Outptr_ GotFocusEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_GotFocus, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<GotFocusEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_GotFocus, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_GotFocus, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_GotFocus(_In_ ABI::Microsoft::UI::Xaml::IRoutedEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    GotFocusEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetGotFocusEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_GotFocus(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    GotFocusEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::IRoutedEventHandler* pValue = (ABI::Microsoft::UI::Xaml::IRoutedEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetGotFocusEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_GotFocus));
    }

Cleanup:
    RRETURN(hr);
}
#if WI_IS_FEATURE_PRESENT(Feature_XamlMotionSystemHoldbacks)
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetHiddenEventSourceNoRef(_Outptr_ HiddenEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_Hidden, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<HiddenEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_Hidden, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_Hidden, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::add_Hidden(_In_ ABI::Windows::Foundation::IEventHandler<IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    HiddenEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetHiddenEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::remove_Hidden(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    HiddenEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::IEventHandler<IInspectable*>* pValue = (ABI::Windows::Foundation::IEventHandler<IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetHiddenEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_Hidden));
    }

Cleanup:
    RRETURN(hr);
}
#endif
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetHoldingEventSourceNoRef(_Outptr_ HoldingEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_Holding, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<HoldingEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_Holding, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_Holding, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_Holding(_In_ ABI::Microsoft::UI::Xaml::Input::IHoldingEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    HoldingEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetHoldingEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_Holding(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    HoldingEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IHoldingEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IHoldingEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetHoldingEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_Holding));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetKeyDownEventSourceNoRef(_Outptr_ KeyDownEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_KeyDown, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<KeyDownEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_KeyDown, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_KeyDown, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_KeyDown(_In_ ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    KeyDownEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetKeyDownEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_KeyDown(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    KeyDownEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetKeyDownEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_KeyDown));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetKeyUpEventSourceNoRef(_Outptr_ KeyUpEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_KeyUp, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<KeyUpEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_KeyUp, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_KeyUp, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_KeyUp(_In_ ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    KeyUpEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetKeyUpEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_KeyUp(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    KeyUpEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetKeyUpEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_KeyUp));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetLosingFocusEventSourceNoRef(_Outptr_ LosingFocusEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_LosingFocus, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<LosingFocusEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_LosingFocus, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_LosingFocus, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_LosingFocus(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::LosingFocusEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    LosingFocusEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetLosingFocusEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_LosingFocus(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    LosingFocusEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::LosingFocusEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::LosingFocusEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetLosingFocusEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_LosingFocus));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetLostFocusEventSourceNoRef(_Outptr_ LostFocusEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_LostFocus, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<LostFocusEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_LostFocus, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_LostFocus, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_LostFocus(_In_ ABI::Microsoft::UI::Xaml::IRoutedEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    LostFocusEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetLostFocusEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_LostFocus(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    LostFocusEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::IRoutedEventHandler* pValue = (ABI::Microsoft::UI::Xaml::IRoutedEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetLostFocusEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_LostFocus));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetManipulationCompletedEventSourceNoRef(_Outptr_ ManipulationCompletedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_ManipulationCompleted, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<ManipulationCompletedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_ManipulationCompleted, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_ManipulationCompleted, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_ManipulationCompleted(_In_ ABI::Microsoft::UI::Xaml::Input::IManipulationCompletedEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    ManipulationCompletedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetManipulationCompletedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_ManipulationCompleted(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    ManipulationCompletedEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IManipulationCompletedEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IManipulationCompletedEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetManipulationCompletedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_ManipulationCompleted));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetManipulationDeltaEventSourceNoRef(_Outptr_ ManipulationDeltaEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_ManipulationDelta, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<ManipulationDeltaEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_ManipulationDelta, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_ManipulationDelta, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_ManipulationDelta(_In_ ABI::Microsoft::UI::Xaml::Input::IManipulationDeltaEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    ManipulationDeltaEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetManipulationDeltaEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_ManipulationDelta(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    ManipulationDeltaEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IManipulationDeltaEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IManipulationDeltaEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetManipulationDeltaEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_ManipulationDelta));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetManipulationInertiaStartingEventSourceNoRef(_Outptr_ ManipulationInertiaStartingEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_ManipulationInertiaStarting, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<ManipulationInertiaStartingEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_ManipulationInertiaStarting, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_ManipulationInertiaStarting, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_ManipulationInertiaStarting(_In_ ABI::Microsoft::UI::Xaml::Input::IManipulationInertiaStartingEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    ManipulationInertiaStartingEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetManipulationInertiaStartingEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_ManipulationInertiaStarting(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    ManipulationInertiaStartingEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IManipulationInertiaStartingEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IManipulationInertiaStartingEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetManipulationInertiaStartingEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_ManipulationInertiaStarting));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetManipulationStartedEventSourceNoRef(_Outptr_ ManipulationStartedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_ManipulationStarted, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<ManipulationStartedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_ManipulationStarted, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_ManipulationStarted, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_ManipulationStarted(_In_ ABI::Microsoft::UI::Xaml::Input::IManipulationStartedEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    ManipulationStartedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetManipulationStartedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_ManipulationStarted(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    ManipulationStartedEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IManipulationStartedEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IManipulationStartedEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetManipulationStartedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_ManipulationStarted));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetManipulationStartingEventSourceNoRef(_Outptr_ ManipulationStartingEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_ManipulationStarting, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<ManipulationStartingEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_ManipulationStarting, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_ManipulationStarting, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_ManipulationStarting(_In_ ABI::Microsoft::UI::Xaml::Input::IManipulationStartingEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    ManipulationStartingEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetManipulationStartingEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_ManipulationStarting(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    ManipulationStartingEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IManipulationStartingEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IManipulationStartingEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetManipulationStartingEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_ManipulationStarting));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetNoFocusCandidateFoundEventSourceNoRef(_Outptr_ NoFocusCandidateFoundEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_NoFocusCandidateFound, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<NoFocusCandidateFoundEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_NoFocusCandidateFound, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_NoFocusCandidateFound, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_NoFocusCandidateFound(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    NoFocusCandidateFoundEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetNoFocusCandidateFoundEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_NoFocusCandidateFound(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    NoFocusCandidateFoundEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetNoFocusCandidateFoundEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_NoFocusCandidateFound));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetPointerCanceledEventSourceNoRef(_Outptr_ PointerCanceledEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_PointerCanceled, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<PointerCanceledEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_PointerCanceled, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_PointerCanceled, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_PointerCanceled(_In_ ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    PointerCanceledEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerCanceledEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_PointerCanceled(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    PointerCanceledEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerCanceledEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_PointerCanceled));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetPointerCaptureLostEventSourceNoRef(_Outptr_ PointerCaptureLostEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_PointerCaptureLost, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<PointerCaptureLostEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_PointerCaptureLost, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_PointerCaptureLost, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_PointerCaptureLost(_In_ ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    PointerCaptureLostEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerCaptureLostEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_PointerCaptureLost(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    PointerCaptureLostEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerCaptureLostEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_PointerCaptureLost));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetPointerEnteredEventSourceNoRef(_Outptr_ PointerEnteredEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_PointerEntered, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<PointerEnteredEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_PointerEntered, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_PointerEntered, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_PointerEntered(_In_ ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    PointerEnteredEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerEnteredEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_PointerEntered(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    PointerEnteredEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerEnteredEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_PointerEntered));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetPointerExitedEventSourceNoRef(_Outptr_ PointerExitedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_PointerExited, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<PointerExitedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_PointerExited, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_PointerExited, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_PointerExited(_In_ ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    PointerExitedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerExitedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_PointerExited(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    PointerExitedEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerExitedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_PointerExited));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetPointerMovedEventSourceNoRef(_Outptr_ PointerMovedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_PointerMoved, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<PointerMovedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_PointerMoved, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_PointerMoved, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_PointerMoved(_In_ ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    PointerMovedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerMovedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_PointerMoved(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    PointerMovedEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerMovedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_PointerMoved));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetPointerPressedEventSourceNoRef(_Outptr_ PointerPressedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_PointerPressed, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<PointerPressedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_PointerPressed, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_PointerPressed, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_PointerPressed(_In_ ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    PointerPressedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerPressedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_PointerPressed(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    PointerPressedEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerPressedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_PointerPressed));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetPointerReleasedEventSourceNoRef(_Outptr_ PointerReleasedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_PointerReleased, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<PointerReleasedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_PointerReleased, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_PointerReleased, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_PointerReleased(_In_ ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    PointerReleasedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerReleasedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_PointerReleased(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    PointerReleasedEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerReleasedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_PointerReleased));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetPointerWheelChangedEventSourceNoRef(_Outptr_ PointerWheelChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_PointerWheelChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<PointerWheelChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_PointerWheelChanged, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_PointerWheelChanged, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_PointerWheelChanged(_In_ ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    PointerWheelChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerWheelChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_PointerWheelChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    PointerWheelChangedEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPointerWheelChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_PointerWheelChanged));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetPreviewKeyDownEventSourceNoRef(_Outptr_ PreviewKeyDownEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_PreviewKeyDown, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<PreviewKeyDownEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_PreviewKeyDown, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_PreviewKeyDown, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_PreviewKeyDown(_In_ ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    PreviewKeyDownEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPreviewKeyDownEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_PreviewKeyDown(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    PreviewKeyDownEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPreviewKeyDownEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_PreviewKeyDown));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetPreviewKeyUpEventSourceNoRef(_Outptr_ PreviewKeyUpEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_PreviewKeyUp, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<PreviewKeyUpEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_PreviewKeyUp, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_PreviewKeyUp, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_PreviewKeyUp(_In_ ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    PreviewKeyUpEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPreviewKeyUpEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_PreviewKeyUp(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    PreviewKeyUpEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetPreviewKeyUpEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_PreviewKeyUp));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetProcessKeyboardAcceleratorsEventSourceNoRef(_Outptr_ ProcessKeyboardAcceleratorsEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_ProcessKeyboardAccelerators, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<ProcessKeyboardAcceleratorsEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_ProcessKeyboardAccelerators, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_ProcessKeyboardAccelerators, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_ProcessKeyboardAccelerators(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    ProcessKeyboardAcceleratorsEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetProcessKeyboardAcceleratorsEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_ProcessKeyboardAccelerators(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    ProcessKeyboardAcceleratorsEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetProcessKeyboardAcceleratorsEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_ProcessKeyboardAccelerators));
    }

Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetRightTappedEventSourceNoRef(_Outptr_ RightTappedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_RightTapped, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<RightTappedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_RightTapped, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_RightTapped, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_RightTapped(_In_ ABI::Microsoft::UI::Xaml::Input::IRightTappedEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    RightTappedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetRightTappedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_RightTapped(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    RightTappedEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::IRightTappedEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::IRightTappedEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetRightTappedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_RightTapped));
    }

Cleanup:
    RRETURN(hr);
}
#if WI_IS_FEATURE_PRESENT(Feature_XamlMotionSystemHoldbacks)
void DirectUI::UIElementGenerated::SimplePropertyChangedHandler_RotationAxisChanged(SimpleProperty::objid_t obj)
{
    IFCFAILFAST((DependencyObject::RaiseSimplePropertyChangedNotification<UIElement, RotationAxisChangedEventSourceType>(
        obj,
        KnownEventIndex::UIElement_RotationAxisChanged,
        nullptr)));
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetRotationAxisChangedEventSourceNoRef(_Outptr_ RotationAxisChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_RotationAxisChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<RotationAxisChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_RotationAxisChanged, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_RotationAxisChanged, *ppEventSource));
        SimpleProperty::Property::RegisterHandler(KnownPropertyIndex::UIElement_RotationAxis, &SimplePropertyChangedHandler_RotationAxisChanged);

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::add_RotationAxisChanged(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    RotationAxisChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(StrictOnlyApiCheck(this, L"RotationAxisChanged"));
    IFC(GetRotationAxisChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::remove_RotationAxisChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    RotationAxisChangedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(StrictOnlyApiCheck(this, L"RotationAxisChanged"));
    IFC(GetRotationAxisChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        SimpleProperty::Property::UnregisterHandler(KnownPropertyIndex::UIElement_RotationAxis, &SimplePropertyChangedHandler_RotationAxisChanged);
        IFC(RemoveEventSource(KnownEventIndex::UIElement_RotationAxisChanged));
    }

Cleanup:
    RRETURN(hr);
}
#endif
#if WI_IS_FEATURE_PRESENT(Feature_XamlMotionSystemHoldbacks)
void DirectUI::UIElementGenerated::SimplePropertyChangedHandler_RotationChanged(SimpleProperty::objid_t obj)
{
    IFCFAILFAST((DependencyObject::RaiseSimplePropertyChangedNotification<UIElement, RotationChangedEventSourceType>(
        obj,
        KnownEventIndex::UIElement_RotationChanged,
        nullptr)));
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetRotationChangedEventSourceNoRef(_Outptr_ RotationChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_RotationChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<RotationChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_RotationChanged, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_RotationChanged, *ppEventSource));
        SimpleProperty::Property::RegisterHandler(KnownPropertyIndex::UIElement_Rotation, &SimplePropertyChangedHandler_RotationChanged);

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::add_RotationChanged(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    RotationChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(StrictOnlyApiCheck(this, L"RotationChanged"));
    IFC(GetRotationChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::remove_RotationChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    RotationChangedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(StrictOnlyApiCheck(this, L"RotationChanged"));
    IFC(GetRotationChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        SimpleProperty::Property::UnregisterHandler(KnownPropertyIndex::UIElement_Rotation, &SimplePropertyChangedHandler_RotationChanged);
        IFC(RemoveEventSource(KnownEventIndex::UIElement_RotationChanged));
    }

Cleanup:
    RRETURN(hr);
}
#endif
#if WI_IS_FEATURE_PRESENT(Feature_XamlMotionSystemHoldbacks)
void DirectUI::UIElementGenerated::SimplePropertyChangedHandler_ScaleChanged(SimpleProperty::objid_t obj)
{
    IFCFAILFAST((DependencyObject::RaiseSimplePropertyChangedNotification<UIElement, ScaleChangedEventSourceType>(
        obj,
        KnownEventIndex::UIElement_ScaleChanged,
        nullptr)));
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetScaleChangedEventSourceNoRef(_Outptr_ ScaleChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_ScaleChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<ScaleChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_ScaleChanged, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_ScaleChanged, *ppEventSource));
        SimpleProperty::Property::RegisterHandler(KnownPropertyIndex::UIElement_Scale, &SimplePropertyChangedHandler_ScaleChanged);

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::add_ScaleChanged(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    ScaleChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(StrictOnlyApiCheck(this, L"ScaleChanged"));
    IFC(GetScaleChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::remove_ScaleChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    ScaleChangedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(StrictOnlyApiCheck(this, L"ScaleChanged"));
    IFC(GetScaleChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        SimpleProperty::Property::UnregisterHandler(KnownPropertyIndex::UIElement_Scale, &SimplePropertyChangedHandler_ScaleChanged);
        IFC(RemoveEventSource(KnownEventIndex::UIElement_ScaleChanged));
    }

Cleanup:
    RRETURN(hr);
}
#endif
#if WI_IS_FEATURE_PRESENT(Feature_XamlMotionSystemHoldbacks)
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetShownEventSourceNoRef(_Outptr_ ShownEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_Shown, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<ShownEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_Shown, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_Shown, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::add_Shown(_In_ ABI::Windows::Foundation::IEventHandler<IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    ShownEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetShownEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::remove_Shown(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    ShownEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::IEventHandler<IInspectable*>* pValue = (ABI::Windows::Foundation::IEventHandler<IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetShownEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_Shown));
    }

Cleanup:
    RRETURN(hr);
}
#endif
_Check_return_ HRESULT DirectUI::UIElementGenerated::GetTappedEventSourceNoRef(_Outptr_ TappedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_Tapped, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<TappedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_Tapped, this, /* bUseEventManager */ true);
        IFC(StoreEventSource(KnownEventIndex::UIElement_Tapped, *ppEventSource));

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::add_Tapped(_In_ ABI::Microsoft::UI::Xaml::Input::ITappedEventHandler* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    TappedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetTappedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

IFACEMETHODIMP DirectUI::UIElementGenerated::remove_Tapped(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    TappedEventSourceType* pEventSource = nullptr;
    ABI::Microsoft::UI::Xaml::Input::ITappedEventHandler* pValue = (ABI::Microsoft::UI::Xaml::Input::ITappedEventHandler*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetTappedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        IFC(RemoveEventSource(KnownEventIndex::UIElement_Tapped));
    }

Cleanup:
    RRETURN(hr);
}
#if WI_IS_FEATURE_PRESENT(Feature_XamlMotionSystemHoldbacks)
void DirectUI::UIElementGenerated::SimplePropertyChangedHandler_TransformMatrixChanged(SimpleProperty::objid_t obj)
{
    IFCFAILFAST((DependencyObject::RaiseSimplePropertyChangedNotification<UIElement, TransformMatrixChangedEventSourceType>(
        obj,
        KnownEventIndex::UIElement_TransformMatrixChanged,
        nullptr)));
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetTransformMatrixChangedEventSourceNoRef(_Outptr_ TransformMatrixChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_TransformMatrixChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<TransformMatrixChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_TransformMatrixChanged, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_TransformMatrixChanged, *ppEventSource));
        SimpleProperty::Property::RegisterHandler(KnownPropertyIndex::UIElement_TransformMatrix, &SimplePropertyChangedHandler_TransformMatrixChanged);

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::add_TransformMatrixChanged(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    TransformMatrixChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(StrictOnlyApiCheck(this, L"TransformMatrixChanged"));
    IFC(GetTransformMatrixChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::remove_TransformMatrixChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    TransformMatrixChangedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(StrictOnlyApiCheck(this, L"TransformMatrixChanged"));
    IFC(GetTransformMatrixChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        SimpleProperty::Property::UnregisterHandler(KnownPropertyIndex::UIElement_TransformMatrix, &SimplePropertyChangedHandler_TransformMatrixChanged);
        IFC(RemoveEventSource(KnownEventIndex::UIElement_TransformMatrixChanged));
    }

Cleanup:
    RRETURN(hr);
}
#endif
#if WI_IS_FEATURE_PRESENT(Feature_XamlMotionSystemHoldbacks)
void DirectUI::UIElementGenerated::SimplePropertyChangedHandler_TranslationChanged(SimpleProperty::objid_t obj)
{
    IFCFAILFAST((DependencyObject::RaiseSimplePropertyChangedNotification<UIElement, TranslationChangedEventSourceType>(
        obj,
        KnownEventIndex::UIElement_TranslationChanged,
        nullptr)));
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetTranslationChangedEventSourceNoRef(_Outptr_ TranslationChangedEventSourceType** ppEventSource)
{
    HRESULT hr = S_OK;

    IFC(GetEventSourceNoRefWithArgumentValidation(KnownEventIndex::UIElement_TranslationChanged, reinterpret_cast<IUntypedEventSource**>(ppEventSource)));

    if (*ppEventSource == nullptr)
    {
        IFC(ctl::ComObject<TranslationChangedEventSourceType>::CreateInstance(ppEventSource, TRUE /* fDisableLeakChecks */));
        (*ppEventSource)->Initialize(KnownEventIndex::UIElement_TranslationChanged, this, /* bUseEventManager */ false);
        IFC(StoreEventSource(KnownEventIndex::UIElement_TranslationChanged, *ppEventSource));
        SimpleProperty::Property::RegisterHandler(KnownPropertyIndex::UIElement_Translation, &SimplePropertyChangedHandler_TranslationChanged);

        // The caller doesn't expect a ref, this function ends in "NoRef".  The ref is now owned by the map (inside StoreEventSource)
        ReleaseInterfaceNoNULL(ctl::iunknown_cast(*ppEventSource));
    }

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::add_TranslationChanged(_In_ ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue, _Out_ EventRegistrationToken* ptToken)
{
    HRESULT hr = S_OK;
    TranslationChangedEventSourceType* pEventSource = nullptr;

    IFC(EventAddPreValidation(pValue, ptToken));
    IFC(DefaultStrictApiCheck(this));
    IFC(GetTranslationChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->AddHandler(pValue));

    ptToken->value = (INT64)pValue;

Cleanup:
    return hr;
}

_Check_return_ HRESULT STDMETHODCALLTYPE DirectUI::UIElementGenerated::remove_TranslationChanged(_In_ EventRegistrationToken tToken)
{
    HRESULT hr = S_OK;
    TranslationChangedEventSourceType* pEventSource = nullptr;
    ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>* pValue = (ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, IInspectable*>*)tToken.value;

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(GetTranslationChangedEventSourceNoRef(&pEventSource));
    IFC(pEventSource->RemoveHandler(pValue));

    if (!pEventSource->HasHandlers())
    {
        SimpleProperty::Property::UnregisterHandler(KnownPropertyIndex::UIElement_Translation, &SimplePropertyChangedHandler_TranslationChanged);
        IFC(RemoveEventSource(KnownEventIndex::UIElement_TranslationChanged));
    }

Cleanup:
    RRETURN(hr);
}
#endif

// Methods.
IFACEMETHODIMP DirectUI::UIElementGenerated::AddHandler(_In_ ABI::Microsoft::UI::Xaml::IRoutedEvent* pRoutedEvent, _In_ IInspectable* pHandler, _In_ BOOLEAN handledEventsToo)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_AddHandler", 0);
    }
    ARG_NOTNULL(pRoutedEvent, "routedEvent");
    ARG_NOTNULL(pHandler, "handler");
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->AddHandlerImpl(pRoutedEvent, pHandler, handledEventsToo));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_AddHandler", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::Arrange(_In_ ABI::Windows::Foundation::Rect finalRect)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_Arrange", 0);
    }
    
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->ArrangeImpl(finalRect));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_Arrange", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::CancelDirectManipulations(_Out_ BOOLEAN* pReturnValue)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_CancelDirectManipulations", 0);
    }
    ARG_VALIDRETURNPOINTER(pReturnValue);
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->CancelDirectManipulationsImpl(pReturnValue));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_CancelDirectManipulations", hr);
    }
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::CaptureMouse(_Out_ BOOLEAN* pReturnValue)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_CaptureMouse", 0);
    }
    ARG_VALIDRETURNPOINTER(pReturnValue);
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_CaptureMouse", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::CapturePointer(_In_ ABI::Microsoft::UI::Xaml::Input::IPointer* pValue, _Out_ BOOLEAN* pReturnValue)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_CapturePointer", 0);
    }
    ARG_NOTNULL(pValue, "value");
    ARG_VALIDRETURNPOINTER(pReturnValue);
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->CapturePointerImpl(pValue, pReturnValue));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_CapturePointer", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::FindSubElementsForTouchTargeting(_In_ ABI::Windows::Foundation::Point point, _In_ ABI::Windows::Foundation::Rect boundingRect, _Outptr_ ABI::Windows::Foundation::Collections::IIterable<ABI::Windows::Foundation::Collections::IIterable<ABI::Windows::Foundation::Point>*>** ppReturnValue)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_FindSubElementsForTouchTargeting", 0);
    }
    ARG_VALIDRETURNPOINTER(ppReturnValue);
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->FindSubElementsForTouchTargetingImpl(point, boundingRect, ppReturnValue));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_FindSubElementsForTouchTargeting", hr);
    }
    RRETURN(hr);
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::FindSubElementsForTouchTargetingProtected(_In_ ABI::Windows::Foundation::Point point, _In_ ABI::Windows::Foundation::Rect boundingRect, _Outptr_ ABI::Windows::Foundation::Collections::IIterable<ABI::Windows::Foundation::Collections::IIterable<ABI::Windows::Foundation::Point>*>** ppReturnValue)
{
    HRESULT hr = S_OK;
    ABI::Microsoft::UI::Xaml::IUIElementOverrides* pVirtuals = NULL;

    if (IsComposed())
    {
        IFC(ctl::do_query_interface(pVirtuals, this));

        // SYNC_CALL_TO_APP DIRECT - This next line may directly call out to app code.
        IFC(pVirtuals->FindSubElementsForTouchTargeting(point, boundingRect, ppReturnValue));
    }
    else
    {
        IFC(FindSubElementsForTouchTargeting(point, boundingRect, ppReturnValue));
    }

Cleanup:
    ReleaseInterfaceNoNULL(pVirtuals);
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::Focus(_In_ ABI::Microsoft::UI::Xaml::FocusState value, _Out_ BOOLEAN* pReturnValue)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_Focus", 0);
    }
    ARG_VALIDRETURNPOINTER(pReturnValue);
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->FocusImpl(value, pReturnValue));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_Focus", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::FocusNoActivate(_In_ ABI::Microsoft::UI::Xaml::FocusState value, _Out_ BOOLEAN* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_FocusNoActivate", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->FocusNoActivateImpl(value, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_FocusNoActivate", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::GetChildrenInTabFocusOrder(_Outptr_ ABI::Windows::Foundation::Collections::IIterable<ABI::Microsoft::UI::Xaml::DependencyObject*>** ppReturnValue)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_GetChildrenInTabFocusOrder", 0);
    }
    ARG_VALIDRETURNPOINTER(ppReturnValue);
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->GetChildrenInTabFocusOrderImpl(ppReturnValue));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_GetChildrenInTabFocusOrder", hr);
    }
    RRETURN(hr);
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::GetChildrenInTabFocusOrderProtected(_Outptr_ ABI::Windows::Foundation::Collections::IIterable<ABI::Microsoft::UI::Xaml::DependencyObject*>** ppReturnValue)
{
    HRESULT hr = S_OK;
    ABI::Microsoft::UI::Xaml::IUIElementOverrides* pVirtuals = NULL;

    if (IsComposed())
    {
        IFC(ctl::do_query_interface(pVirtuals, this));

        // SYNC_CALL_TO_APP DIRECT - This next line may directly call out to app code.
        IFC(pVirtuals->GetChildrenInTabFocusOrder(ppReturnValue));
    }
    else
    {
        IFC(GetChildrenInTabFocusOrder(ppReturnValue));
    }

Cleanup:
    ReleaseInterfaceNoNULL(pVirtuals);
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::InvalidateArrange()
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_InvalidateArrange", 0);
    }
    
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->InvalidateArrangeImpl());
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_InvalidateArrange", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::InvalidateMeasure()
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_InvalidateMeasure", 0);
    }
    
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->InvalidateMeasureImpl());
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_InvalidateMeasure", hr);
    }
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::LayoutRound(_In_ FLOAT value, _Out_ FLOAT* pReturnValue)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_LayoutRound", 0);
    }

    FLOAT valueCore = value;
    FLOAT returnValueCore;

    ARG_VALIDRETURNPOINTER(pReturnValue);

    IFC(CheckThread());

    IFC(static_cast<CUIElement*>(GetHandle())->LayoutRound(valueCore, &returnValueCore));

    IFC(CValueBoxer::ConvertToFramework(returnValueCore, pReturnValue, /* fReleaseCoreValue */ TRUE));

Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_LayoutRound", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::Measure(_In_ ABI::Windows::Foundation::Size availableSize)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_Measure", 0);
    }
    
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->MeasureImpl(availableSize));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_Measure", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::OnBringIntoViewRequested(_In_ ABI::Microsoft::UI::Xaml::IBringIntoViewRequestedEventArgs* pE)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_OnBringIntoViewRequested", 0);
    }
    ARG_NOTNULL(pE, "e");
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->OnBringIntoViewRequestedImpl(pE));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_OnBringIntoViewRequested", hr);
    }
    RRETURN(hr);
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::OnBringIntoViewRequestedProtected(_In_ ABI::Microsoft::UI::Xaml::IBringIntoViewRequestedEventArgs* pE)
{
    HRESULT hr = S_OK;
    ABI::Microsoft::UI::Xaml::IUIElementOverrides* pVirtuals = NULL;

    if (IsComposed())
    {
        IFC(ctl::do_query_interface(pVirtuals, this));

        // SYNC_CALL_TO_APP DIRECT - This next line may directly call out to app code.
        IFC(pVirtuals->OnBringIntoViewRequested(pE));
    }
    else
    {
        IFC(OnBringIntoViewRequested(pE));
    }

Cleanup:
    ReleaseInterfaceNoNULL(pVirtuals);
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::OnCreateAutomationPeer(_Outptr_ ABI::Microsoft::UI::Xaml::Automation::Peers::IAutomationPeer** ppReturnValue)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_OnCreateAutomationPeer", 0);
    }
    ARG_VALIDRETURNPOINTER(ppReturnValue);
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->OnCreateAutomationPeerImpl(ppReturnValue));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_OnCreateAutomationPeer", hr);
    }
    RRETURN(hr);
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::OnCreateAutomationPeerProtected(_Outptr_ ABI::Microsoft::UI::Xaml::Automation::Peers::IAutomationPeer** ppReturnValue)
{
    HRESULT hr = S_OK;
    ABI::Microsoft::UI::Xaml::IUIElementOverrides* pVirtuals = NULL;

    if (IsComposed())
    {
        IFC(ctl::do_query_interface(pVirtuals, this));

        // SYNC_CALL_TO_APP DIRECT - This next line may directly call out to app code.
        IFC(pVirtuals->OnCreateAutomationPeer(ppReturnValue));
    }
    else
    {
        IFC(OnCreateAutomationPeer(ppReturnValue));
    }

Cleanup:
    ReleaseInterfaceNoNULL(pVirtuals);
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::OnDisconnectVisualChildren()
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_OnDisconnectVisualChildren", 0);
    }
    
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->OnDisconnectVisualChildrenImpl());
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_OnDisconnectVisualChildren", hr);
    }
    RRETURN(hr);
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::OnDisconnectVisualChildrenProtected()
{
    HRESULT hr = S_OK;
    ABI::Microsoft::UI::Xaml::IUIElementOverrides* pVirtuals = NULL;

    if (IsComposed())
    {
        IFC(ctl::do_query_interface(pVirtuals, this));

        // SYNC_CALL_TO_APP DIRECT - This next line may directly call out to app code.
        IFC(pVirtuals->OnDisconnectVisualChildren());
    }
    else
    {
        IFC(OnDisconnectVisualChildren());
    }

Cleanup:
    ReleaseInterfaceNoNULL(pVirtuals);
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::OnKeyboardAcceleratorInvoked(_In_ ABI::Microsoft::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs* pArgs)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_OnKeyboardAcceleratorInvoked", 0);
    }
    ARG_NOTNULL(pArgs, "args");
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->OnKeyboardAcceleratorInvokedImpl(pArgs));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_OnKeyboardAcceleratorInvoked", hr);
    }
    RRETURN(hr);
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::OnKeyboardAcceleratorInvokedProtected(_In_ ABI::Microsoft::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs* pArgs)
{
    HRESULT hr = S_OK;
    ABI::Microsoft::UI::Xaml::IUIElementOverrides* pVirtuals = NULL;

    if (IsComposed())
    {
        IFC(ctl::do_query_interface(pVirtuals, this));

        // SYNC_CALL_TO_APP DIRECT - This next line may directly call out to app code.
        IFC(pVirtuals->OnKeyboardAcceleratorInvoked(pArgs));
    }
    else
    {
        IFC(OnKeyboardAcceleratorInvoked(pArgs));
    }

Cleanup:
    ReleaseInterfaceNoNULL(pVirtuals);
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::OnProcessKeyboardAccelerators(_In_ ABI::Microsoft::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs* pArgs)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_OnProcessKeyboardAccelerators", 0);
    }
    ARG_NOTNULL(pArgs, "args");
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->OnProcessKeyboardAcceleratorsImpl(pArgs));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_OnProcessKeyboardAccelerators", hr);
    }
    RRETURN(hr);
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::OnProcessKeyboardAcceleratorsProtected(_In_ ABI::Microsoft::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs* pArgs)
{
    HRESULT hr = S_OK;
    ABI::Microsoft::UI::Xaml::IUIElementOverrides* pVirtuals = NULL;

    if (IsComposed())
    {
        IFC(ctl::do_query_interface(pVirtuals, this));

        // SYNC_CALL_TO_APP DIRECT - This next line may directly call out to app code.
        IFC(pVirtuals->OnProcessKeyboardAccelerators(pArgs));
    }
    else
    {
        IFC(OnProcessKeyboardAccelerators(pArgs));
    }

Cleanup:
    ReleaseInterfaceNoNULL(pVirtuals);
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::PopulatePropertyInfoOverride(_In_ HSTRING propertyName, _In_ ABI::Microsoft::UI::Composition::IAnimationPropertyInfo* pAnimationPropertyInfo)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_PopulatePropertyInfoOverride", 0);
    }
    ARG_NOTNULL(propertyName, "propertyName");
    ARG_NOTNULL(pAnimationPropertyInfo, "animationPropertyInfo");
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->PopulatePropertyInfoOverrideImpl(propertyName, pAnimationPropertyInfo));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_PopulatePropertyInfoOverride", hr);
    }
    RRETURN(hr);
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::PopulatePropertyInfoOverrideProtected(_In_ HSTRING propertyName, _In_ ABI::Microsoft::UI::Composition::IAnimationPropertyInfo* pAnimationPropertyInfo)
{
    HRESULT hr = S_OK;
    ABI::Microsoft::UI::Xaml::IUIElementOverrides* pVirtuals = NULL;

    if (IsComposed())
    {
        IFC(ctl::do_query_interface(pVirtuals, this));

        // SYNC_CALL_TO_APP DIRECT - This next line may directly call out to app code.
        IFC(pVirtuals->PopulatePropertyInfoOverride(propertyName, pAnimationPropertyInfo));
    }
    else
    {
        IFC(PopulatePropertyInfoOverride(propertyName, pAnimationPropertyInfo));
    }

Cleanup:
    ReleaseInterfaceNoNULL(pVirtuals);
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::ReleaseMouseCapture()
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_ReleaseMouseCapture", 0);
    }
    
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_ReleaseMouseCapture", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::ReleasePointerCapture(_In_ ABI::Microsoft::UI::Xaml::Input::IPointer* pValue)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_ReleasePointerCapture", 0);
    }

    CPointer* pValueCore = static_cast<CPointer*>(pValue ? static_cast<DirectUI::Pointer*>(pValue)->GetHandle() : nullptr);

    ARG_NOTNULL(pValue, "value");

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));

    IFC(static_cast<CUIElement*>(GetHandle())->ReleasePointerCapture(pValueCore));


Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_ReleasePointerCapture", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::ReleasePointerCaptures()
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_ReleasePointerCaptures", 0);
    }


    

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));

    IFC(static_cast<CUIElement*>(GetHandle())->ReleasePointerCaptures());


Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_ReleasePointerCaptures", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::RemoveHandler(_In_ ABI::Microsoft::UI::Xaml::IRoutedEvent* pRoutedEvent, _In_ IInspectable* pHandler)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_RemoveHandler", 0);
    }
    ARG_NOTNULL(pRoutedEvent, "routedEvent");
    ARG_NOTNULL(pHandler, "handler");
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->RemoveHandlerImpl(pRoutedEvent, pHandler));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_RemoveHandler", hr);
    }
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementGenerated::ResetGlobalScaleFactor()
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_ResetGlobalScaleFactor", 0);
    }


    

    IFC(CheckThread());

    IFC(static_cast<CUIElement*>(GetHandle())->ResetGlobalScaleFactor());


Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_ResetGlobalScaleFactor", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::StartAnimation(_In_ ABI::Microsoft::UI::Composition::ICompositionAnimationBase* pAnimation)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_StartAnimation", 0);
    }
    ARG_NOTNULL(pAnimation, "animation");
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->StartAnimationImpl(pAnimation));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_StartAnimation", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::StartBringIntoView()
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_StartBringIntoView", 0);
    }
    
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->StartBringIntoViewImpl());
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_StartBringIntoView", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::StartBringIntoViewWithOptions(_In_ ABI::Microsoft::UI::Xaml::IBringIntoViewOptions* pOptions)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_StartBringIntoViewWithOptions", 0);
    }
    ARG_NOTNULL(pOptions, "options");
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->StartBringIntoViewWithOptionsImpl(pOptions));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_StartBringIntoViewWithOptions", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::StartDragAsync(_In_ ABI::Microsoft::UI::Input::IPointerPoint* pPointerPoint, _Outptr_ ABI::Windows::Foundation::IAsyncOperation<ABI::Windows::ApplicationModel::DataTransfer::DataPackageOperation>** ppReturnValue)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_StartDragAsync", 0);
    }
    ARG_NOTNULL(pPointerPoint, "pointerPoint");
    ARG_VALIDRETURNPOINTER(ppReturnValue);
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->StartDragAsyncImpl(pPointerPoint, ppReturnValue));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_StartDragAsync", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::StopAnimation(_In_ ABI::Microsoft::UI::Composition::ICompositionAnimationBase* pAnimation)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_StopAnimation", 0);
    }
    ARG_NOTNULL(pAnimation, "animation");
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->StopAnimationImpl(pAnimation));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_StopAnimation", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::TransformToVisual(_In_opt_ ABI::Microsoft::UI::Xaml::IUIElement* pVisual, _Outptr_ ABI::Microsoft::UI::Xaml::Media::IGeneralTransform** ppReturnValue)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_TransformToVisual", 0);
    }
    ARG_VALIDRETURNPOINTER(ppReturnValue);
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->TransformToVisualImpl(pVisual, ppReturnValue));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_TransformToVisual", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::TryInvokeKeyboardAccelerator(_In_ ABI::Microsoft::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs* pArgs)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_TryInvokeKeyboardAccelerator", 0);
    }
    ARG_NOTNULL(pArgs, "args");
    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));
    IFC(static_cast<UIElement*>(this)->TryInvokeKeyboardAcceleratorImpl(pArgs));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_TryInvokeKeyboardAccelerator", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementGenerated::UpdateLayout()
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "UIElement_UpdateLayout", 0);
    }


    

    IFC(CheckThread());
    IFC(DefaultStrictApiCheck(this));

    IFC(static_cast<CUIElement*>(GetHandle())->UpdateLayout());


Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "UIElement_UpdateLayout", hr);
    }
    RRETURN(hr);
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::EventAddHandlerByIndex(_In_ KnownEventIndex nEventIndex, _In_ IInspectable* pHandler, _In_ BOOLEAN handledEventsToo)
{
    switch (nEventIndex)
    {
    case KnownEventIndex::UIElement_BringIntoViewRequested:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::BringIntoViewRequestedEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                BringIntoViewRequestedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetBringIntoViewRequestedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_CharacterReceived:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                CharacterReceivedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetCharacterReceivedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ContextCanceled:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::RoutedEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ContextCanceledEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetContextCanceledEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ContextRequested:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ContextRequestedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetContextRequestedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_DoubleTapped:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IDoubleTappedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DoubleTappedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDoubleTappedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_DragEnter:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::IDragEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DragEnterEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDragEnterEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_DragLeave:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::IDragEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DragLeaveEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDragLeaveEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_DragOver:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::IDragEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DragOverEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDragOverEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_DragStarting:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::DragStartingEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DragStartingEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDragStartingEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_Drop:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::IDragEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DropEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDropEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_DropCompleted:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::DropCompletedEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DropCompletedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDropCompletedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_GettingFocus:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::GettingFocusEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                GettingFocusEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetGettingFocusEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_GotFocus:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::IRoutedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                GotFocusEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetGotFocusEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_Holding:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IHoldingEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                HoldingEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetHoldingEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_KeyDown:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                KeyDownEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetKeyDownEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_KeyUp:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                KeyUpEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetKeyUpEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_LosingFocus:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::LosingFocusEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                LosingFocusEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetLosingFocusEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_LostFocus:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::IRoutedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                LostFocusEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetLostFocusEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ManipulationCompleted:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IManipulationCompletedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ManipulationCompletedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetManipulationCompletedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ManipulationDelta:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IManipulationDeltaEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ManipulationDeltaEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetManipulationDeltaEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ManipulationInertiaStarting:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IManipulationInertiaStartingEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ManipulationInertiaStartingEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetManipulationInertiaStartingEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ManipulationStarted:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IManipulationStartedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ManipulationStartedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetManipulationStartedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ManipulationStarting:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IManipulationStartingEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ManipulationStartingEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetManipulationStartingEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_NoFocusCandidateFound:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                NoFocusCandidateFoundEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetNoFocusCandidateFoundEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerCanceled:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerCanceledEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerCanceledEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerCaptureLost:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerCaptureLostEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerCaptureLostEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerEntered:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerEnteredEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerEnteredEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerExited:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerExitedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerExitedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerMoved:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerMovedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerMovedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerPressed:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerPressedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerPressedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerReleased:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerReleasedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerReleasedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerWheelChanged:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerWheelChangedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerWheelChangedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PreviewKeyDown:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PreviewKeyDownEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPreviewKeyDownEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PreviewKeyUp:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PreviewKeyUpEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPreviewKeyUpEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ProcessKeyboardAccelerators:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ProcessKeyboardAcceleratorsEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetProcessKeyboardAcceleratorsEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_RightTapped:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IRightTappedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                RightTappedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetRightTappedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_Tapped:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::ITappedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                TappedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetTappedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->AddHandler(spEventHandler.Get(), handledEventsToo));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    default:
        IFC_RETURN(E_INVALIDARG);
        break;
    }

    return S_OK;
}

_Check_return_ HRESULT DirectUI::UIElementGenerated::EventRemoveHandlerByIndex(_In_ KnownEventIndex nEventIndex, _In_ IInspectable* pHandler)
{
    switch (nEventIndex)
    {
    case KnownEventIndex::UIElement_BringIntoViewRequested:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::BringIntoViewRequestedEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                BringIntoViewRequestedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetBringIntoViewRequestedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_CharacterReceived:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::CharacterReceivedRoutedEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                CharacterReceivedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetCharacterReceivedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ContextCanceled:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::RoutedEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ContextCanceledEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetContextCanceledEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ContextRequested:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::ContextRequestedEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ContextRequestedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetContextRequestedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_DoubleTapped:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IDoubleTappedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DoubleTappedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDoubleTappedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_DragEnter:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::IDragEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DragEnterEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDragEnterEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_DragLeave:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::IDragEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DragLeaveEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDragLeaveEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_DragOver:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::IDragEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DragOverEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDragOverEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_DragStarting:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::DragStartingEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DragStartingEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDragStartingEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_Drop:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::IDragEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DropEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDropEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_DropCompleted:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::DropCompletedEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                DropCompletedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetDropCompletedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_GettingFocus:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::GettingFocusEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                GettingFocusEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetGettingFocusEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_GotFocus:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::IRoutedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                GotFocusEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetGotFocusEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_Holding:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IHoldingEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                HoldingEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetHoldingEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_KeyDown:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                KeyDownEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetKeyDownEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_KeyUp:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                KeyUpEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetKeyUpEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_LosingFocus:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::LosingFocusEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                LosingFocusEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetLosingFocusEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_LostFocus:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::IRoutedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                LostFocusEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetLostFocusEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ManipulationCompleted:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IManipulationCompletedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ManipulationCompletedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetManipulationCompletedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ManipulationDelta:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IManipulationDeltaEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ManipulationDeltaEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetManipulationDeltaEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ManipulationInertiaStarting:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IManipulationInertiaStartingEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ManipulationInertiaStartingEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetManipulationInertiaStartingEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ManipulationStarted:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IManipulationStartedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ManipulationStartedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetManipulationStartedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ManipulationStarting:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IManipulationStartingEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ManipulationStartingEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetManipulationStartingEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_NoFocusCandidateFound:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::NoFocusCandidateFoundEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                NoFocusCandidateFoundEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetNoFocusCandidateFoundEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerCanceled:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerCanceledEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerCanceledEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerCaptureLost:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerCaptureLostEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerCaptureLostEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerEntered:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerEnteredEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerEnteredEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerExited:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerExitedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerExitedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerMoved:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerMovedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerMovedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerPressed:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerPressedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerPressedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerReleased:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerReleasedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerReleasedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PointerWheelChanged:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IPointerEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PointerWheelChangedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPointerWheelChangedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PreviewKeyDown:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PreviewKeyDownEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPreviewKeyDownEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_PreviewKeyUp:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IKeyEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                PreviewKeyUpEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetPreviewKeyUpEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_ProcessKeyboardAccelerators:
        {
            ctl::ComPtr<ABI::Windows::Foundation::ITypedEventHandler<ABI::Microsoft::UI::Xaml::UIElement*, ABI::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs*>> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                ProcessKeyboardAcceleratorsEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetProcessKeyboardAcceleratorsEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_RightTapped:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::IRightTappedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                RightTappedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetRightTappedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    case KnownEventIndex::UIElement_Tapped:
        {
            ctl::ComPtr<ABI::Microsoft::UI::Xaml::Input::ITappedEventHandler> spEventHandler;
            IValueBoxer::UnboxValue(pHandler, spEventHandler.ReleaseAndGetAddressOf());

            if (nullptr != spEventHandler)
            {
                TappedEventSourceType* pEventSource = nullptr;
                IFC_RETURN(GetTappedEventSourceNoRef(&pEventSource));
                IFC_RETURN(pEventSource->RemoveHandler(spEventHandler.Get()));
            }
            else
            {
                IFC_RETURN(E_INVALIDARG);
            }
        }
        break;
    default:
        IFC_RETURN(E_INVALIDARG);
        break;
    }

    return S_OK;
}

HRESULT DirectUI::UIElementFactory::QueryInterfaceImpl(_In_ REFIID iid, _Outptr_ void** ppObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Xaml::IUIElementFactory)))
    {
        *ppObject = static_cast<ABI::Microsoft::UI::Xaml::IUIElementFactory*>(this);
    }
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Xaml::IUIElementStatics)))
    {
        *ppObject = static_cast<ABI::Microsoft::UI::Xaml::IUIElementStatics*>(this);
    }
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Xaml::IUIElementStaticsPrivate)))
    {
        *ppObject = static_cast<ABI::Microsoft::UI::Xaml::IUIElementStaticsPrivate*>(this);
    }
    else
    {
        RRETURN(ctl::BetterAggregableAbstractCoreObjectActivationFactory::QueryInterfaceImpl(iid, ppObject));
    }

    AddRefOuter();
    RRETURN(S_OK);
}


// Factory methods.

// Dependency properties.




IFACEMETHODIMP DirectUI::UIElementFactory::get_AllowDropProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_AllowDrop, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_OpacityProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_Opacity, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_ClipProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_Clip, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_RenderTransformProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_RenderTransform, ppValue));
}






IFACEMETHODIMP DirectUI::UIElementFactory::get_ProjectionProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_Projection, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_Transform3DProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_Transform3D, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_RenderTransformOriginProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_RenderTransformOrigin, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_IsHitTestVisibleProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_IsHitTestVisible, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_VisibilityProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_Visibility, ppValue));
}

IFACEMETHODIMP DirectUI::UIElementFactory::get_UseLayoutRoundingProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_UseLayoutRounding, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_TransitionsProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_Transitions, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_CacheModeProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_CacheMode, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_IsTapEnabledProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_IsTapEnabled, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_IsDoubleTapEnabledProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_IsDoubleTapEnabled, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_CanDragProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_CanDrag, ppValue));
}

IFACEMETHODIMP DirectUI::UIElementFactory::get_IsRightTapEnabledProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_IsRightTapEnabled, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_IsHoldingEnabledProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_IsHoldingEnabled, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_ManipulationModeProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_ManipulationMode, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_PointerCapturesProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_PointerCaptures, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_ContextFlyoutProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_ContextFlyout, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_CompositeModeProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_CompositeMode, ppValue));
}

IFACEMETHODIMP DirectUI::UIElementFactory::get_LightsProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_Lights, ppValue));
}

IFACEMETHODIMP DirectUI::UIElementFactory::get_CanBeScrollAnchorProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_CanBeScrollAnchor, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_ExitDisplayModeOnAccessKeyInvokedProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_ExitDisplayModeOnAccessKeyInvoked, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_IsAccessKeyScopeProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_IsAccessKeyScope, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_AccessKeyScopeOwnerProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_AccessKeyScopeOwner, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_AccessKeyProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_AccessKey, ppValue));
}

IFACEMETHODIMP DirectUI::UIElementFactory::get_KeyTipPlacementModeProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_KeyTipPlacementMode, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_KeyTipHorizontalOffsetProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_KeyTipHorizontalOffset, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_KeyTipVerticalOffsetProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_KeyTipVerticalOffset, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_KeyTipTargetProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_KeyTipTarget, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_XYFocusKeyboardNavigationProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_XYFocusKeyboardNavigation, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_XYFocusUpNavigationStrategyProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_XYFocusUpNavigationStrategy, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_XYFocusDownNavigationStrategyProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_XYFocusDownNavigationStrategy, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_XYFocusLeftNavigationStrategyProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_XYFocusLeftNavigationStrategy, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_XYFocusRightNavigationStrategyProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_XYFocusRightNavigationStrategy, ppValue));
}

IFACEMETHODIMP DirectUI::UIElementFactory::get_KeyboardAcceleratorPlacementTargetProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_KeyboardAcceleratorPlacementTarget, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_KeyboardAcceleratorPlacementModeProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_KeyboardAcceleratorPlacementMode, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_HighContrastAdjustmentProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_HighContrastAdjustment, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_TabFocusNavigationProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_TabFocusNavigation, ppValue));
}






IFACEMETHODIMP DirectUI::UIElementFactory::get_ShadowProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_Shadow, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_FocusStateProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_FocusState, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_UseSystemFocusVisualsProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_UseSystemFocusVisuals, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_XYFocusLeftProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_XYFocusLeft, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_XYFocusRightProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_XYFocusRight, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_XYFocusUpProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_XYFocusUp, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_XYFocusDownProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_XYFocusDown, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_IsTabStopProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_IsTabStop, ppValue));
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_TabIndexProperty(_Out_ ABI::Microsoft::UI::Xaml::IDependencyProperty** ppValue)
{
    RRETURN(MetadataAPI::GetIDependencyProperty(KnownPropertyIndex::UIElement_TabIndex, ppValue));
}

// Attached properties.

// Static properties.
IFACEMETHODIMP DirectUI::UIElementFactory::get_KeyDownEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_KeyDownEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_KeyUpEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_KeyUpEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_PointerEnteredEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_PointerEnteredEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_PointerPressedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_PointerPressedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_PointerMovedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_PointerMovedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_PointerReleasedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_PointerReleasedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_PointerExitedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_PointerExitedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_PointerCaptureLostEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_PointerCaptureLostEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_PointerCanceledEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_PointerCanceledEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_PointerWheelChangedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_PointerWheelChangedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_TappedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_TappedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_DoubleTappedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_DoubleTappedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_HoldingEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_HoldingEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_RightTappedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_RightTappedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
_Check_return_ HRESULT DirectUI::UIElementFactory::get_RightTappedUnhandledEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_RightTappedUnhandledEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_ManipulationStartingEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_ManipulationStartingEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_ManipulationInertiaStartingEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_ManipulationInertiaStartingEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_ManipulationStartedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_ManipulationStartedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_ManipulationDeltaEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_ManipulationDeltaEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_ManipulationCompletedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_ManipulationCompletedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_DragEnterEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_DragEnterEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_DragLeaveEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_DragLeaveEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_DragOverEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_DragOverEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_DropEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_DropEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_GettingFocusEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_GettingFocusEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_LosingFocusEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_LosingFocusEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_NoFocusCandidateFoundEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_NoFocusCandidateFoundEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_PreviewKeyDownEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_PreviewKeyDownEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_CharacterReceivedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_CharacterReceivedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_PreviewKeyUpEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_PreviewKeyUpEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_BringIntoViewRequestedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_BringIntoViewRequestedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::get_ContextRequestedEvent(_Outptr_result_maybenull_ ABI::Microsoft::UI::Xaml::IRoutedEvent** ppValue)
{
    HRESULT hr = S_OK;
    ARG_VALIDRETURNPOINTER(ppValue);
    
    IFC(get_ContextRequestedEventImpl(ppValue));
Cleanup:
    RRETURN(hr);
}

// Static methods.
IFACEMETHODIMP DirectUI::UIElementFactory::TryStartDirectManipulation(_In_ ABI::Microsoft::UI::Xaml::Input::IPointer* pValue, _Out_ BOOLEAN* pReturnValue)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, 0, "UIElement_TryStartDirectManipulation", 0);
    }
    ARG_NOTNULL(pValue, "value");
    ARG_VALIDRETURNPOINTER(pReturnValue);
    IFC(CheckActivationAllowed());
    IFC(TryStartDirectManipulationImpl(pValue, pReturnValue));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, 0, "UIElement_TryStartDirectManipulation", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::RegisterAsScrollPort(_In_ ABI::Microsoft::UI::Xaml::IUIElement* pElement)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, 0, "UIElement_RegisterAsScrollPort", 0);
    }
    ARG_NOTNULL(pElement, "element");
    IFC(CheckActivationAllowed());
    IFC(RegisterAsScrollPortImpl(pElement));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, 0, "UIElement_RegisterAsScrollPort", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::InternalGetIsEnabled(_In_ ABI::Microsoft::UI::Xaml::IUIElement* pElement, _Out_ BOOLEAN* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, 0, "UIElement_InternalGetIsEnabled", 0);
    }
    ARG_NOTNULL(pElement, "element");
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckActivationAllowed());
    IFC(InternalGetIsEnabledImpl(pElement, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, 0, "UIElement_InternalGetIsEnabled", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::UIElementFactory::InternalPutIsEnabled(_In_ ABI::Microsoft::UI::Xaml::IUIElement* pElement, _In_ BOOLEAN value)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, 0, "UIElement_InternalPutIsEnabled", 0);
    }
    ARG_NOTNULL(pElement, "element");
    IFC(CheckActivationAllowed());
    IFC(InternalPutIsEnabledImpl(pElement, value));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, 0, "UIElement_InternalPutIsEnabled", hr);
    }
    RRETURN(hr);
}

namespace DirectUI
{
    _Check_return_ IActivationFactory* CreateActivationFactory_UIElement()
    {
        RRETURN(ctl::ActivationFactoryCreator<UIElementFactory>::CreateActivationFactory());
    }
}
