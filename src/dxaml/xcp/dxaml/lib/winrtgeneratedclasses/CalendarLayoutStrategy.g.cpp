// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.
//------------------------------------------------------------------------
//
//  Abstract:
//
//      XAML types.
//      NOTE: This file was generated by a tool.
//
//------------------------------------------------------------------------

#include "CalendarLayoutStrategy.g.h"
#include "XamlTelemetry.h"

// Constructors/destructors.
DirectUI::CalendarLayoutStrategyGenerated::CalendarLayoutStrategyGenerated()
{
}

DirectUI::CalendarLayoutStrategyGenerated::~CalendarLayoutStrategyGenerated()
{
}

HRESULT DirectUI::CalendarLayoutStrategyGenerated::QueryInterfaceImpl(_In_ REFIID iid, _Outptr_ void** ppObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(DirectUI::CalendarLayoutStrategy)))
    {
        *ppObject = static_cast<DirectUI::CalendarLayoutStrategy*>(this);
    }
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Xaml::Controls::ILayoutStrategy)))
    {
        *ppObject = static_cast<ABI::Microsoft::UI::Xaml::Controls::ILayoutStrategy*>(this);
    }
    else
    {
        RRETURN(ctl::WeakReferenceSource::QueryInterfaceImpl(iid, ppObject));
    }

    AddRefOuter();
    RRETURN(S_OK);
}

// Properties.

// Events.

// Methods.
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::BeginMeasure()
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_BeginMeasure", 0);
    }
    
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->BeginMeasureImpl());
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_BeginMeasure", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::EndMeasure()
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_EndMeasure", 0);
    }
    
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->EndMeasureImpl());
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_EndMeasure", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::EstimateElementBounds(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference headerReference, _In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference containerReference, _In_ ABI::Windows::Foundation::Rect window, _Out_ ABI::Windows::Foundation::Rect* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_EstimateElementBounds", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->EstimateElementBoundsImpl(elementType, elementIndex, headerReference, containerReference, window, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_EstimateElementBounds", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::EstimateElementIndex(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference headerReference, _In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference containerReference, _In_ ABI::Windows::Foundation::Rect window, _Out_ ABI::Windows::Foundation::Rect* pTargetRect, _Out_ INT* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_EstimateElementIndex", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->EstimateElementIndexImpl(elementType, headerReference, containerReference, window, pTargetRect, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_EstimateElementIndex", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::EstimateIndexFromPoint(_In_ BOOLEAN requestingInsertionIndex, _In_ ABI::Windows::Foundation::Point point, _In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference reference, _In_ ABI::Windows::Foundation::Rect windowConstraint, _Out_ ABI::Microsoft::UI::Xaml::Controls::IndexSearchHint* pSearchHint, _Out_ ABI::Microsoft::UI::Xaml::Controls::ElementType* pElementType, _Out_ INT* pElementIndex)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_EstimateIndexFromPoint", 0);
    }
    
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->EstimateIndexFromPointImpl(requestingInsertionIndex, point, reference, windowConstraint, pSearchHint, pElementType, pElementIndex));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_EstimateIndexFromPoint", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::EstimatePanelExtent(_In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference lastHeaderReference, _In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference lastContainerReference, _In_ ABI::Windows::Foundation::Rect windowConstraint, _Out_ ABI::Windows::Foundation::Size* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_EstimatePanelExtent", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->EstimatePanelExtentImpl(lastHeaderReference, lastContainerReference, windowConstraint, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_EstimatePanelExtent", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::GetElementArrangeBounds(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Windows::Foundation::Rect containerBounds, _In_ ABI::Windows::Foundation::Rect windowConstraint, _In_ ABI::Windows::Foundation::Size finalSize, _Out_ ABI::Windows::Foundation::Rect* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetElementArrangeBounds", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->GetElementArrangeBoundsImpl(elementType, elementIndex, containerBounds, windowConstraint, finalSize, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetElementArrangeBounds", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::GetElementBounds(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Windows::Foundation::Size containerDesiredSize, _In_ ABI::Microsoft::UI::Xaml::Controls::LayoutReference referenceInformation, _In_ ABI::Windows::Foundation::Rect windowConstraint, _Out_ ABI::Windows::Foundation::Rect* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetElementBounds", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->GetElementBoundsImpl(elementType, elementIndex, containerDesiredSize, referenceInformation, windowConstraint, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetElementBounds", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::GetElementMeasureSize(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Windows::Foundation::Rect windowConstraint, _Out_ ABI::Windows::Foundation::Size* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetElementMeasureSize", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->GetElementMeasureSizeImpl(elementType, elementIndex, windowConstraint, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetElementMeasureSize", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::GetElementTransitionsBounds(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Windows::Foundation::Rect windowConstraint, _Out_ ABI::Windows::Foundation::Rect* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetElementTransitionsBounds", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->GetElementTransitionsBoundsImpl(elementType, elementIndex, windowConstraint, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetElementTransitionsBounds", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::GetIsWrappingStrategy(_Out_ BOOLEAN* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetIsWrappingStrategy", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->GetIsWrappingStrategyImpl(pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetIsWrappingStrategy", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::GetPositionOfFirstElement(_Out_ ABI::Windows::Foundation::Point* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetPositionOfFirstElement", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->GetPositionOfFirstElementImpl(pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetPositionOfFirstElement", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::GetRegularSnapPoints(_Out_ FLOAT* pNearOffset, _Out_ FLOAT* pFarOffset, _Out_ FLOAT* pSpacing, _Out_ BOOLEAN* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetRegularSnapPoints", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->GetRegularSnapPointsImpl(pNearOffset, pFarOffset, pSpacing, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetRegularSnapPoints", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::GetTargetIndexFromNavigationAction(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Microsoft::UI::Xaml::Controls::KeyNavigationAction action, _In_ ABI::Windows::Foundation::Rect windowConstraint, _In_ INT itemIndexHintForHeaderNavigation, _Out_ ABI::Microsoft::UI::Xaml::Controls::ElementType* pTargetElementType, _Out_ INT* pTargetElementIndex)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetTargetIndexFromNavigationAction", 0);
    }
    
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->GetTargetIndexFromNavigationActionImpl(elementType, elementIndex, action, windowConstraint, itemIndexHintForHeaderNavigation, pTargetElementType, pTargetElementIndex));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetTargetIndexFromNavigationAction", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::GetVirtualizationDirection(_Out_ ABI::Microsoft::UI::Xaml::Controls::Orientation* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetVirtualizationDirection", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->GetVirtualizationDirectionImpl(pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_GetVirtualizationDirection", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::HasIrregularSnapPoints(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _Out_ BOOLEAN* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_HasIrregularSnapPoints", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->HasIrregularSnapPointsImpl(elementType, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_HasIrregularSnapPoints", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::HasSnapPointOnElement(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _Out_ BOOLEAN* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_HasSnapPointOnElement", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->HasSnapPointOnElementImpl(elementType, elementIndex, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_HasSnapPointOnElement", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::IsIndexLayoutBoundary(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Windows::Foundation::Rect windowConstraint, _Out_ BOOLEAN* pIsLeftBoundary, _Out_ BOOLEAN* pIsTopBoundary, _Out_ BOOLEAN* pIsRightBoundary, _Out_ BOOLEAN* pIsBottomBoundary)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_IsIndexLayoutBoundary", 0);
    }
    
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->IsIndexLayoutBoundaryImpl(elementType, elementIndex, windowConstraint, pIsLeftBoundary, pIsTopBoundary, pIsRightBoundary, pIsBottomBoundary));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_IsIndexLayoutBoundary", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::SetLayoutDataInfoProvider(_In_ ABI::Microsoft::UI::Xaml::Controls::ILayoutDataInfoProvider* pProvider)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_SetLayoutDataInfoProvider", 0);
    }
    ARG_NOTNULL(pProvider, "provider");
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->SetLayoutDataInfoProviderImpl(pProvider));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_SetLayoutDataInfoProvider", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::CalendarLayoutStrategyGenerated::ShouldContinueFillingUpSpace(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Microsoft::UI::Xaml::Controls::LayoutReference referenceInformation, _In_ ABI::Windows::Foundation::Rect windowToFill, _Out_ BOOLEAN* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_ShouldContinueFillingUpSpace", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    IFC(CheckThread());
    IFC(static_cast<CalendarLayoutStrategy*>(this)->ShouldContinueFillingUpSpaceImpl(elementType, elementIndex, referenceInformation, windowToFill, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "CalendarLayoutStrategy_ShouldContinueFillingUpSpace", hr);
    }
    RRETURN(hr);
}


