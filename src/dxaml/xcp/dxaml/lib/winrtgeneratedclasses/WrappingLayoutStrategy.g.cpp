// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.
//------------------------------------------------------------------------
//
//  Abstract:
//
//      XAML types.
//      NOTE: This file was generated by a tool.
//
//------------------------------------------------------------------------

#include "WrappingLayoutStrategy.g.h"
#include "XamlTelemetry.h"

// Constructors/destructors.
DirectUI::WrappingLayoutStrategyGenerated::WrappingLayoutStrategyGenerated()
{
}

DirectUI::WrappingLayoutStrategyGenerated::~WrappingLayoutStrategyGenerated()
{
}

HRESULT DirectUI::WrappingLayoutStrategyGenerated::QueryInterfaceImpl(_In_ REFIID iid, _Outptr_ void** ppObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(DirectUI::WrappingLayoutStrategy)))
    {
        *ppObject = static_cast<DirectUI::WrappingLayoutStrategy*>(this);
    }
    else if (InlineIsEqualGUID(iid, __uuidof(ABI::Microsoft::UI::Xaml::Controls::ILayoutStrategy)))
    {
        *ppObject = static_cast<ABI::Microsoft::UI::Xaml::Controls::ILayoutStrategy*>(this);
    }
    else
    {
        RRETURN(ctl::WeakReferenceSource::QueryInterfaceImpl(iid, ppObject));
    }

    AddRefOuter();
    RRETURN(S_OK);
}

// Properties.

// Events.

// Methods.
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::BeginMeasure()
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_BeginMeasure", 0);
    }
    
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->BeginMeasureImpl());
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_BeginMeasure", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::EndMeasure()
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_EndMeasure", 0);
    }
    
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->EndMeasureImpl());
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_EndMeasure", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::EstimateElementBounds(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference headerReference, _In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference containerReference, _In_ ABI::Windows::Foundation::Rect window, _Out_ ABI::Windows::Foundation::Rect* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_EstimateElementBounds", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->EstimateElementBoundsImpl(elementType, elementIndex, headerReference, containerReference, window, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_EstimateElementBounds", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::EstimateElementIndex(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference headerReference, _In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference containerReference, _In_ ABI::Windows::Foundation::Rect window, _Out_ ABI::Windows::Foundation::Rect* pTargetRect, _Out_ INT* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_EstimateElementIndex", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->EstimateElementIndexImpl(elementType, headerReference, containerReference, window, pTargetRect, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_EstimateElementIndex", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::EstimateIndexFromPoint(_In_ BOOLEAN requestingInsertionIndex, _In_ ABI::Windows::Foundation::Point point, _In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference reference, _In_ ABI::Windows::Foundation::Rect windowConstraint, _Out_ ABI::Microsoft::UI::Xaml::Controls::IndexSearchHint* pSearchHint, _Out_ ABI::Microsoft::UI::Xaml::Controls::ElementType* pElementType, _Out_ INT* pElementIndex)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_EstimateIndexFromPoint", 0);
    }
    
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->EstimateIndexFromPointImpl(requestingInsertionIndex, point, reference, windowConstraint, pSearchHint, pElementType, pElementIndex));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_EstimateIndexFromPoint", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::EstimatePanelExtent(_In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference lastHeaderReference, _In_ ABI::Microsoft::UI::Xaml::Controls::EstimationReference lastContainerReference, _In_ ABI::Windows::Foundation::Rect windowConstraint, _Out_ ABI::Windows::Foundation::Size* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_EstimatePanelExtent", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->EstimatePanelExtentImpl(lastHeaderReference, lastContainerReference, windowConstraint, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_EstimatePanelExtent", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::GetElementArrangeBounds(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Windows::Foundation::Rect containerBounds, _In_ ABI::Windows::Foundation::Rect windowConstraint, _In_ ABI::Windows::Foundation::Size finalSize, _Out_ ABI::Windows::Foundation::Rect* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetElementArrangeBounds", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->GetElementArrangeBoundsImpl(elementType, elementIndex, containerBounds, windowConstraint, finalSize, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetElementArrangeBounds", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::GetElementBounds(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Windows::Foundation::Size containerDesiredSize, _In_ ABI::Microsoft::UI::Xaml::Controls::LayoutReference referenceInformation, _In_ ABI::Windows::Foundation::Rect windowConstraint, _Out_ ABI::Windows::Foundation::Rect* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetElementBounds", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->GetElementBoundsImpl(elementType, elementIndex, containerDesiredSize, referenceInformation, windowConstraint, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetElementBounds", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::GetElementMeasureSize(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Windows::Foundation::Rect windowConstraint, _Out_ ABI::Windows::Foundation::Size* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetElementMeasureSize", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->GetElementMeasureSizeImpl(elementType, elementIndex, windowConstraint, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetElementMeasureSize", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::GetElementTransitionsBounds(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Windows::Foundation::Rect windowConstraint, _Out_ ABI::Windows::Foundation::Rect* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetElementTransitionsBounds", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->GetElementTransitionsBoundsImpl(elementType, elementIndex, windowConstraint, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetElementTransitionsBounds", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::GetIsWrappingStrategy(_Out_ BOOLEAN* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetIsWrappingStrategy", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->GetIsWrappingStrategyImpl(pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetIsWrappingStrategy", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::GetPositionOfFirstElement(_Out_ ABI::Windows::Foundation::Point* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetPositionOfFirstElement", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->GetPositionOfFirstElementImpl(pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetPositionOfFirstElement", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::GetRegularSnapPoints(_Out_ FLOAT* pNearOffset, _Out_ FLOAT* pFarOffset, _Out_ FLOAT* pSpacing, _Out_ BOOLEAN* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetRegularSnapPoints", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->GetRegularSnapPointsImpl(pNearOffset, pFarOffset, pSpacing, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetRegularSnapPoints", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::GetTargetIndexFromNavigationAction(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Microsoft::UI::Xaml::Controls::KeyNavigationAction action, _In_ ABI::Windows::Foundation::Rect windowConstraint, _In_ INT itemIndexHintForHeaderNavigation, _Out_ ABI::Microsoft::UI::Xaml::Controls::ElementType* pTargetElementType, _Out_ INT* pTargetElementIndex)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetTargetIndexFromNavigationAction", 0);
    }
    
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->GetTargetIndexFromNavigationActionImpl(elementType, elementIndex, action, windowConstraint, itemIndexHintForHeaderNavigation, pTargetElementType, pTargetElementIndex));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetTargetIndexFromNavigationAction", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::GetVirtualizationDirection(_Out_ ABI::Microsoft::UI::Xaml::Controls::Orientation* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetVirtualizationDirection", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->GetVirtualizationDirectionImpl(pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_GetVirtualizationDirection", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::HasIrregularSnapPoints(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _Out_ BOOLEAN* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_HasIrregularSnapPoints", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->HasIrregularSnapPointsImpl(elementType, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_HasIrregularSnapPoints", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::HasSnapPointOnElement(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _Out_ BOOLEAN* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_HasSnapPointOnElement", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->HasSnapPointOnElementImpl(elementType, elementIndex, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_HasSnapPointOnElement", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::IsIndexLayoutBoundary(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Windows::Foundation::Rect windowConstraint, _Out_ BOOLEAN* pIsLeftBoundary, _Out_ BOOLEAN* pIsTopBoundary, _Out_ BOOLEAN* pIsRightBoundary, _Out_ BOOLEAN* pIsBottomBoundary)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_IsIndexLayoutBoundary", 0);
    }
    
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->IsIndexLayoutBoundaryImpl(elementType, elementIndex, windowConstraint, pIsLeftBoundary, pIsTopBoundary, pIsRightBoundary, pIsBottomBoundary));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_IsIndexLayoutBoundary", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::SetLayoutDataInfoProvider(_In_ ABI::Microsoft::UI::Xaml::Controls::ILayoutDataInfoProvider* pProvider)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_SetLayoutDataInfoProvider", 0);
    }
    ARG_NOTNULL(pProvider, "provider");
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->SetLayoutDataInfoProviderImpl(pProvider));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_SetLayoutDataInfoProvider", hr);
    }
    RRETURN(hr);
}
IFACEMETHODIMP DirectUI::WrappingLayoutStrategyGenerated::ShouldContinueFillingUpSpace(_In_ ABI::Microsoft::UI::Xaml::Controls::ElementType elementType, _In_ INT elementIndex, _In_ ABI::Microsoft::UI::Xaml::Controls::LayoutReference referenceInformation, _In_ ABI::Windows::Foundation::Rect windowToFill, _Out_ BOOLEAN* pResult)
{
    HRESULT hr = S_OK;
    if (EventEnabledApiFunctionCallStart())
    {
        XamlTelemetry::PublicApiCall(true, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_ShouldContinueFillingUpSpace", 0);
    }
    ARG_VALIDRETURNPOINTER(pResult);
    *pResult={};
    IFC(CheckThread());
    IFC(static_cast<WrappingLayoutStrategy*>(this)->ShouldContinueFillingUpSpaceImpl(elementType, elementIndex, referenceInformation, windowToFill, pResult));
Cleanup:
    if (EventEnabledApiFunctionCallStop())
    {
        XamlTelemetry::PublicApiCall(false, reinterpret_cast<uint64_t>(this), "WrappingLayoutStrategy_ShouldContinueFillingUpSpace", hr);
    }
    RRETURN(hr);
}


