// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.

//  Abstract:
//      DispatherTimer class is not generated by the ClassGen tool, it is now a regular object instead of DependencyObject.
//      But it still wants to interop with its native peer DispatcherTimer object, so some interop mechanism is implemented 
//      in this class.

#include "precomp.h"
#include "DispatcherTimer.g.h"

using namespace DirectUI;

_Check_return_ HRESULT DispatcherTimer::get_IsEnabledImpl(
    _Out_ BOOLEAN* pValue)
{
    *pValue = m_fIsEnabled;
    RRETURN(S_OK);
}

_Check_return_ HRESULT DispatcherTimer::StartImpl()
{
    HRESULT hr = S_OK;
    
    m_fIsEnabled = TRUE;
    IFC(CoreImports::DispatcherTimer_Start(static_cast<CDispatcherTimer *>(GetHandle())));

Cleanup:
    RRETURN(hr);
}

_Check_return_ HRESULT DispatcherTimer::StopImpl()
{
    HRESULT hr = S_OK;
    
    m_fIsEnabled = FALSE;

    // It is possible that an application object could hold onto a reference to a
    // timer and call stop on it during destruction, so we need to check the handle
    // to see if the core object has been disconnected.
    CDispatcherTimer* timer = static_cast<CDispatcherTimer *>(GetHandle());
    if (timer)
    {
        IFC(timer->Stop());
    }

Cleanup:
    RRETURN(hr);
}
