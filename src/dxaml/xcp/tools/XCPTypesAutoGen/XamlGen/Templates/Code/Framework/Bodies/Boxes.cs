// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace XamlGen.Templates.Code.Framework.Bodies
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using OM;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public partial class Boxes : CppCodeGenerator<OMContextView>
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTemplate<Copyright>()));
            this.Write("\r\n\r\n#include \"precomp.h\"\r\n\r\n");
 foreach (var type in Model.GetTypeTableEnums()) {
       if (type.IdlTypeInfo.IsExcluded) { 
            this.Write("REFERENCE_ELEMENT_NAME_IMPL(");
            this.Write(this.ToStringHelper.ToStringWithCulture(AsCppType(type.AbiReferenceFullName)));
            this.Write(", L\"\");\r\n");
     } else { 
            this.Write("REFERENCE_ELEMENT_NAME_IMPL(");
            this.Write(this.ToStringHelper.ToStringWithCulture(AsCppType(type.AbiReferenceFullName)));
            this.Write(", L\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(type.AbiReferenceFullNameNoABIPrefix));
            this.Write("\");\r\n");
     }
   } 
            this.Write(@"
// This pattern (GetValueFor_<typename>) may look weird at first, and weirder still because we're specifically
// asking for __declspec(noinline).  But there's a reason!  The microsoft toolchain is very clever about folding
// together functions with identical bodies (COMDAT folding), but it can't do the same for blocks within functions
// yet.  Thus, by factoring this out into functions that'll end up being identical in their optimized, compiled
// form, we save a noticeable amount of binary size.

");
 foreach (var type in Model.GetTypeTableEnums()) { 
            this.Write("\r\n__declspec(noinline) HRESULT GetValueFor_");
            this.Write(this.ToStringHelper.ToStringWithCulture(type.IndexName.Replace("::", "_")));
            this.Write("(_In_ IInspectable* pBox, REFIID guid, _Out_ UINT* pnValue)\r\n{\r\n    HRESULT hr = " +
                    "S_OK;\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(PrefixAbi("Windows::Foundation::IReference")));
            this.Write("<");
            this.Write(this.ToStringHelper.ToStringWithCulture(AsCppType(type.AbiReferenceFullName)));
            this.Write(">* ptr = nullptr;\r\n    IFC(pBox->QueryInterface(guid, reinterpret_cast<void**>(&p" +
                    "tr)));\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(AsCppType(type.AbiReferenceFullName)));
            this.Write(" value;\r\n    IFC(ptr->get_Value(&value));\r\n    *pnValue = static_cast<uint32_t>(v" +
                    "alue);\r\nCleanup:\r\n    ReleaseInterfaceNoNULL(ptr);\r\n    return hr;\r\n}\r\n");
 } 
            this.Write("\r\n_Check_return_ HRESULT GetEnumValueFromKnownWinRTBox(_In_ IInspectable* pBox, _" +
                    "In_ const CClassInfo* pType, _Out_ UINT* pnValue)\r\n{\r\n    REFIID typeGuid = pTyp" +
                    "e->GetGuid();\r\n\r\n    *pnValue = 0;\r\n    switch (pType->GetIndex())\r\n    {\r\n");
 foreach (var type in Model.GetTypeTableEnums()) { 
            this.Write("        case ");
            this.Write(this.ToStringHelper.ToStringWithCulture(type.IndexName));
            this.Write(":\r\n            return GetValueFor_");
            this.Write(this.ToStringHelper.ToStringWithCulture(type.IndexName.Replace("::", "_")));
            this.Write("(pBox, typeGuid, pnValue);\r\n");
 } 
            this.Write(@"        default:
            // Unsupported enum type.
            IFC_RETURN(E_NOTIMPL);
    }

    return S_OK;
}

_Check_return_ HRESULT GetKnownWinRTBoxFromEnumValue(_In_ UINT nValue, _In_ const CClassInfo* pType, _Outptr_ IInspectable** ppBox)
{
    *ppBox = nullptr;
    switch (pType->GetIndex())
    {
");
 foreach (var type in Model.GetTypeTableEnums()) { 
            this.Write("        case ");
            this.Write(this.ToStringHelper.ToStringWithCulture(type.IndexName));
            this.Write(":\r\n            return DirectUI::PropertyValue::CreateEnumReference<");
            this.Write(this.ToStringHelper.ToStringWithCulture(AsCppType(type.AbiReferenceFullName)));
            this.Write(">(static_cast<");
            this.Write(this.ToStringHelper.ToStringWithCulture(AsCppType(type.AbiReferenceFullName)));
            this.Write(">(nValue), ppBox);\r\n");
 } 
            this.Write("        default:\r\n            // Unsupported enum type.\r\n            IFC_RETURN(E" +
                    "_NOTIMPL);\r\n    }\r\n\r\n    return S_OK;\r\n}\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
}
