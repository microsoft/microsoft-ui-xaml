// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace XamlGen.Templates.Code.Core.Bodies
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using OM;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    public partial class SimplePropertiesCommon : CppCodeGenerator<OMContextView>
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTemplate<Copyright>()));
            this.Write(@"

#include ""precomp.h""
#include <StringConversions.h>
#include <SimplePropertiesCommon.g.h>
#include <DXamlTypes.h>
#include <CValueBoxer.h>

 // For every type used by simple properties, we need to generate its Reference type's name.
 // One exception is if the type is an enum. Boxes.g.cpp will already generate its Reference type's name.
 ");
 foreach (var typeName in Model.GetAllTypeTableSimpleProperties().Where(simpleProperty => !(simpleProperty.PropertyType.Type is EnumDefinition)).Select(simpleProperty => simpleProperty.PropertyType.AbiFullNameNoABIPrefix).Distinct()) {
            this.Write("REFERENCE_ELEMENT_NAME_IMPL(");
            this.Write(this.ToStringHelper.ToStringWithCulture(AsCppType(typeName)));
            this.Write(", L\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(typeName));
            this.Write("\");\r\n ");
 } 
            this.Write("REFERENCE_ELEMENT_NAME_IMPL(");
            this.Write(this.ToStringHelper.ToStringWithCulture(PrefixAbi("Windows::Foundation::Numerics::Quaternion")));
            this.Write(@", L""Windows.Foundation.Numerics.Quaternion"");


// Type converters for types used by simple properties.
// If a new type converter is required, add it to the source T4 file,
// and then add an exception for the type to ObjectWriter::Logic_CreatePropertyValueFromText()
namespace SimplePropertiesCommon {

    HRESULT ConvertToVector2(const CValue& value, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(PrefixAbi("Windows::Foundation::Numerics::Vector2")));
            this.Write("& convertedValue)\r\n    {\r\n        IFCEXPECT_RETURN(value.GetType() == valueString" +
                    ");\r\n        IFC_RETURN(Vector2FromString(value.As<valueString>(), convertedValue" +
                    "));\r\n        return S_OK;\r\n    }\r\n\r\n    HRESULT ConvertToVector3(const CValue& v" +
                    "alue, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(PrefixAbi("Windows::Foundation::Numerics::Vector3")));
            this.Write("& convertedValue)\r\n    {\r\n        IFCEXPECT_RETURN(value.GetType() == valueString" +
                    ");\r\n        IFC_RETURN(Vector3FromString(value.As<valueString>(), convertedValue" +
                    "));\r\n        return S_OK;\r\n    }\r\n\r\n    HRESULT ConvertToQuaternion(const CValue" +
                    "& value, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(PrefixAbi("Windows::Foundation::Numerics::Quaternion")));
            this.Write("& convertedValue)\r\n    {\r\n        IFCEXPECT_RETURN(value.GetType() == valueString" +
                    ");\r\n        IFC_RETURN(QuaternionFromString(value.As<valueString>(), convertedVa" +
                    "lue));\r\n        return S_OK;\r\n    }\r\n\r\n    HRESULT ConvertToMatrix3x2(const CVal" +
                    "ue& value, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(PrefixAbi("Windows::Foundation::Numerics::Matrix3x2")));
            this.Write("& convertedValue)\r\n    {\r\n        IFCEXPECT_RETURN(value.GetType() == valueString" +
                    ");\r\n        IFC_RETURN(Matrix3x2FromString(value.As<valueString>(), convertedVal" +
                    "ue));\r\n        return S_OK;\r\n    }\r\n\r\n    HRESULT ConvertToMatrix4x4(const CValu" +
                    "e& value, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(PrefixAbi("Windows::Foundation::Numerics::Matrix4x4")));
            this.Write("& convertedValue)\r\n    {\r\n        IFCEXPECT_RETURN(value.GetType() == valueString" +
                    ");\r\n        IFC_RETURN(Matrix4x4FromString(value.As<valueString>(), convertedVal" +
                    "ue));\r\n        return S_OK;\r\n    }\r\n\r\n    HRESULT ConvertToTimeSpan(const CValue" +
                    "& value, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(PrefixAbi("Windows::Foundation::TimeSpan")));
            this.Write(@"& convertedValue)
    {
        IFCEXPECT_RETURN(value.GetType() == valueObject);
        const CTimeSpan* timeSpan = static_cast<const CTimeSpan*>(value.As<valueObject>());
        convertedValue = { static_cast<long long>(timeSpan->m_rTimeSpan * 10000000.0) };
        return S_OK;
    }

    HRESULT ConvertToVector3TransitionComponents(const CValue& value, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Helper.PrefixAbiIfNeeded($"{Helper.GetRootNamespaceCpp()}::Vector3TransitionComponents")));
            this.Write("& convertedValue)\r\n    {\r\n        IFCEXPECT_RETURN(value.GetType() == valueEnum8)" +
                    ";\r\n        convertedValue = static_cast<");
            this.Write(this.ToStringHelper.ToStringWithCulture(Helper.PrefixAbiIfNeeded($"{Helper.GetRootNamespaceCpp()}::Vector3TransitionComponents")));
            this.Write(@">(value.AsEnum8());
        return S_OK;
    }

    HRESULT ConvertToDouble(const CValue& value, double& convertedValue)
    {
        // Counterintuitively checking for valueFloat here because CDouble::CreateCValue actually
        // creates a valueFloat, not a valueDouble (as one might expect)
        if (value.GetType() == valueFloat)
        {
            convertedValue = value.As<valueFloat>();
        }
        else
        {
            IFCEXPECT_RETURN(value.GetType() == valueString);
            IFC_RETURN(DirectUI::CValueBoxer::UnboxValue(&value, &convertedValue));
        }
        return S_OK;
    }

    HRESULT ConvertToInt32(const CValue& value, int32_t& convertedValue)
    {
        if (value.GetType() == valueSigned)
        {
            convertedValue = value.As<valueSigned>();
        }
        else
        {
            IFCEXPECT_RETURN(value.GetType() == valueString);
            IFC_RETURN(DirectUI::CValueBoxer::UnboxValue(&value, &convertedValue));
        }
        return S_OK;
    }
}");
            return this.GenerationEnvironment.ToString();
        }
    }
}
