// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace XamlGen.Templates.Metadata
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using OM;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    public partial class StaticMetadataBody : MetadataCodeGenerator<OMContextView>
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTemplate<Copyright>()));
            this.Write(@"

// Contains machine-independent metadata.

#include ""precomp.h""
#include ""Indexes.g.h""
#include ""TypeTableStructs.h""
#include ""Activators.g.h""
#include ""TypeTable.g.h""
#include ""EnumValueTable.h""

// Namespaces.
extern const MetaDataNamespace c_aNamespaces[KnownNamespaceCount] =
{
    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTemplate<NamespaceEntry>(NamespaceDefinition.UnknownNamespace)));
            this.Write(",\r\n");
 foreach (var ns in Model.GetTypeTableNamespaces()) { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTemplate<NamespaceEntry>(ns)));
            this.Write(",\r\n");
 } 
            this.Write("};\r\n\r\n// Basic type info.\r\nextern const MetaDataType c_aTypes[KnownTypeCount] =\r\n" +
                    "{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTypeEntry(ClassDefinition.UnknownType)));
            this.Write(",\r\n");
 foreach (var type in Model.GetAllTypeTableTypes()) { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTypeEntry(type)));
            this.Write(",\r\n");
 } 
            this.Write("};\r\n\r\n// Type name information.\r\nextern const MetaDataTypeNameInfo c_aTypeNameInf" +
                    "os[KnownTypeCount] =\r\n{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTypeNameInfoEntry(ClassDefinition.UnknownType)));
            this.Write(",\r\n");
 foreach (var type in Model.GetAllTypeTableTypes()) { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTypeNameInfoEntry(type)));
            this.Write(",\r\n");
 } 
            this.Write("};\r\n\r\n// Type property information.\r\nextern const MetaDataTypeProperties c_aTypeP" +
                    "roperties[KnownTypeCount] =\r\n{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTypePropertiesEntry(ClassDefinition.UnknownType)));
            this.Write(",\r\n");
 foreach (var type in Model.GetAllTypeTableTypes()) { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTypePropertiesEntry(type)));
            this.Write(",\r\n");
 } 
            this.Write("};\r\n\r\n// Type UUID information.\r\nextern constexpr IID c_aTypeUUIDs[KnownTypeCount] =\r" +
                    "\n{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(GetDefaultInterfaceGuidString(ClassDefinition.UnknownType)));
            this.Write(",\r\n");
 foreach (var type in Model.GetAllTypeTableTypes()) { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(GetDefaultInterfaceGuidString(type)));
            this.Write(",\r\n");
 } 
            this.Write("};\r\n\r\n// Types that can be referenced from XAML.\r\nextern const MetaDataTypeName c" +
                    "_aTypeNames[");
            this.Write(this.ToStringHelper.ToStringWithCulture(1 + Model.GetTypeTableTypesWithNames().Count()));
            this.Write("] =\r\n{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTemplate<TypeNameEntry>(ClassDefinition.UnknownType)));
            this.Write(",\r\n");
 foreach (var type in Model.GetTypeTableTypesWithNames().OrderBy(t => t.TypeTableName).OrderBy(t => t.TypeTableName.Length)) { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTemplate<TypeNameEntry>(type)));
            this.Write(",\r\n");
 } 
            this.Write("};\r\n\r\n// Properties.\r\nextern const MetaDataProperty c_aProperties[KnownPropertyCo" +
                    "unt] =\r\n{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTemplate<PropertyEntry>(PropertyDefinition.UnknownProperty)));
            this.Write(",\r\n");
 foreach (var property in Model.GetAllTypeTableProperties()) { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(IncludeTemplate<PropertyEntry>(property)));
            this.Write(",\r\n");
 } 
            this.Write("};\r\n\r\n// Property iteration.\r\nextern const KnownPropertyIndex c_aNextProperty[Kno" +
                    "wnPropertyCount] =\r\n{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(PropertyDefinition.UnknownProperty.NextPropertyInTypeTable.IndexName));
            this.Write(", // ");
            this.Write(this.ToStringHelper.ToStringWithCulture(PropertyDefinition.UnknownProperty.IndexNameWithoutPrefix));
            this.Write("\r\n");
 foreach (var property in Model.GetAllTypeTableProperties()) { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(property.NextPropertyInTypeTable.IndexName));
            this.Write(", // ");
            this.Write(this.ToStringHelper.ToStringWithCulture(property.IndexNameWithoutPrefix));
            this.Write("\r\n");
 } 
            this.Write("};\r\n\r\n// Property slots.\r\nextern const UINT8 c_aPropertySlot[KnownPropertyCount] " +
                    "=\r\n{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(PropertyDefinition.UnknownProperty.Slot));
            this.Write(", // ");
            this.Write(this.ToStringHelper.ToStringWithCulture(PropertyDefinition.UnknownProperty.IndexNameWithoutPrefix));
            this.Write("\r\n");
 foreach (var property in Model.GetAllTypeTableProperties()) { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(property.Slot));
            this.Write(", // ");
            this.Write(this.ToStringHelper.ToStringWithCulture(property.IndexNameWithoutPrefix));
            this.Write("\r\n");
 } 
            this.Write("};\r\n\r\n// Property names.\r\nextern const xstring_ptr_storage c_aPropertyNames[Known" +
                    "PropertyCount] =\r\n{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(AsStringStorage(PropertyDefinition.UnknownProperty.TypeTableName)));
            this.Write(",\r\n");
 foreach (var property in Model.GetAllTypeTableProperties()) { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(AsStringStorage(property.TypeTableName)));
            this.Write(",\r\n");
 } 
            this.Write("};\r\n\r\n// Maps a type name length to a scan range in c_aTypeNames. pnEndIndex is n" +
                    "ot inclusive.\r\nUINT MapTypeNameLengthToSearchRange(_In_ UINT nLength, _Out_ UINT" +
                    "* pnEndIndex)\r\n{\r\n    switch (nLength)\r\n    {\r\n");
 foreach (var range in GetSearchRanges(Model.GetTypeTableTypesWithNames())) { 
            this.Write("        case ");
            this.Write(this.ToStringHelper.ToStringWithCulture(range.TypeNameLength));
            this.Write(":\r\n            *pnEndIndex = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(range.EndIndex));
            this.Write(";\r\n            return ");
            this.Write(this.ToStringHelper.ToStringWithCulture(range.StartIndex));
            this.Write(";\r\n");
 } 
            this.Write(@"        default:
            *pnEndIndex = 0;
            return 0;
    }
}

// Returns the enum value array which can be used to do enum<->string conversions.
_Check_return_ HRESULT GetEnumValueTable(_In_ KnownTypeIndex nTypeIndex, _Out_ UINT* pnCount, _Outptr_result_buffer_(*pnCount) const XTABLE* ppTable[])
{
    switch (nTypeIndex)
    {
");
 foreach (var type in Model.GetTypeTableEnums()) { 
            this.Write("        case ");
            this.Write(this.ToStringHelper.ToStringWithCulture(type.IndexName));
            this.Write(":\r\n            *pnCount = ARRAY_SIZE(");
            this.Write(this.ToStringHelper.ToStringWithCulture(type.ValueTableArrayName));
            this.Write(");\r\n            *ppTable = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(type.ValueTableArrayName));
            this.Write(";\r\n            return S_OK;\r\n");
 } 
            this.Write("        default:\r\n            ASSERT(FALSE);\r\n            return E_FAIL;\r\n    }\r\n" +
                    "}\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
}
