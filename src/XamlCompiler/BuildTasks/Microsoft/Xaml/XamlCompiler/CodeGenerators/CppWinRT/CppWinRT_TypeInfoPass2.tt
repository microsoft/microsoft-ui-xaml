<#@ template language="C#" inherits="CppWinRT_CodeGenerator<TypeInfoDefinition>" visibility="internal" linePragmas="false"#>
<#@ assembly name="System.Core"#>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Microsoft.UI.Xaml.Markup.Compiler.Properties" #>
<#@ import namespace="Microsoft.UI.Xaml.Markup.Compiler.Utilities" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<#  if(!String.IsNullOrEmpty(ProjectInfo.PrecompiledHeaderFile)) { #>
#include "<#=ProjectInfo.PrecompiledHeaderFile#>"
<#  }#>
#include <memory>

<#  foreach (var includeFile in Model.NeededCppWinRTProjectionHeaderFiles) { #>
#if __has_include(<<#=includeFile#>>)
#include <<#=includeFile#>>
#endif
<#  }#>

<#  if (ProjectInfo.GenerateIncrementalTypeInfo) { #>
#ifdef XAML_TYPE_INFO_INC
#include XAML_TYPE_INFO_INC
#endif
<#  } #>
#include "XamlTypeInfo.xaml.g.h"

<#  if (!ProjectInfo.GenerateIncrementalTypeInfo) { #>
<#      foreach(string includeFile in Model.AllLocalXamlHeaderFiles) { #>
#include "<#=includeFile#>"
<#      } #>
<#  } #>
#include "XamlBindingInfo.xaml.g.hpp"
<#  if (!ProjectInfo.GenerateIncrementalTypeInfo) { #>
<#      foreach(string includeFile in Model.AllLocalHppGeneratedFiles) #>
<#      { #>
#include "<#=includeFile.Replace(".g.hpp", ".xaml.g.hpp")#>"
<#      } #>
<#  } #>

namespace winrt::<#=Colonize(ProjectInfo.RootNamespace)#>::implementation
{
using IXamlMember = <#=Projection(KnownNamespaces.XamlMarkup)#>::IXamlMember;
using IXamlType = <#=Projection(KnownNamespaces.XamlMarkup)#>::IXamlType;
using TypeKind = <#=Projection(KnownNamespaces.WindowsXamlInterop)#>::TypeKind;
<#  if (Model.TypeInfos.Any()) { #>
<#      if (ProjectInfo.GenerateCppWinRTStaticAsserts) { #>

    namespace XamlTypeInfo_staticasserts
    {
        template<typename, typename = void>
        constexpr bool is_type_complete_v = false;

        template<typename T>
        constexpr bool is_type_complete_v<T, std::void_t<decltype(sizeof(T))>> = true;

<#          foreach (var typeInfo in Model.TypeInfos) { #>
<#              Output_StaticAssertTypeIsComplete(typeInfo, Indent.TwoTabs); #>
<#          } #>

    }
<#      } #>

<#      if (ProjectInfo.GenerateIncrementalTypeInfo) { #>
<#          foreach(var entry in Model.TypeInfos.OrderBy(t => t.StandardName)) { #>
<#              IncludeTemplate<CppWinRT_MetadataDelegates>(entry, ProjectInfo.ClassToHeaderFileMap.ContainsKey(entry.StandardName));#>
<#          } #>
<#      } else { #>
<#          IncludeTemplate<CppWinRT_TemplatedMetadataDelegates>(Model);#>
<#      } #>

enum TypeInfo_Flags
{
    TypeInfo_Flags_None                 = 0x00,
    TypeInfo_Flags_IsLocalType          = 0x01,
    TypeInfo_Flags_IsSystemType         = 0x02,
    TypeInfo_Flags_IsReturnTypeStub     = 0x04,
    TypeInfo_Flags_IsBindable           = 0x08,
    TypeInfo_Flags_IsMarkupExtension    = 0x10, 
};

struct TypeInfo
{
    const wchar_t* typeName{nullptr};
    const wchar_t* contentPropertyName{nullptr};
    <#=Projection(KnownNamespaces.WindowsFoundation)#>::IInspectable (*activator)();
    void (*collectionAdd)(<#=Projection(KnownNamespaces.WindowsFoundation)#>::IInspectable const&, <#=Projection(KnownNamespaces.WindowsFoundation)#>::IInspectable const&);
    void (*dictionaryAdd)(<#=Projection(KnownNamespaces.WindowsFoundation)#>::IInspectable const&, <#=Projection(KnownNamespaces.WindowsFoundation)#>::IInspectable const&, <#=Projection(KnownNamespaces.WindowsFoundation)#>::IInspectable const&);
    <#=Projection(KnownNamespaces.WindowsFoundation)#>::IInspectable (*fromStringConverter)(XamlUserType const&, ::winrt::hstring const& );
    int     baseTypeIndex;
    int     firstMemberIndex;
    int     firstEnumValueIndex;
    int     createFromStringIndex;
    TypeKind kindOfType;
    unsigned int flags;
    int boxedTypeIndex;
};

<#  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
<#  { #>
#pragma warning( push )
#pragma warning( disable : 4973 )
<#  } #>
<#  if (Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod).Any()) { #>

XamlUserType::CreateFromStringFn CreateFromStringMethods[] =
{
<#      foreach(var entry in Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod)) { #>
    [](::winrt::hstring const& value) -> ::winrt::Windows::Foundation::IInspectable { return ::winrt::box_value(<#=entry.CreateFromStringMethod.ResolvedName.CppWinRTName()#>(value)); },
<#      }#>
};
<#  } #>

const TypeInfo TypeInfos[] = 
{
<#  int entryIndex = 0; #>
<#  int firstEnumValueIndex = 0; #>
<#  int firstMemberIndex = 0; #>
<#  int createFromStringIndex = 0; #>
<#  foreach(var entry in Model.TypeInfos) #>
<#  { #>
<#      String isLocalType = entry.IsLocalType ? "TypeInfo_Flags_IsLocalType | " : "";#>
<#      String isSystemType = entry.IsSystemType ? "TypeInfo_Flags_IsSystemType | " : "";#>
<#      String isReturnTypeStub = entry.IsReturnTypeStub ? "TypeInfo_Flags_IsReturnTypeStub | " : "";#>
<#      String isBindable = entry.IsBindable ? "TypeInfo_Flags_IsBindable | " : "";#>
<#      String isMarkupExtension = entry.IsMarkupExtension ? "TypeInfo_Flags_IsMarkupExtension | " : "";#>
<#      String baseTypeIndex = entry.BaseTypeStandardName.Length > 0 ? Model.TypeInfoIndexes[entry.BaseTypeStandardName].ToString() + ", // " + entry.BaseTypeStandardName : "-1,";#>
<#      String boxedTypeIndex = entry.BoxedTypeStandardName.Length > 0 ? Model.TypeInfoIndexes[entry.BoxedTypeStandardName].ToString() + ", // " + entry.BoxedTypeStandardName : "-1,";#>
<#      String kindofType = String.Format("TypeKind::{0}", entry.IsLocalType && !ProjectInfo.IsLibrary ? "Custom" : "Metadata");#>
<#      String activator = entry.HasActivator ? $"&{entry.ActivatorName.CppWinRTName()}" : "nullptr";#>
<#      String collectionAdd = entry.IsCollection ? $"&{entry.CollectionAddName.CppWinRTName()}" : "nullptr";#>
<#      String dictionaryAdd = entry.IsDictionary ? $"&{entry.DictionaryAddName.CppWinRTName()}" : "nullptr";#>
<#      String fromStringConverter = entry.HasEnumValues ? $"&{entry.FromStringConverterName.CppWinRTName()}" : "nullptr";#>
<#      String createFromString = "-1";#>
<#      if (entry.HasCreateFromStringMethod)#>
<#      {#>
<#          createFromString = createFromStringIndex.ToString();#>
<#          createFromStringIndex++;#>
<#      }#>
<#      if (entry.HasMembers) #>
<#      { #>
<#          Model.TrackTypeMembers(entry, out firstMemberIndex); #>
<#      } #>
<#      if(entry.HasEnumValues) #>
<#      { #>
<#          Model.TrackTypeEnumValues(entry, out firstEnumValueIndex); #>
<#      } #>
    // <#= String.Format("{0,3}", entryIndex++) #>
    L"<#=entry.StandardName#>", L"<#=entry.ContentPropertyName#>",
    <#=activator#>, <#=collectionAdd#>, <#=dictionaryAdd#>, <#=fromStringConverter#>,
    <#=baseTypeIndex#>
    <#=firstMemberIndex#>, <#=firstEnumValueIndex#>, <#=createFromString#>, <#=kindofType#>,
    <#=isLocalType#><#=isSystemType#><#=isReturnTypeStub#><#=isBindable#><#=isMarkupExtension#>TypeInfo_Flags_None,
    <#=boxedTypeIndex#>
<#      firstEnumValueIndex += entry.EnumValues.Count(); #>
<#      firstMemberIndex += entry.Members.Count(); #>
<#  } #>
    //  Last type here is for padding
    L"", L"",
    nullptr, nullptr, nullptr, nullptr,
    -1, 
    <#=firstMemberIndex#>, <#=firstEnumValueIndex#>, -1, TypeKind::Custom,
    TypeInfo_Flags_None,
};
<#  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
<#  { #>
#pragma warning( pop )
<#  } #>

<#  entryIndex = 0; #>
constexpr uint32_t TypeInfoLookup[] = { 
<#  foreach(var entry in Model.TypeInfoLookup) #>
<#  { #>
    <#= String.Format("{0,3},   // {1,3}", entry, entryIndex++) #>
<# } #>
};
<#  if (Model.EnumValues.Count() > 0) #>
<#  { #>

struct EnumValueInfo
{
    const wchar_t* name{nullptr};
    int eValue;
};

const EnumValueInfo EnumValues[] =
{ 
<#      foreach (var enumValue in Model.EnumValues) #>
<#      { #>
    L"<#=enumValue.ValueName#>", static_cast<int>(<#=enumValue.TypeInfo.FullName#>::<#=enumValue.ValueName#>),
<#      } #>
};
<#  } #>
<#  if (Model.MemberInfos.Count() > 0) #>
<#  { #>

struct MemberInfo 
{
    const wchar_t* shortName{nullptr};
    <#=Projection(KnownNamespaces.WindowsFoundation)#>::IInspectable (*getter)(<#=Projection(KnownNamespaces.WindowsFoundation)#>::IInspectable const&);
    void (*setter)(<#=Projection(KnownNamespaces.WindowsFoundation)#>::IInspectable const&, <#=Projection(KnownNamespaces.WindowsFoundation)#>::IInspectable const&);
    int typeIndex;
    int targetTypeIndex;
    bool isReadOnly;
    bool isDependencyProperty;
    bool isAttachable;
};

<#      if (Model.MemberInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
<#      { #>
#pragma warning( push )
#pragma warning( disable : 4973 )
<#      } #>
const MemberInfo MemberInfos[] = 
{
<#      entryIndex = 0; #>
<#      foreach(var entry in Model.MemberInfos) #>
<#      { #>
<#      String isReadOnly = entry.HasPublicGetter && !entry.HasPublicSetter ? "true, " : "false,"; #>
<#      String isDependencyProperty = entry.IsDependencyProperty ? "true, " : "false,"; #>
<#      String isAttachable = entry.IsAttachable ? "true, " : "false,"; #>
<#      String targetTypeIndex = entry.TargetType != null ? Model.TypeInfoIndexes[entry.TargetType.StandardName].ToString() + ", // " + entry.TargetType.StandardName : "-1,";#>
    // <#= String.Format("{0,3}", entryIndex++) #> - <#=entry.DeclaringType.StandardName#>.<#=entry.Name#>
    L"<#=entry.Name#>",
<#          if (entry.HasGetAttachableMember) { #>
    &<#=entry.GetAttachableMemberName#>,
<#          } else if (entry.HasGetValueTypeMember) { #>
    &<#=entry.GetValueTypeMemberName#>,
<#          } else if (entry.HasGetReferenceTypeMember) { #>
    &<#=entry.GetReferenceTypeMemberName#>,
<#          } else { #>
    nullptr,
<#          } #>
<#          if (entry.HasSetAttachableMember) { #>
    &<#=entry.SetAttachableMemberName#>,
<#          } else if (entry.HasSetEnumMember) { #>
    &<#=entry.SetEnumMemberName#>,
<#          } else if (entry.HasSetValueTypeMember) { #>
    &<#=entry.SetValueTypeMemberName#>,
<#          } else if (entry.HasSetReferenceTypeMember) { #>
    &<#=entry.SetReferenceTypeMemberName#>,
<#          } else { #>
    nullptr,
<#          } #>
    <#=Model.TypeInfoIndexes[entry.Type.StandardName]#>, // <#=entry.Type.StandardName#>
    <#=targetTypeIndex#>
    <#=isReadOnly#> <#=isDependencyProperty#> <#=isAttachable#>
<#      } #>
};
<#      if (Model.MemberInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
<#      { #>
#pragma warning( pop )
<#      } #>

const wchar_t* GetShortName(const wchar_t* longName)
{
    const auto separator = wcsrchr(longName, '.');
    return separator ? separator + 1: longName;
}
<#  } #>

const TypeInfo* GetTypeInfo(::winrt::hstring const& typeName)
{
    size_t typeNameLength = typeName.size();
    if (typeNameLength < _countof(TypeInfoLookup) - 1)
    {
        const auto begin = TypeInfos + TypeInfoLookup[typeNameLength];
        const auto end = TypeInfos + TypeInfoLookup[typeNameLength + 1];
        auto pos = std::find_if(begin, end, [&typeName](TypeInfo const& elem)
        {
            return wcscmp(typeName.data(), elem.typeName) == 0;
        });
        if (pos != end)
        {
            return pos;
        }
    }
    return nullptr;
}
<#      if (Model.MemberInfos.Count() > 0) { #>

const MemberInfo* GetMemberInfo(::winrt::hstring const& longMemberName)
{
    const auto dotPosition = std::find(longMemberName.crbegin(), longMemberName.crend(), L'.').base();
    if (dotPosition != longMemberName.end())
    {
        const auto sizeBeforeDot = static_cast<::winrt::hstring::size_type>(dotPosition - longMemberName.begin()) - 1;
        const TypeInfo* pTypeInfo = GetTypeInfo(::winrt::hstring{longMemberName.data(), sizeBeforeDot});
        if (pTypeInfo)
        {
            const TypeInfo* pNextTypeInfo = pTypeInfo + 1;
            const auto shortMemberName = GetShortName(longMemberName.data());
            const auto begin = MemberInfos + pTypeInfo->firstMemberIndex;
            const auto end = MemberInfos + pNextTypeInfo->firstMemberIndex;
            auto info = std::find_if(begin, end,
                [shortMemberName](const MemberInfo& elem)
            {
                return wcscmp(shortMemberName, elem.shortName) == 0;
            });
            if (info != end)
            {
                return info;
            }
        }
    }
    return nullptr;
}
<#      } #>
<#  } // if (Model.TypeInfos.Count() > 0) #>

std::vector<<#=Projection(KnownNamespaces.XamlMarkup)#>::IXamlMetadataProvider> const& XamlTypeInfoProvider::OtherProviders()
{
<#      if (ProjectInfo.GenerateProviderCode && SchemaInfo.OtherMetadataProviders.Any()) { #>
    std::lock_guard<std::recursive_mutex> lock(_xamlTypesCriticalSection);
    if (_otherProviders.empty())
    {
<#          foreach(var provider in SchemaInfo.OtherMetadataProviders) { #>
        _otherProviders.push_back(<#=provider.FullName#>());
<#          } #>
    }
<#  } #>
    return _otherProviders;
}

<#  if (!Model.TypeInfos.Any()) { #>
IXamlType XamlTypeInfoProvider::CreateXamlType(::winrt::hstring const& )
{
    // No local types
    return nullptr;
}
<#  } else  { #>
IXamlType XamlTypeInfoProvider::CreateXamlType(::winrt::hstring const& typeName)
{
    const TypeInfo* pTypeInfo = GetTypeInfo(typeName);
    const TypeInfo* pNextTypeInfo = pTypeInfo + 1;
    if (!pTypeInfo || !pNextTypeInfo)
    {
        return nullptr;
    }
    else if (pTypeInfo->flags & TypeInfo_Flags_IsSystemType)
    {
        return ::winrt::make<XamlSystemBaseType>(typeName);
    }
    else
    {
        ::winrt::hstring baseName { pTypeInfo->baseTypeIndex >= 0 ? TypeInfos[pTypeInfo->baseTypeIndex].typeName : L""};
        ::winrt::hstring boxedName { pTypeInfo->boxedTypeIndex >= 0 ? TypeInfos[pTypeInfo->boxedTypeIndex].typeName : L""};
        auto userType = ::winrt::make_self<XamlUserType>(shared_from_this(), pTypeInfo->typeName, GetXamlTypeByName(baseName));
        userType->_kindOfType = pTypeInfo->kindOfType;
        userType->_activator = pTypeInfo->activator;
        userType->_collectionAdd = pTypeInfo->collectionAdd;
        userType->_dictionaryAdd = pTypeInfo->dictionaryAdd;
        userType->_fromStringConverter = pTypeInfo->fromStringConverter;
        userType->ContentPropertyName(pTypeInfo->contentPropertyName);
        userType->IsLocalType(pTypeInfo->flags & TypeInfo_Flags_IsLocalType);
        userType->IsReturnTypeStub(pTypeInfo->flags & TypeInfo_Flags_IsReturnTypeStub);
        userType->IsBindable(pTypeInfo->flags & TypeInfo_Flags_IsBindable);
        userType->IsMarkupExtension(pTypeInfo->flags & TypeInfo_Flags_IsMarkupExtension);
        userType->_createFromStringMethod = nullptr;
<#  if (Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod).Any()) { #>
        if (pTypeInfo->createFromStringIndex != -1)
        {
            userType->_createFromStringMethod = CreateFromStringMethods[pTypeInfo->createFromStringIndex];
        }
<#  } #>
        userType->SetBoxedType(GetXamlTypeByName(boxedName));
<#  if (Model.MemberInfos.Any()) { #>
        for (int i = pTypeInfo->firstMemberIndex; i < pNextTypeInfo->firstMemberIndex; ++i)
        {
            userType->AddMemberName(MemberInfos[i].shortName);
        }
<#  } #>
<#  if (Model.EnumValues.Any()) { #>
        for (int i = pTypeInfo->firstEnumValueIndex; i < pNextTypeInfo->firstEnumValueIndex; ++i)
        {
            userType->AddEnumValue(EnumValues[i].name, winrt::Windows::Foundation::PropertyValue::CreateInt32(EnumValues[i].eValue));
        }
<#  } #>
        return userType.as<IXamlType>();
    }
}
<#  } #>

<#  if (!Model.MemberInfos.Any()) { #>
IXamlMember XamlTypeInfoProvider::CreateXamlMember(::winrt::hstring const& )
{
    // No local properties
    return nullptr;
}
<#  } else { #>
IXamlMember XamlTypeInfoProvider::CreateXamlMember(::winrt::hstring const& longMemberName)
{
    const MemberInfo* pMemberInfo = GetMemberInfo(longMemberName);
    if (!pMemberInfo)
    {
        return nullptr;
    }
    auto xamlMember = ::winrt::make_self<XamlMember>(shared_from_this(),
        pMemberInfo->shortName, TypeInfos[pMemberInfo->typeIndex].typeName);
    xamlMember->_getter = pMemberInfo->getter;
    xamlMember->_setter = pMemberInfo->setter;
    xamlMember->TargetTypeName(pMemberInfo->targetTypeIndex >= 0 ? TypeInfos[pMemberInfo->targetTypeIndex].typeName : L"");
    xamlMember->IsReadOnly(pMemberInfo->isReadOnly);
    xamlMember->IsDependencyProperty(pMemberInfo->isDependencyProperty);
    xamlMember->IsAttachable(pMemberInfo->isAttachable);

    return xamlMember.as<IXamlMember>();
}
<#  } #>
} // namespace

<#+ HashSet<TypeGenInfo> staticAssertTypes = new HashSet<TypeGenInfo>();#>

<#+ private void Output_StaticAssertTypeIsComplete(TypeGenInfo typeInfo, Indent indent = Indent.None)#>
<#+ {#>
<#+     bool hasGeneratedCodeReference = typeInfo.HasActivator || typeInfo.IsCollection || typeInfo.IsDictionary || typeInfo.HasEnumValues;#>
<#+     if(hasGeneratedCodeReference && !staticAssertTypes.Contains(typeInfo))#>
<#+     {#>
<#+         staticAssertTypes.Add(typeInfo);#>
<#+         PushIndent(indent);#>
<#+         if(!String.IsNullOrEmpty(ProjectInfo.PrecompiledHeaderFile))#>
<#+         {#>
static_assert( is_type_complete_v<<#=typeInfo.FullName.CppWinRTName()#>>, "<#=ResourceUtilities.FormatString(XamlCompilerResources.XamlCompiler_CodeGenStaticAssert_IncompleteType, typeInfo.FullName.CppWinRTName(), ProjectInfo.PrecompiledHeaderFile)#>" );
<#+         }#>
<#+         else#>
<#+         {#>
static_assert( is_type_complete_v<<#=typeInfo.FullName.CppWinRTName()#>>, "<#=ResourceUtilities.FormatString(XamlCompilerResources.XamlCompiler_CodeGenStaticAssert_IncompleteType_NoPch, typeInfo.FullName.CppWinRTName())#>" );
<#+         }#>
<#+         PopIndent();#>
<#+     }#>
<#+ }#>
