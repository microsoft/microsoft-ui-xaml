<?xml version="1.0"?>
<!-- Copyright (c) Microsoft Corporation. Licensed under the MIT License. See LICENSE in the project root for license information. -->
<doc>
    <assembly>
        <name>Microsoft.UI.Xaml.Markup.Compiler</name>
    </assembly>
    <members>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Tasks.CompileXaml">
            <summary>
            Called to build the given set of xaml files
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Tasks.CompileXaml.CheckForDesignTimeBuildMode">
            <summary>
            There is a specific build task "DesignTimeBuild" which is called IN PROC for intellisense
            </summary>
            <returns>true if this is a design time build</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Tasks.IVsMSBuildTaskFileManager.GetFileDocData(System.String)">
            <SecurityNote>
                 Critical - call is SUC'ed
            </SecurityNote>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper">
            <summary>
            A wrapper that abstracts the differences between host objects implementing
            <see cref="T:Microsoft.UI.Xaml.Markup.Compiler.Tasks.IVsMSBuildTaskFileManager"/> and <see cref="T:Microsoft.VisualStudio.ProjectSystem.Interop.IVsMSBuildTaskFreeThreadedFileManager"/>.
            </summary>
        </member>
        <member name="F:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper.legacy">
            <summary>
            The wrapped STA affinitized <see cref="T:Microsoft.UI.Xaml.Markup.Compiler.Tasks.IVsMSBuildTaskFileManager"/> host object.
            </summary>
        </member>
        <member name="F:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper.freeThreaded">
            <summary>
            The wrapped free-threaded <see cref="T:Microsoft.VisualStudio.ProjectSystem.Interop.IVsMSBuildTaskFreeThreadedFileManager"/> host object.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Tasks.IVsMSBuildTaskFileManager)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper"/> class
            that wraps the STA affinitized <see cref="T:Microsoft.UI.Xaml.Markup.Compiler.Tasks.IVsMSBuildTaskFileManager"/> host object.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper.#ctor(Microsoft.VisualStudio.ProjectSystem.Interop.IVsMSBuildTaskFreeThreadedFileManager)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper"/> class
            that wraps the free-threaded <see cref="T:Microsoft.VisualStudio.ProjectSystem.Interop.IVsMSBuildTaskFreeThreadedFileManager"/> host object.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper.IsRealBuildOperation">
            <summary>
            Checks whether we're running in a solution build (as opposed to a design-time build).
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper.Delete(System.String)">
            <summary>
            Marks the specified file for deletion.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper.Exists(System.String,System.Boolean)">
            <summary>
            Checks whether the specified file exists.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper.GetFileContents(System.String)">
            <summary>
            Gets the contents of the specified file, from disk or unsaved buffers in the editor, if available.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper.GetFileLastChangeTime(System.String)">
            <summary>
            Gets the last time this file's contents were changed (including in unsaved buffers).
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper.PutGeneratedFileContents(System.String,System.String)">
            <summary>
            Updates the editor buffers and/or disk with new contents for the specified file.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Tasks.VsMSBuildFileManagerHostObjectWrapper.Acquire(System.Object)">
            <summary>
            Creates a wrapper around the specified host object, if the type of object is recognizeable.
            </summary>
            <param name="hostObject">The host object.</param>
            <returns>A wrapper instance, or <c>null</c> if the host object wasn't of a recognized type.</returns>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CXMetadataDelegates">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CXMetadataDelegates.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CXTemplatedMetadataDelegates">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CXTemplatedMetadataDelegates.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharpAppPass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharpAppPass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharpPagePass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharpPagePass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharpPagePass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharpPagePass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharpTypeInfoPass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CSharpTypeInfoPass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppAppPass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppAppPass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppAppPass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppAppPass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppBindingInfoPass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppBindingInfoPass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppBindingInfoPass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppBindingInfoPass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppPagePass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppPagePass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppPagePass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppPagePass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppTypeInfoPass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppTypeInfoPass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppTypeInfoPass1b">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppTypeInfoPass1b.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppTypeInfoPass1Impl">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppTypeInfoPass1Impl.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppTypeInfoPass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.MoComCppTypeInfoPass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VisualBasicAppPass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VisualBasicAppPass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VisualBasicPagePass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VisualBasicPagePass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VisualBasicPagePass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VisualBasicPagePass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VisualBasicTypeInfoPass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.VisualBasicTypeInfoPass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_AppPass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_AppPass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_AppPass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_AppPass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_BindingInfoPass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_BindingInfoPass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_BindingInfoPass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_BindingInfoPass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_PageBinding">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_PageBinding.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_PageBindingTracking">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_PageBindingTracking.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_PagePass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_PagePass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_PagePass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_PagePass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_MetadataDelegates">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_MetadataDelegates.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_TemplatedMetadataDelegates">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_TemplatedMetadataDelegates.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_XamlMetaDataProviderPass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_XamlMetaDataProviderPass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_TypeInfoPass1">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_TypeInfoPass1.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_XamlMetaDataProviderPass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_XamlMetaDataProviderPass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_TypeInfoPass1Impl">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_TypeInfoPass1Impl.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_TypeInfoPass2">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppWinRT_TypeInfoPass2.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppCX_CodeGenerator`1.ColonizeRef(Microsoft.UI.Xaml.Markup.Compiler.EventAssignment)">
            <summary>
            Used by the C++ code gen to create a reference to a type
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.CppCX_CodeGenerator`1.ColonizeRef(Microsoft.UI.Xaml.Markup.Compiler.BoundEventAssignment)">
            <summary>
            Used by the C++ code gen to create a reference to a type
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.IncludeTemplate``1">
            <summary>
            Executes a template and appends the result to the GenerationEnvironment.
            </summary>
            <typeparam name="TTemplate"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.IncludeTemplate``1(System.Object,System.Object[])">
            <summary>
            Executes a template and appends the result to the GenerationEnvironment.
            </summary>
            <typeparam name="TTemplate"></typeparam>
            <param name="model"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.GenerationEnvironment">
            <summary>
            The string builder that generation-time code is using to assemble generated output
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.Errors">
            <summary>
            The error collection for the generation process
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.indentLengths">
            <summary>
            A list of the lengths of each indent that was added with PushIndent
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.Write(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.WriteLine(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.Write(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.WriteLine(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.Error(System.String)">
            <summary>
            Raise an error
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.Warning(System.String)">
            <summary>
            Raise a warning
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.PushIndent(Microsoft.UI.Xaml.Markup.Compiler.CodeGen.Indent)">
            <summary>
            Increase the indent
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.PopIndent">
            <summary>
            Remove the last indent that was added with PushIndent
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.T4Base.ClearIndent">
            <summary>
            Remove any indentation
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.CodeGen.TypeInfoDefinition.AppMetadataProviderNamespace">
            <summary>
            Gets the app's namespace - this is valid in Pass 2, so it's most useful for VB/C# typeinfo structure which occurs all in Pass 2.
            This is invalid for non-app codegen.
            Used for generating the app's implementation of IXamlMetadataProvider in VB/C#.  In VB/C# this is done in Pass 2 TypeInfo
            so we need this information, for C++/CX it's done in the Pass 1 App codegen so we don't use it there.
            This should never change, as we have a contract with Visual Studio
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_BindBack_InvalidMethod">
            <summary>
              Looks up a localized string similar to BindBack must point to a method that takes one argument of type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_BindBack_NotFound">
            <summary>
              Looks up a localized string similar to BindBack was expected, but not found.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_BindBack_NotMethod">
            <summary>
              Looks up a localized string similar to BindBack must point to a method.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_BindBack_Unexpected">
            <summary>
              Looks up a localized string similar to Unexpected BindBack found.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_CastCannotStartWithAttachedProperty">
            <summary>
              Looks up a localized string similar to Starting a cast with an attached property is not supported.  Try the &quot;path.(owner.property)&quot; syntax.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_ConverterWithFunctionBindingNotSupported">
            <summary>
              Looks up a localized string similar to Using a converter with function binding is not supported.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_FieldNameElementName_Conflict">
            <summary>
              Looks up a localized string similar to Ambiguous name &apos;{0}&apos; used in x:Bind.  Could either refer to a named element within template, or a field on the data root - assuming data root field.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_FieldNameElementName_ConflictBadConfig">
            <summary>
              Looks up a localized string similar to Name &apos;{0}&apos; used in x:Bind references an x:Name&apos;d element, but there is also an unbindable field of the same name on the data root.  If you meant to bind to the data root, rename element &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_FunctionReturnTypeInvalid">
            <summary>
              Looks up a localized string similar to Function return type &apos;{0}&apos; must match binding target type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_InvalidCast">
            <summary>
              Looks up a localized string similar to Unable to cast type &apos;{0}&apos; to &apos;{1}&apos;.  Use a converter or function binding to change the type.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_InvalidFallbackValue">
            <summary>
              Looks up a localized string similar to Only string and {x:Null} are supported for FallbackValue.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_InvalidPropertyPathSyntax">
            <summary>
              Looks up a localized string similar to Invalid property path syntax.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_NeedsConverter">
            <summary>
              Looks up a localized string similar to Cannot directly bind type &apos;{0}&apos; to &apos;{1}&apos;. Use a cast, converter or function binding to change the type.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_OneWay_NoWay">
            <summary>
              Looks up a localized string similar to OneWay bindings require at least one of their steps to support raising notifications when their value changes.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_OrphanConverterParam">
            <summary>
              Looks up a localized string similar to {0} cannot be specified without an actual converter.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_RequiresConditionalNamespace">
            <summary>
              Looks up a localized string similar to Binding requires a conditional namespace because at least one step in the binding path is conditional.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_UpdateSourceTrigger_ExplicitUnsupported">
            <summary>
              Looks up a localized string similar to &apos;Explicit&apos; is not a supported value for &apos;UpdateSourceTrigger&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_UpdateSourceTrigger_LostFocusEventRequired">
            <summary>
              Looks up a localized string similar to &apos;LostFocus&apos; is only supported with members that expose a &apos;LostFocus&apos; event.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_UpdateSourceTrigger_PropertyChangedOnlyOnDP">
            <summary>
              Looks up a localized string similar to &apos;PropertyChanged&apos; is only supported with members that are DependencyProperty.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_UpdateSourceTrigger_UnrecognizedValue">
            <summary>
              Looks up a localized string similar to Unrecognized value for &apos;UpdateSourceTrigger&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_UpdateSourceTrigger_UpdateSourceTriggerOnlyWithTwoWay">
            <summary>
              Looks up a localized string similar to &apos;UpdateSourceTrigger&apos; may only be used with binding &apos;Mode=TwoWay&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_XamlXBindAssignmentValidationError">
            <summary>
              Looks up a localized string similar to Invalid binding assignment : {0}.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_XamlXBindParseError">
            <summary>
              Looks up a localized string similar to Invalid binding path &apos;{0}&apos; : {1}.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindAssignment_XamlXBindUsedInStyleError">
            <summary>
              Looks up a localized string similar to Cannot use x:Bind in Styles.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindPathParser_CantBindToMethods">
            <summary>
              Looks up a localized string similar to Binding to methods is not supported.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindPathParser_CantTwoWayCastStep">
            <summary>
              Looks up a localized string similar to TwoWay binding is invalid when the binding expression ends with a cast.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindPathParser_PathSetTwice">
            <summary>
              Looks up a localized string similar to The value for Path is set twice..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BindPathParser_UnexpectedReflectionType">
            <summary>
              Looks up a localized string similar to Unexpected member type &apos;{1}&apos; when binding to &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BoundEventAssignment_InvalidSignature">
            <summary>
              Looks up a localized string similar to Invalid signature for event &apos;{0}&apos;. Events can only be bound to methods that match the event signature or are parameterless.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BoundEventAssignment_NonDelegateProperty">
            <summary>
              Looks up a localized string similar to Event &apos;{0}&apos; can only be bound to properties of delegate type {1}.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BoundEventAssignment_NonLeafMethod">
            <summary>
              Looks up a localized string similar to Invalid path node &apos;{0}&apos;. Methods can only be used as the leaf node in an event binding.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BoundEventAssignment_NoOverloads">
            <summary>
              Looks up a localized string similar to Events can only be bound to non-overloaded methods.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.BoundEventAssignment_SignatureMismatch">
            <summary>
              Looks up a localized string similar to Invalid signature for event &apos;{0}&apos;. Parameter {1} of type &apos;{2}&apos; is not assignable from type &apos;{3}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.ConditionalNamespace_ConditionalInStandard">
            <summary>
              Looks up a localized string similar to Cannot use a platform conditional expression in a strict Xaml Standard app.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.ConditionalNamespace_FailedToParse">
            <summary>
              Looks up a localized string similar to {1} while parsing conditional namespace expression &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.ConditionalNamespace_MultipleApiInformations">
            <summary>
              Looks up a localized string similar to Multiple runtime conditionals found.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.ConditionalNamespace_MultipleTargetPlatforms">
            <summary>
              Looks up a localized string similar to Multiple TargetPlatforms found.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.ConditionalNamespace_UnmatchedApiInformationParameters">
            <summary>
              Looks up a localized string similar to Unmatched API information parameters for method &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.ConditionalNamespace_UnrecognizedApiInformation">
            <summary>
              Looks up a localized string similar to Unrecognized API information &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.CppCodeGen_MissingMember">
            <summary>
              Looks up a localized string similar to Type code generation error.  Missing member &apos;{0}&apos; in the master member table.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.CreateFromString_InvalidMethodSignature">
            <summary>
              Looks up a localized string similar to CreateFromString method &apos;{0}&apos; declared on type &apos;{1}&apos; must accept a string as its first argument.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.CreateFromString_MethodOnTypeNotFound">
            <summary>
              Looks up a localized string similar to Could not find CreateFromString method &apos;{0}&apos; declared on type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.CreateFromString_TypeNotFound">
            <summary>
              Looks up a localized string similar to Could not find type for CreateFromString method &apos;{0}&apos; declared on type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.DuiSchema_AmbiguousCollectionAdd">
            <summary>
              Looks up a localized string similar to Ambiguous match, the type &apos;{0}&apos; has more than one &apos;{1}&apos; method with &apos;{2}&apos; parameters.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.DuiSchema_ArgumentNotXamlDirective">
            <summary>
              Looks up a localized string similar to Argument must be of type XamlDirective.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.DuiSchema_BadBindablePropertyProvider">
            <summary>
              Looks up a localized string similar to Marking class &apos;{0}&apos; &apos;[Bindable]&apos; will prevent use of its ICustomPropertyProvider Interface.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.DuiSchema_BindableNotSupportedOnGeneric">
            <summary>
              Looks up a localized string similar to &apos;[Bindable]&apos; on generic type &apos;{0}&apos; is not supported.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.DuiSchema_CustomAttributesTypeLoadException">
            <summary>
              Looks up a localized string similar to Type Load Exception reading assembly attributes for &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.DuiSchema_GetAllXamlTypeNotImpl">
            <summary>
              Looks up a localized string similar to GetAllXamlTypes is not implemented for namespace {0}.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.DuiSchema_TypeLoadException">
            <summary>
              Looks up a localized string similar to Type Load Exception loading type &apos;{0}&apos; from reference &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.DuiSchema_TypeLoadExceptionMessage">
            <summary>
              Looks up a localized string similar to Type Load problem with type &apos;{0}&apos;: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.DuiSchema_WRTAssembliesMissing">
            <summary>
              Looks up a localized string similar to SDK is not installed.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.Harvester_ClassMustHaveANamespace">
            <summary>
              Looks up a localized string similar to Invalid class name &apos;{0}&apos;.  Class names must have a namespace followed by a name, separated by a &apos;.&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.Harvester_ClassNameEmptyPathPart">
            <summary>
              Looks up a localized string similar to Invalid class name &apos;{0}&apos;.  Empty path components are not allowed.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.Harvester_ClassNameNoWhiteSpace">
            <summary>
              Looks up a localized string similar to Invalid class name &apos;{0}&apos;.  Whitespace is not allowed in path components: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.Harvester_ControlTemplateDoesNotDefineTargetType">
            <summary>
              Looks up a localized string similar to &apos;TargetType&apos; is required to use x:Bind inside a ControlTemplate.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.Harvester_DataTemplateDoesNotDefineDataType">
            <summary>
              Looks up a localized string similar to DataTemplates containing x:Bind need a DataType to be specified using &apos;x:DataType&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.Harvester_ProjectFolderIsNotADirectory">
            <summary>
              Looks up a localized string similar to ProjectFolder is not a path to a Directory.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.TypeInfoReflection_TypeViolatesNamingConvention">
            <summary>
              Looks up a localized string similar to Type info reflection is enabled, but type &apos;{0}&apos; is not under the root namespace &apos;{1}&apos;.  Either move the type under the root namespace, or disable type info reflection by adding &apos;&lt;PropertyGroup&gt;&lt;EnableTypeInfoReflection&gt;false&lt;/EnableTypeInfoReflection&gt;&lt;/PropertyGroup&gt;&apos; to your project file.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlAppFile_MustBeNamedApp_xaml">
            <summary>
              Looks up a localized string similar to Application main file must be named App.xaml.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_BadName">
            <summary>
              Looks up a localized string similar to The value &apos;{0}&apos; is an invalid value for &apos;{1}&apos; on object &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_BadNameChar">
            <summary>
              Looks up a localized string similar to The value &apos;{0}&apos; is an invalid value for &apos;{1}&apos; on object &apos;{2}&apos;.  Illegal character &apos;{3}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_BadValueInSupressWarningsList">
            <summary>
              Looks up a localized string similar to Bad Value &apos;{0}&apos; found in Suppressed XAML Warnings list.  Values must be integers seperated with &apos;;&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_BaseFilenamesMustBeTheSame">
            <summary>
              Looks up a localized string similar to The class named &apos;{0}&apos; is represented by files with more than one base filename: &apos;{1}&apos; and &apos;{2}&apos;. The base filenames for a single class must be unique..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_BindingSetValueFailed">
            <summary>
              Looks up a localized string similar to Binding failure in assigning &apos;{0}.{1}&apos; = &apos;{2}&apos; at {3}, line {4} : .
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_BindingUpdateFailed">
            <summary>
              Looks up a localized string similar to Binding update failed for &apos;{0}&apos; : .
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CannotHaveDeferLoadStrategy">
            <summary>
              Looks up a localized string similar to x:DeferLoadStrategy can only be used on UIElement or FlyoutBase type elements that are not direct children of a resource dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CannotNameElementTwice">
            <summary>
              Looks up a localized string similar to Cannot name element twice..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CantAccessNonPublicType">
            <summary>
              Looks up a localized string similar to Cannot access non-public type &apos;{0}&apos; in XMLnamespace &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CantAddToCollectionObject">
            <summary>
              Looks up a localized string similar to Cannot add &apos;{0}&apos; into the collection object &apos;{1}&apos;, type must be &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CantAddToCollectionProperty">
            <summary>
              Looks up a localized string similar to Cannot add &apos;{0}&apos; into the collection property &apos;{1}&apos;, type must be &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CantAddToDictionaryObject">
            <summary>
              Looks up a localized string similar to Cannot add &apos;{0}&apos; into the dictionary object &apos;{1}&apos;, type must be &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CantAddToDictionaryProperty">
            <summary>
              Looks up a localized string similar to Cannot add &apos;{0}&apos; into the dictionary property &apos;{1}&apos;, type must be &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CantAssign">
            <summary>
              Looks up a localized string similar to Cannot assign &apos;{0}&apos; into property &apos;{1}&apos;, type must be assignable to &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CantAssignTextToProperty">
            <summary>
              Looks up a localized string similar to Cannot assign text value &apos;{0}&apos; into property &apos;{1}&apos; of type &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CantAssignToReadOnlyProperty">
            <summary>
              Looks up a localized string similar to Cannot assign &apos;{0}&apos; into the read only property &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CantNameValueTypes">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos;, and &quot;Value Types&quot; in general, cannot use x:Name.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CantResolveAssembly">
            <summary>
              Looks up a localized string similar to Cannot resolve Assembly or Windows Metadata file &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CantResolveDataType">
            <summary>
              Looks up a localized string similar to Cannot resolve DataType {0}.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CantResolveWindowsMetadata">
            <summary>
              Looks up a localized string similar to Cannot resolve &apos;Windows.metadata&apos;.  Please install the Windows Software Development Kit. The Windows SDK is installed with Visual Studio..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CodeGenString_Bad">
            <summary>
              Looks up a localized string similar to Unrecognized substring of the CodeGenerationControlFlag &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CodeGenString_NotSupported">
            <summary>
              Looks up a localized string similar to Code Generation Control Flag &apos;{0}&apos; is not supported.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CodeGenString_Using">
            <summary>
              Looks up a localized string similar to Code Generation Control Flag(s) are in effect: ({0}).
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_CodeLangNotSupported">
            <summary>
              Looks up a localized string similar to XAML code behind generation is not supported for the language {0}.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_DeferLoadStrategyMissingXName">
            <summary>
              Looks up a localized string similar to Element must have x:Name attribute specified since it uses x:DeferLoadStrategy..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_Deprecated">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is deprecated: {1}.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_DictionaryItemsCannotBeText">
            <summary>
              Looks up a localized string similar to Dictionary Items cannot be Text: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_DictionaryItemsHasDuplicateKey">
            <summary>
              Looks up a localized string similar to Dictionary Item &apos;{0}&apos; has duplicate key &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_DictionaryItemsMustHaveKeys">
            <summary>
              Looks up a localized string similar to Dictionary Item &apos;{0}&apos; must have a Key attribute.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_DuplicateTypeName">
            <summary>
              Looks up a localized string similar to A type with a full name of &apos;{0}&apos; already exists in an included reference..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_DuplicationAssignment">
            <summary>
              Looks up a localized string similar to Duplication assignment to the &apos;{0}&apos; property of the &apos;{1}&apos; object.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_ElementNameAlreadyUsed">
            <summary>
              Looks up a localized string similar to Element name &apos;{0}&apos; is already used in this scope..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_EventValuesMustBeText">
            <summary>
              Looks up a localized string similar to Invalid value for &apos;{0}&apos;. Event values must be text.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_Experimental">
            <summary>
              Looks up a localized string similar to {0} is for evaluation purposes only and is subject to change or removal in future updates..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_FeatureNotInMinVersion">
            <summary>
              Looks up a localized string similar to The &apos;{0}&apos; feature is not supported in Min Target Platform Version &apos;{2}&apos;. Update your Min Target Platform Version to &apos;{1}&apos; or above..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_FeatureOnlyInTargetVersion">
            <summary>
              Looks up a localized string similar to The &apos;{0}&apos; feature is not supported in your Min Target Platform Version. Update your Min Target Platform Version to match your Target Platform Version..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_FileOpenFailure">
            <summary>
              Looks up a localized string similar to Error opening XAML file for reading: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_IdPropertiesMustBeText">
            <summary>
              Looks up a localized string similar to Values for &apos;{0}&apos; property must be Text.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_InternalErrorProcessingStyle">
            <summary>
              Looks up a localized string similar to Internal error while processing Style.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_InvalidCPA">
            <summary>
              Looks up a localized string similar to Invalid ContentPropertyAttribute on type &apos;{0}&apos;, property &apos;{1}&apos; is not found.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_InvalidFieldModifier">
            <summary>
              Looks up a localized string similar to Invalid FieldModifier value: &apos;{0}&apos; on &apos;{1}&apos;.  Must be private, public, protected, internal or friend.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_InvalidPropertyType">
            <summary>
              Looks up a localized string similar to Type {0} on property {1} is invalid.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_InvalidSignedChar">
            <summary>
              Looks up a localized string similar to Type {0} on property {1} is invalid.  Signed Char is not a valid WinRT type.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_InvalidValueForPhase">
            <summary>
              Looks up a localized string similar to Phase value must be a positive integer less than 25..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_LanguageUnsupported">
            <summary>
              Looks up a localized string similar to The language &apos;{0}&apos; is not supported.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_LoadConflict">
            <summary>
              Looks up a localized string similar to An element cannot have both x:Load and x:DeferLoadStrategy.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_LoadMissingName">
            <summary>
              Looks up a localized string similar to Element must have x:Name attribute specified since it uses x:Load..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_LoadNotSupported">
            <summary>
              Looks up a localized string similar to x:Load cannot be used on the root of a Page, User Control or DataTemplate, or direct children of a Resource Dictionary, and can only be used on elements of type UIElement or FlyoutBase.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_MemberContractDoesNotExist">
            <summary>
              Looks up a localized string similar to Member &apos;{3}&apos; on type &apos;{0}&apos; is defined under contract &apos;{1}&apos; version &apos;{2}&apos;, but the contract doesn&apos;t exist in the targeted min version!.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_MissingCPA">
            <summary>
              Looks up a localized string similar to Missing Content Property definition for Element &apos;{0}&apos; to receive content &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_MoreThanOneApplicationXaml">
            <summary>
              Looks up a localized string similar to A project cannot have more than one ApplicationXaml item.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_MustNotSetLocalAssembly">
            <summary>
              Looks up a localized string similar to The LocalAssembly property of the CompileXaml Task must not be set when IsPass1 is set to True.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_MustSetLocalAssembly">
            <summary>
              Looks up a localized string similar to The LocalAssembly property of the CompileXaml Task must be set when IsPass1 is set to True.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_NoEventsInAppXaml">
            <summary>
              Looks up a localized string similar to Events cannot be set in the Application class XAML file.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_NotConstructibleObj">
            <summary>
              Looks up a localized string similar to XAML {0} type cannot be constructed. In order to be constructed in XAML, a type cannot be abstract, interface, nested, generic or a struct, and must have a public default constructor.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_NoXamlGiven">
            <summary>
              Looks up a localized string similar to CompileXaml Task invoked with no XAML to compile.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_NullablePropertyType">
            <summary>
              Looks up a localized string similar to Cannot assign to nullable type on property {0}.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_OnlyOneLocalAssembly">
            <summary>
              Looks up a localized string similar to LocalAssembly property may only have one Item.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_PhaseMustBeUsedWithinADataTemplate">
            <summary>
              Looks up a localized string similar to Phase can only be used within a DataTemplate.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_PhaseMustHaveAssociatedBind">
            <summary>
              Looks up a localized string similar to Phase must be used with Bind.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_PlatformUnsupported">
            <summary>
              Looks up a localized string similar to The platform &apos;{0}&apos; is not supported.  Use &apos;UWP&apos;, &apos;iOS&apos;, or &apos;Android&apos; for XamlPlatform.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_Preview">
            <summary>
              Looks up a localized string similar to {0} support is currently in preview and may change in future updates..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_SetterMustHaveValue">
            <summary>
              Looks up a localized string similar to Setter object must specify a value for the Value Property.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_SetterPropertyMustBeDP">
            <summary>
              Looks up a localized string similar to Property &apos;{0}&apos; must be a DependencyProperty to be set with a Setter.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_SettersMustHaveProperty">
            <summary>
              Looks up a localized string similar to Setter object must specify a String value for the Property or Target property.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_SetterValueWrongType">
            <summary>
              Looks up a localized string similar to The type of Value &apos;{0}&apos; is not assignable to the type of the Property &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_StyleBasedOnBadStyleTargetType">
            <summary>
              Looks up a localized string similar to BasedOn TargetType &apos;{0}&apos; is not assignable to the Style&apos;s TargetType &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_StyleBasedOnMustBeStyle_BadObj">
            <summary>
              Looks up a localized string similar to Style BasedOn property must be a Style, not &apos;{0}&apos; object.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_StyleBasedOnMustBeStyle_SR">
            <summary>
              Looks up a localized string similar to Style BasedOn property must be a Style.  StaticResource &apos;{0}&apos; resolves to &apos;{1}&apos; not Style.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_StyleBasedOnMustBeStyle_Text">
            <summary>
              Looks up a localized string similar to Style BasedOn property must be a Style, not text value &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_StyleMustHaveTargetType">
            <summary>
              Looks up a localized string similar to Style object must specify a String value for the TargetType property.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_TwoWayTargetNotADependencyProperty">
            <summary>
              Looks up a localized string similar to TwoWay binding target &apos;{0}&apos; must be a dependency property.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_TypeContractDoesNotExist">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; is defined under contract &apos;{1}&apos; version &apos;{2}&apos;, but the contract doesn&apos;t exist in the targeted min version!.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_TypeMustHaveANamespace">
            <summary>
              Looks up a localized string similar to Invalid class name &apos;{0}&apos;. Types must be in a namespace to be referenced in XAML; they cannot be declared in the global namespace.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_UnknownAttachableMember">
            <summary>
              Looks up a localized string similar to Unknown attachable member &apos;{0}.{1}&apos; on element &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_UnknownMember">
            <summary>
              Looks up a localized string similar to Unknown member &apos;{0}&apos; on element &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_UnknownObject">
            <summary>
              Looks up a localized string similar to Unknown type &apos;{0}&apos; in XML namespace &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_UnknownSetterAttachableMember">
            <summary>
              Looks up a localized string similar to Unknown attachable member &apos;{0}&apos; on element &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_UnknownStyleTargetType">
            <summary>
              Looks up a localized string similar to Unknown target type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_UnresolvedForwardedTypeAssembly">
            <summary>
              Looks up a localized string similar to A type&apos;s assembly could not be resolved.  This is often because it was forwarded to an unresolved assembly: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_WrongMemberContract">
            <summary>
              Looks up a localized string similar to Member &apos;{4}&apos; on type &apos;{0}&apos; is defined under contract &apos;{1}&apos; version &apos;{2}&apos;, but the contract version for the targeted min version is &apos;{3}&apos;!.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_WrongTypeContract">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; is defined under contract &apos;{1}&apos; version &apos;{2}&apos;, but the contract version for the targeted min version is &apos;{3}&apos;!.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_XamlFileMustEndInDotXaml">
            <summary>
              Looks up a localized string similar to XAML files must end in &apos;.xaml&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_XamlFilesHaveTheSameName">
            <summary>
              Looks up a localized string similar to XAML files &apos;{0}&apos; and &apos;{1}&apos; have the same project path &apos;{2}&apos;.  Each file must have a unique project path..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_XBindInsideXBind">
            <summary>
              Looks up a localized string similar to Nested x:Bind expressions are not supported.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_XBindOnControlTemplate">
            <summary>
              Looks up a localized string similar to x:Bind is only supported inside the ControlTemplate.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_XBindOutOfScopeUnsupported">
            <summary>
              Looks up a localized string similar to Binding resolved to named element &apos;{0}&apos; on line {1}, but binding to named elements outside the current namescope is not supported in the app&apos;s targeted minimum version..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_XBindTargetNullValueOnNonNullableType">
            <summary>
              Looks up a localized string similar to TargetNullValue cannot be applied on &apos;{0}&apos; because its type &apos;{1}&apos; is not nullable.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_XBindWithoutCodeBehind">
            <summary>
              Looks up a localized string similar to This Xaml file must have a code-behind class to use {x:Bind}. See http://go.microsoft.com/fwlink/?LinkID=532920&amp;clcid=0x409 for more information.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_xClassTypeDoesntMatchWinmd">
            <summary>
              Looks up a localized string similar to The type path of x:Class &apos;{0}&apos; does not match the name of the Windows metadata &apos;{1}&apos; file.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_xClassTypeIsNotFound">
            <summary>
              Looks up a localized string similar to x:Class type &apos;{0}&apos; is not found in &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlCompiler_XPropertyUsageNotSupportedForLanguage">
            <summary>
              Looks up a localized string similar to This usage of x:Property is not supported for this language: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlDom_IncorrectMemberConstructor">
            <summary>
              Looks up a localized string similar to Incorrect XamlDomMember constructor has been called.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlDom_MemberDifferentSchemas">
            <summary>
              Looks up a localized string similar to The passed SchemaContext must match the XamlMember&apos;s SchemaContext.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlDom_MemberHasMoreThanOneItem">
            <summary>
              Looks up a localized string similar to This Member &apos;{0}&apos; has more than one item, use the Items property.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlDom_SealedNamespaceCollection">
            <summary>
              Looks up a localized string similar to Modification of a Namespace Collection failed because it was sealed.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlDom_SealedXamlDomNode">
            <summary>
              Looks up a localized string similar to Modification of XamlDomNode failed because it was sealed.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlDom_TypeDifferentSchemas">
            <summary>
              Looks up a localized string similar to The provided SchemaContext must match the XamlType&apos;s SchemaContext.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlDom_UnknownAttachableMember">
            <summary>
              Looks up a localized string similar to Unknown Attachable Members &apos;{0}&apos; are not supported in the XAML Dom.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlDom_UseHasAttachedMember">
            <summary>
              Looks up a localized string similar to Attachable members are not supported in HasMember.  Please call HasAttachableMember.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlDom_UseHasGetAttachedMember">
            <summary>
              Looks up a localized string similar to Attachable members are not supported in GetMemberNode.  Please call GetAttachableMemberNode.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlInternlError">
            <summary>
              Looks up a localized string similar to Xaml Internal Error.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlRewriter_CompiledBindingsCannotBeInElementForm">
            <summary>
              Looks up a localized string similar to Compiled Bindings cannot be processed in Property Element form.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlRewriter_EventsAcrossLine">
            <summary>
              Looks up a localized string similar to Event values cannot be broken across a line boundary.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlRewriter_EventsCannotBeInElementForm">
            <summary>
              Looks up a localized string similar to Events cannot be processed in Property Element form.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlRewriter_XamlRewriterErrorDataTypeLongForm">
            <summary>
              Looks up a localized string similar to Error processing DataType attribute.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlValidationError_AmbiguousEvent">
            <summary>
              Looks up a localized string similar to Objects which use an event, and whose type is defined in the currently building assembly, must also have an x:Name.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlValidationError_DataTypeOnlyAllowedOnDataTemplate">
            <summary>
              Looks up a localized string similar to DataType is only allowed for DataTemplate..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlValidationError_DefaultBindModeInvalidValue">
            <summary>
              Looks up a localized string similar to Invalid value specified for attribute &apos;{0}&apos;.  Accepted values are &apos;OneWay&apos;, &apos;OneTime&apos;, or &apos;TwoWay&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlValidationError_DeferLoadStrategyInvalidValue">
            <summary>
              Looks up a localized string similar to Invalid value specified for attribute &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlValidationError_InvalidAttributeValue">
            <summary>
              Looks up a localized string similar to Invalid value specified for attribute &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XamlXmlParsingError">
            <summary>
              Looks up a localized string similar to Xaml Xml Parsing Error.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XbfGeneration_CouldNotLoadXbfGenerator">
            <summary>
              Looks up a localized string similar to Cannot resolve &apos;GenXbf.dll&apos; under path &apos;{0}&apos;.  Please install the latest version of the Windows 10 Software Development Kit..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XbfGeneration_GeneralFailure">
            <summary>
              Looks up a localized string similar to Failure Generating XAML Binary Format: Exception={0}.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XbfGeneration_MissingWindowsSdkPath">
            <summary>
              Looks up a localized string similar to Cannot resolve &apos;GenXbf.dll&apos;.  Please install the latest version of the Windows 10 Software Development Kit..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XbfGeneration_MissingXbfApi">
            <summary>
              Looks up a localized string similar to XBF generation failure due to missing Windows 10 Support, Set property &lt;DisableXbfGeneration&gt;true&lt;/DisableXbfGeneration&gt; in your Project file and try again..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XbfGeneration_PropertyNotFoundError">
            <summary>
              Looks up a localized string similar to The XAML Binary Format (XBF) generator reported syntax error &apos;0x09C4&apos; : Property Not Found.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XbfGeneration_SyntaxError">
            <summary>
              Looks up a localized string similar to The XAML Binary Format (XBF) generator reported syntax error &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XbfGeneration_SyntaxErrorME">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; used after &apos;{{&apos; must be a Markup Extension. Error code {1}..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XbfGeneration_XamlInputFileOpenFailure">
            <summary>
              Looks up a localized string similar to Error opening XAML file for reading: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Properties.XamlCompilerResources.XbfGeneration_XbfOutputFileOpenFailure">
            <summary>
              Looks up a localized string similar to Error opening XBF File for writing: {0}.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.CompileXamlInternal">
            <summary>
            Called to build the .designer files for the given set of xaml files
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CompileXamlInternal.DidXAMLFilesChange">
            <summary>
            This is just a XAML timestamp check - both passes.
            If any of the generated files are out of date, we need to regen them
            </summary>
            <returns>TRUE if we need to perform any additional work</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.CompileXamlInternal.UnloadReferences">
            <summary>
            We have to free up any assemblies we may have kept open
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Utilities.NativeMethodsHelper.LoadLibrary32_64(System.String,System.String)">
            <summary>
            Loads the dll based on the process architecture and returns the dll handle
            </summary>
            <param name="path32bit">Path to the 32 bit binary</param>
            <param name="path64bit">Path to the 64 bit binary</param>
            <returns>Returns the Dll Handle</returns>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Utilities.ResourceUtilities">
            <summary>
            This class contains utility methods for dealing with resources.
            </summary>
            <owner>SumedhK</owner>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Utilities.ResourceUtilities.ExtractMessageCode(System.Text.RegularExpressions.Regex,System.String,System.String@)">
            <summary>
            Extracts the message code (if any) prefixed to the given string. If a message code pattern is not supplied, the
            MSBuild message code pattern is used by default. The message code pattern must contain two named capturing groups
            called "CODE" and "MESSAGE" that identify the message code and the message respectively.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <owner>SumedhK</owner>
            <param name="messageCodePattern">The Regex used to find the message code (can be null).</param>
            <param name="messageWithCode">The string to parse.</param>
            <param name="code">[out] The message code, or null if there was no code.</param>
            <returns>The string without its message code prefix.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Utilities.ResourceUtilities.FormatString(System.String,System.Object[])">
            <summary>
            Formats the given string using the variable arguments passed in.

            PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
            the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <owner>SumedhK</owner>
            <param name="unformatted">The string to format.</param>
            <param name="args">Optional arguments for formatting the given string.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.XamlTypeInfoValidator.ValidateCreateFromStringMethod(Microsoft.UI.Xaml.Markup.Compiler.CodeGen.InternalTypeEntry)">
            <summary>
            Validates that type has a valid CreateFromString method that exists
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomObject.ResolveMemberName(System.Xaml.XamlType,System.Xaml.XamlType,System.String)">
            <summary>
            Resolve the member name
            </summary>
            <param name="xamlTargetType">This is the type of the Element tag the property is associated with.</param>
            <param name="memberType">This is the type of the first half of the '.' syntax.  Ie: MemberType.PropName</param>
            <param name="shortPropertyName">Name of the Property, no '.'s</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedConstructorInfo">
            <summary>
            Represent the fabricated constructors on an array class.
            See Ecma IIb 14.2.
            Each array has 2 constructors which just take a vector of integers for the parameter.
            One ctor has an Int32 parameter for each dimension.
            The other ctor has 2 Int32 parameters for each dimension
            </summary>
            <remarks>
            Reflection requires constructors derive from ConstructorInfo. However, we want to share
            extensive functionality with the fabricated methods.
            So we have an internal Adapter that uses the array fabricated MethodInfo support,
            and then we publicly wrap it in a ConstructorInfo for public consumption.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedConstructorInfo.#ctor(System.Type,System.Int32)">
            <summary>
            Ctor for array fabricated constructor.
            </summary>
            <param name="arrayType">The declaring type that the ctor is on. arrayType.IsArrayType must be true.</param>
            <param name="numParams">the number of Int32 parameters in the ctor's signature.</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedConstructorInfo.GetCustomAttributes(System.Boolean)">
            <summary>
            To make it easier for LMR clients that extend LMR objects, we directly
            return empty arrays here so they don't need to go through factory.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedConstructorInfo.GetCustomAttributes(System.Type,System.Boolean)">
            <summary>
            To make it easier for LMR clients that extend LMR objects, we directly
            return empty arrays here so they don't need to go through factory.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedConstructorInfo.Adapter">
            <summary>
            Internal Adapter to provide functionality using ArrayFabricatedMethodInfo.
            This is then publicly wrapped in a constructorInfo to match the reflection construct.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedGetMethodInfo">
            <summary>
            MethodInfo represented the fabricated method for an Array getter.
            Signature is:
                T Get(...)
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedSetMethodInfo">
            <summary>
            MethodInfo represented the fabricated method for an Array setter.
            Signature is:
                void Set(..., T)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedAddressMethodInfo" -->
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedMethodInfo">
            <summary>
            Base class for MethodInfos for fabricated methods on an array (Get/Set/Address).
            Each specific method can have its own derived class. This avoids having to eagerly populate
            all the properties and facilates quickly creating tearoff objects with lazy properties.

            The MethodInfo's signatures are a function of the declaring type's Array rank and element type.
             "..." represents a set of parameters, one int32 for each dimension in the array. This depends on the rank.
             "T" represents the declaring type's element type.

            You can see this codepath by inspecting something like:
               elementType.MakeArrayType(n).GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public).

            Unfortunately, most of the values here are not specified. These are reverse engineered from observing the CLR's behavior.
            </summary>
            <remarks>
            This derives directly from MethodInfo (and not some LMR equivalent), and so this is technically a non-LMR implementation.
            So this exercises mixing non-LMR and LMR implementations.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedMethodInfo.#ctor(System.Type)">
            <summary>
            Protected constructor for derived classes.
            </summary>
            <param name="arrayType"></param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedMethodInfo.MakeParameterHelper(System.Int32)">
            <summary>
            Helper to Get the fabricated parameters for the rank.
            See Ecma IIb 14.2 for details. This is an System.Int32 parameter for each rank in the array
            </summary>
            <param name="extra">Allocate extra slots at the end of the ParameterInfo array.
            Some signatures (eg, Set(..., T)) have additional parameters. So we allow allocating extra space so
            that the caller can just fill in the extra parameters without reallocating a new array.
            </param>
            <returns>an array of ParameterInfos of length (this.Rank + extra).
            </returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedMethodInfo.GetCustomAttributes(System.Boolean)">
            <summary>
            To make it easier for LMR clients that extend LMR objects, we directly
            return empty arrays here so they don't need to go through factory.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ArrayFabricatedMethodInfo.GetCustomAttributes(System.Type,System.Boolean)">
            <summary>
            To make it easier for LMR clients that extend LMR objects, we directly
            return empty arrays here so they don't need to go through factory.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyFactory">
            <summary>
            Public factory to allow callers to create an Assembly implementation without needing to expose the assembly
            implementation directly.
            This is the most basic building block for allocation. Caller is reponsible for:
            - getting the MetadataFile (IMetadataImport) in the first place.
            - updating the Universe with the new assembly.
            MetadataFileLoader class layers on top of this to provide better universe integration.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyFactory.CreateAssembly(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.String)">
            <summary>
            Pass in TokenResolver (module) so that the caller can create a derived instance.
            This only supports creating single-module assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyFactory.CreateAssembly(System.Reflection.Adds.ITypeUniverse,System.Reflection.Adds.MetadataFile,System.String)">
            <summary>
            Create a single-module assembly around the metadata importer.
            </summary>
            <param name="typeUniverse">Type universe in which types are resolved.</param>
            <param name="metadataImport">IMetadataImport representing single-module assembly.</param>
            <returns>Assembly object representing single-module assembly.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyFactory.CreateAssembly(System.Reflection.Adds.ITypeUniverse,System.Reflection.Adds.MetadataFile,Microsoft.UI.Xaml.Markup.Compiler.Lmr.IReflectionFactory,System.String)">
            <summary>
            Overload taking an IReflection factory
            </summary>
            <param name="typeUniverse">Type universe in which types are resolved.</param>
            <param name="metadataImport">IMetadataImport representing single-module assembly.</param>
            <param name="factory">reflection factory to use in assembly</param>
            <returns>Assembly object representing single-module assembly.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyFactory.CreateAssembly(System.Reflection.Adds.ITypeUniverse,System.Reflection.Adds.MetadataFile,System.Reflection.Adds.MetadataFile[],System.String,System.String[])">
            <summary>
            Create a multi-module assembly around the metadata importer.
            </summary>
            <param name="typeUniverse">Type universe in which types are resolved.</param>
            <param name="manifestModuleImport">IMetadataImport representing module with manifest.</param>
            <param name="netModuleImports">Array of IMetadataImports representing netmodules.
            Can be null or zero lenght in which case created assembly is a single-module assembly.</param>
            <returns>Assembly object representing multi-module assembly.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyFactory.CreateAssembly(System.Reflection.Adds.ITypeUniverse,System.Reflection.Adds.MetadataFile,System.Reflection.Adds.MetadataFile[],Microsoft.UI.Xaml.Markup.Compiler.Lmr.IReflectionFactory,System.String,System.String[])">
            <summary>
            Create a multi-module assembly around the metadata importer.
            </summary>
            <param name="typeUniverse">Type universe in which types are resolved.</param>
            <param name="manifestModuleImport">IMetadataImport representing module with manifest.</param>
            <param name="netModuleImports">Array of IMetadataImports representing netmodules.
            Can be null or zero lenght in which case created assembly is a single-module assembly.</param>
            <param name="factory">reflection factory to use in assembly</param>
            <returns>Assembly object representing multi-module assembly.</returns>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.CommonIdeHelper">
            <summary>
            Class for test method used by Global DTar feature. LMR exposes this helper function to decrease
            coupling with DTar.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.CommonIdeHelper.GetNameFromPath(System.String)">
            <summary>
            Get an AssemblyName object for the given assembly at the specified path. This will crack the metadata.
            </summary>
            <param name="path">full path to local file assembly. File must exist</param>
            <returns>AssemblyName object parsed from assembly's metadata</returns>
            <remarks>Other dlls (GDTar) may depend on this signature, so be wary of changing it.</remarks>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyNameHelper">
            <summary>
            Helpers for computing AssemblyName objects from metadata information.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyNameHelper.AssemblyNameBuilder">
            <summary>
            This class helps build a System.Reflection.AssemblyName from the raw metadata structures.
            Since the marshaling is very meticulous and involves unmanaged data structures and memory,  we
            wanted a single unified marshaling path for both the AssemblyRef and AssemblyDef paths.

            Derived classes provide the actually call to the metadata APIs.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyNameHelper.AssemblyNameBuilder.Fetch">
            <summary>
            Derived class implements this to fetch the fields from the appropriate metadata API.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyNameHelper.AssemblyNameBuilder.CalculateName">
            <summary>
            Calculate the AssemblyName object from the metadata structures.
            </summary>
            <returns>AssemblyName object</returns>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyNameHelper.AssemblyNameBuilder.AssemblyNameFlags">
            <summary>
            Exposes original assembly name flags read from metadata. Setting Flags property
            on AssemblyName masks some of the bits that are important for determining
            assembly architecture.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyNameHelper.AssemblyNameFromDefitionBuilder">
            <summary>
            Derived class for getting an AssemblyName from an assembly definition.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyNameHelper.GetAssemblyName(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule)">
            <summary>
            Get an assembly name from the metadata for the manifest module
            </summary>
            <param name="module">the manifest module</param>
            <returns>AssemblyName object of the assembly.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyNameHelper.HasV1Metadata(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule)">
            <summary>
            Determines if assembly as built against CLR v1.0 or v1.1.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyNameHelper.AssemblyNameFromRefBuilder">
            <summary>
            Derived class to get an assembly name for an assembly Ref token.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyNameHelper.GetAssemblyNameFromRef(System.Reflection.Adds.Token,Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataAssemblyImport)">
            <summary>
            Get an AssemblyName for an assembly ref token in the given metadata scope
            </summary>
            <param name="assemblyRefToken">an assemblyRef token</param>
            <param name="assemblyImport">a metadata scope containing the token</param>
            <returns>AssemblyName object</returns>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyRef">
            <summary>
            An Assembly proxy object given just the assembly name.
            </summary>
            <remarks>This is just a container for AssemblyName.
            Ideally, this would also implement GetType(string,...) and hand out TypeRefs, and be consumed by the TypeNameParser.
            </remarks>
        </member>
        <member name="F:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyRef.m_name">
            <summary>
            The assembly name that this assembly is for.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ConstructorInfoRef">
            <summary>
            Simple proxy to just chain back to the declaring type.
            This is used in custom attributes so facilitate the design pattern of:
               Ca.Constructor.DeclaringType.FullName
            so that we can get the custom attribute name (and argument types) without resolving.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ConstructorInfoRef.GetSignatureParameters">
            <summary>
            Get the parameter information available in the MethodRef without resolving to a def
            </summary>
            <returns>An array of ParameterInfo objects describing the types (and modifiers) of parameters (but not their
            names and other attributes present only in the definition)</returns>
            <remarks>
            Note that we don't override GetParameters() because it could be a breaking change - omitting information
            (tokens, names, in/out, etc.) that the caller may care about.  For custom attribute processing we explicitly
            opt-in to using this API.
            Note also that this isn't technically the same thing as a method definition signature.  For example, the reference
            signature can include precise types where the definition may be a varargs signature.  Also, I'm not sure if
            optional modifiers are required to match exactly.
            </remarks>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureParameterInfo">
            <summary>
            Parameters created from a methodRef signature
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.CustomModifiers">
            <summary>
            The class is used to represent custom modifiers, defined using modreq ("required modifier")
            and modopt ("optional modifier"). See Standard II.7.1.1
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.DefaultFactory.CreateConstructorInfo(System.Reflection.MethodBase)">
            <summary>
            Create a constructor info around the given method
            </summary>
            <param name="method">method for the constructor</param>
            <returns>a constructor info for the given method</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.DefaultFactory.CreateMethodInfo(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo)">
            <summary>
            Create a MethodInfo for the given method.
            </summary>
            <param name="method">method to create</param>
            <returns>can return method directly, or create a new wrapper arodun it.</returns>
            <remarks> ConstructorInfo and MethodInfo both correspond to a MethodDef token. LMR needs to
            call into the metadata to determine which factory method to call for the token.
            The factory would also need to call into the metadata again to create the instantiated
            ConstructorInfo/MethodInfo object.
            To avoid double calls into the metadata, LMR provides the results via an instantiated
            MethodInfo. A default factory could just return that method. Or it could create its own derived
            method and instantiate it with that data.
            </remarks>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.DefaultUniverse">
            <summary>
            A Type Universe that explicitly provides convenience methods for easily loading metadata
            files with LMR. This is just a trivial wrapper around a LMR Loader object, and then any interesting
            logic should be in the Loader object so that other universe implementations can easily pick it up.
            Non-LMR modules can still be loaded into the universe.
            </summary> // add XML comments....
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.DefaultUniverse.Loader">
            <summary>
            The underlying Loader object.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IReflectionFactory">
            <summary>
            Factory object supplied to LMR, allow creation of custom derived objects.
            See code:DefaultFactory
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IReflectionFactory.CreateTypeVariable(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token)">
            <summary>
            Creates a type variable.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IReflectionFactory.CreateMethodOrConstructor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token,System.Type[],System.Type[])">
            <summary>
            Hook creating a MethodInfo or ConstructorInfo based on methodDef token. This does not work for ref tokens.
            </summary>
            <param name="resolver">module that the token is scoped to</param>
            <param name="methodToken">a methodDef token for a Constructor or methodInfo.</param>
            <param name="typeArgs">type arguments for a generic method. May be null or 0-length. </param>
            <param name="methodArgs">method arguments for a generic method. May be null or 0-length. </param>
            <returns>a MethodBase</returns>
            <remarks>Normally, you need to access the metadata to determine whether a token represents a Method or a Constructor.
            The metadata access can be expensive, and using a token allows a factory to do efficient caching on results without having
            to access the metadata.</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IReflectionFactory.TryCreateMethodBody(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo,System.Reflection.MethodBody@)">
            <summary>
            Allow creating an IL method body for the given method. A method may not have a method body (such
            as a pinvoke). So this has 3 states:
            1. If the factory does not hook, return false. Ignore body parameter.
            2. If the factory does hook, return true
                2a. and there is no method body, set body=null.
                2b. if there is a method body, set body= created instance of the body.

            The factory can use the code:LMRMethodBody to help implement the method body.
            </summary>
            <param name="method">method to create the body for. </param>
            <param name="body">null or newly created method body.</param>
            <returns>true if the body is valid, else false.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IReflectionFactory.CreateTypeRef(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token)">
            <summary>
            Create for a TypeRef token.
            - could implementing caching for TypeRefs
            - could eagerly resolve Types (so return type may not implement ITypeReference)
            - could return an ITypeReference with an arbitrary resolution policy)

            Since a TypeRef can resolve to a non-LMR type, the return type here must be
            System.Type instead of a LMR-specific type.
            </summary>
            <param name="scope">the module that the token is valid in </param>
            <param name="tokenTypeRef">a typeRef token within the module</param>
            <returns>a Type object corresponding to the typeref token. The factory may eagerly resolve the token,
            or return a proxy object that does deferred resolution. </returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IReflectionFactory.CreateSignatureTypeRef(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token,System.Reflection.Adds.CorElementType)">
            <summary>
            Create for a TypeRef token that occured in a signature.
            - could implementing caching for TypeRefs
            - could eagerly resolve Types (so return type may not implement ITypeReference)
            - could return an ITypeReference with an arbitrary resolution policy)

            Since a TypeRef can resolve to a non-LMR type, the return type here must be
            System.Type instead of a LMR-specific type.
            </summary>
            <param name="scope">the module that the token is valid in </param>
            <param name="tokenTypeRef">a typeRef token within the module</param>
            <param name="elementType">the element type used for this token</param>
            <returns>a Type object corresponding to the typeref token. The factory may eagerly resolve the token,
            or return a proxy object that does deferred resolution. </returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IReflectionFactory.CreateTypeSpec(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token,System.Type[],System.Type[])">
            <summary>
            Create for a TypeSpec token. This is similar to a TypeRef that it can create a proxy type.
            </summary>
            <param name="module">module scope that the token is valid in. </param>
            <param name="typeSpecToken">a typespec token in that scope</param>
            <param name="typeArgs">the generic type args for resolving vars</param>
            <param name="methodArgs">the generic method args for resolving mvars.</param>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext">
            <summary>
            Convenience class to group type arg and method args together.
            This is similar to:
              Type.GetGenericArguments.
              Method.GetGenericArguments.

            Signatures also can directly refer to type arguments from the generic context
            ( eg Type arg #2; method arg #1), so this can be passed to a signature resolver to convert an open
            generic type to a closed generic type.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext.VerifyAndUpdateMethodArguments(System.Int32)">
            <summary>
            Verifies that generic context contains the right number of method arguments.
            </summary>
            <remarks>
            Checking number of type arguments is easy since we can get them from class' metadata
            (regardless if we have TypeDef or TypeRef tokens).
            But method arguments are not as easy and we can only get them from signature blob
            if we have MemberRef token. That's why we use this API to check if we are in
            consistent state after we read signature blob context. See OpenGenericContext class
            for alternative implementation.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext.DeleteMethodArgs">
            <summary>
            Returns a generic context with the method args removed.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext.IsNullOrEmptyMethodArgs(Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)">
            <summary>
            Checks if generic context is null or has empty method arguments list.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext.IsNullOrEmptyTypeArgs(Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)">
            <summary>
            Checks if generic context is null or has empty type arguments list.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.HCORENUM">
            <summary>
            Wrapper around unmanaged HCORENUM structure. Metadata enumerators can be rich objects with dynamically allocated memory.
            An HCORENUM can be cast to a direct native pointer and calling IMDI.Close() will delete the underlying memory.
            HCORENUM have all the same dangers as regular unmanaged memory:
            - if we forget to call Close(), we may leak memory
            - if we call Close() and then call another method on the enumerator, we may access deleted memory and crash.
            Because of these dangers, we wrap them and take special care.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.UnmanagedStringMemoryHandle">
            <summary>
            Safehandle for dynamically allocated unicode string.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.UnmanagedStringMemoryHandle.GetAsString(System.Int32)">
            <summary>
            Get the unmanaged string as a System.String. This copies the data from the unmanaged buffer
            so that it can safely be deleted.
            </summary>
            <param name="countCharsNoNull">count of unicode characters not including the null.
            This will be the length of the string</param>
            <returns>System.String representation </returns>
            <remarks>Having a safe accessor here allows us to never expose the raw IntPtr.</remarks>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyMetaData.LocaleString">
            <summary>
            Get the locale as a System.String which copies data from szLocale field . Caller must allocate the szLocale buffer.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.AssemblyMetaData.Locale">
            <summary>
            Get a CultureInfo object for the szLocale field.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Loader">
            <summary>
            Helpers for loading LMR assemblies into a universe.
            This providers various friendly Load() overloads.
            </summary>
            <remarks>Whereas the AssemblyFactory class instantiates LMR objects from low-level IMetadataImports,
            this Loader creates the the IMDIs from things like filenames or byte arrays.
            The Loader also updates the containing universe to provide a consistent model.
            The Loader can also share state across creation calls, such as a shared dispenser or configuration options
            (such as a LMR factory).
            The specific signatures on the loader are somewhat arbitrary with the main goal of providing useful convenience
            methods for loading LMR assemblies into a mutable universe.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Loader.#ctor(System.Reflection.Adds.IMutableTypeUniverse)">
            <summary>
            Creates a metadata loader object and associate it with a universe.
            </summary>
            <param name="universe">The universe that all loaded assemblies will be loaded into.</param>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Loader.Factory">
            <summary>
            Gets or sets the LMR Factory object associated with new modules.
            This will use a default factory rather than return null.
            A factory can be shared across multiple module instances.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Loader.LoadAssemblyFromFile(System.String)">
            <summary>
            Load an assembly at the given filename
            </summary>
            <param name="file">filename of assembly to load into the universe</param>
            <returns>an assembly for the given file</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Loader.LoadAssemblyFromFile(System.String,System.String[])">
            <summary>
            Load a multi-module assembly, explicitly specifying all modules.
            </summary>
            <param name="manifestFile">the filename to the manifest module</param>
            <param name="netModuleFiles">the filenames for the rest of the modules</param>
            <returns>An assembly containing all the modules.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Loader.LoadAssemblyFromByteArray(System.Byte[])">
            <summary>
            Open assembly from a byte-array containing the same contents as the file.
            This is similar to Assembly.Load(byte[]).
            </summary>
            <param name="data">raw byte array. This starts at the 'mz' signature not the 'bsjb' signature. </param>
            <returns>assembly instantiated around the byte array.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Loader.LoadModuleFromFile(System.String)">
            <summary>
            Load just the module (without the assembly) given the filename.
            An isolated module may not include the manifest and so certain operations may not be valid.
            For general use, use LoadAssembly() instead of LoadModule().
            </summary>
            <param name="moduleFileName">filename to the module</param>
            <returns>A module which may not have a manifest. Some operations may be inavlid.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Loader.ResolveModule(System.Reflection.Assembly,System.String)">
            <summary>
            Load a module with the given name as part of a mulit-module assembly
            </summary>
            <param name="containingAssembly">the assembly contaning the module</param>
            <param name="moduleName">the modules name from the metadata as recorded in the containing assembly's module table.</param>
            <returns>a module in the given assembly</returns>
            <remarks>This uses a default policy of looking for the module on disk next to the containing assembly.</remarks>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataExtensionsPolicy">
            <summary>
            Callback object to encapsulate information that's exposed in reflection but not explicitly defined in
            the metadata. This could be due to members injected by the loader, or impedence mismatch between reflection
            object model vs. metadata object model.
            This provides a centralized location for such hooks in the reflection implementation.

            Possible things controlled by this:
            - Pseudo members on Arrays
            - Pseudo custom attributes
            - whether we hide Transparent Proxy
            - whether we expose  __ComObject as a base class

            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataExtensionsPolicy.GetExtraArrayInterfaces(System.Type)">
            <summary>
            An array T[] inherits from System.Array so it implements those interfaces, but the loader
            may add additional interfaces too. This returns any additional interfaces not already on System.Array.
            </summary>
            <param name="elementType">type of the array</param>
            <returns>non-null array of types (may be 0-length) of unique interfaces. </returns>
            <remarks>
            See
            http://blogs.msdn.com/jmstall/archive/2008/05/23/stuff-in-reflection-that-s-not-in-metadata.aspx
            for example and further explanation of this difference.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataExtensionsPolicy.GetExtraArrayMethods(System.Type)" -->
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataExtensionsPolicy.GetExtraArrayConstructors(System.Type)">
            <summary>
            Get the rutime-added constructors on an array.
            Constructor counterpart to GetExtraArrayMethods
            Since Clr 1.0, these include:
                .ctor(...)
                .ctor(... ...)
            </summary>
            <param name="arrayType">the array type. This should be an array type and will serve as the declaring type for the returned methods</param>
            <returns>a set of ConstructorInfos for the array.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataExtensionsPolicy.GetFakeParameterInfo(System.Reflection.MemberInfo,System.Type,System.Int32)">
            <summary>
            Get a ParameterInfo based only from the method signature. Use this when there is no parameter metadata available.
            Many of the ParameterInfo properties will return arbitrary (usually 0) values. This is
            considered policy because these arbitrary values are not represented in the metadata.
            </summary>
            <param name="member">method containing the parameter </param>
            <param name="paramType">type of the parameter</param>
            <param name="position">0-based position of the parameter</param>
            <returns>a ParameterInfo with the supplied properties. </returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataExtensionsPolicy.GetPseudoCustomAttributes(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token)">
            <summary>
            Gets list of pseudo-custom attributes on an object.
            </summary>
            <param name="module">Module in which object is valid.</param>
            <param name="token">Token representing an object we want PCAs on.</param>
            <returns>List of pseudo-custom attributes on a given object.</returns>
            <remarks>This is considered policy since list of PCAs depends on the runtime version.
            Extracting PCAs is also expensive so hosts might want to skip this steps if they
            don't need any of PCAs.</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.IMetadataExtensionsPolicy.TryTypeForwardResolution(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly,System.String,System.Boolean)">
             <summary>
              Try to resolve a type name which may be forwarded.
             </summary>
             <param name="assembly">assembly that containing the TypeForwardedTo attribute</param>
             <param name="fullname">full name of type, as specified in the attribute</param>
             <param name="ignoreCase">true for a case in-sensitive comparison of fullname against the type name in each attribute, false for a case-sensitive comparsion.</param>
             <returns>Null if the type name is not specified in a type forwareded attribute</returns>
             <remarks>
             This is policy because the exact resolution algorithm is tied to the CLR Loader and may change from version to version. For example, type forwarding
             didn't exist in CLR 1.0.

             TODO: Ideally, this should return a TypeRef to an AssemblyRef and never eagerly force resolution.
             However, since we don't yet support AssemblyRefs, this may invoke the type universe to load new assemblies.
             </remarks>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataExtensionsPolicy20">
            <summary>
            Policy to implement semantics from Whidbey (.Net 2.0)
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataExtensionsPolicy20.GetExtraArrayInterfaces(System.Type)">
            <summary>
            With generics, arrays implemenent generic interfaces.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataExtensionsPolicy20.GetPseudoCustomAttributes(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token)">
            <summary>
            Only returns TypeForwardedToAttribute and SerializableAttribute currently.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataExtensionsPolicy20.TryTypeForwardResolution(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly,System.String,System.Boolean)">
            <summary>
            Inspects TypeForwardedTo attributes on the assembly and if the name matches (using a case comparsion specified by ignoreCase)
            resolves it. If names don't match no resolution is performed.
            A TypeForwardTo attribute looks like:
              [assembly: TypeForwardedTo(typeof(Widget))]
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyArrayType">
            <summary>
            This class represents multi-dimentional arrays.
            The CLR makes a distinction between vectors (that is, one-dimensional
            arrays that are always zero-based) and multidimensional arrays.
            A vector, which always has only one dimension, is not the same
            as a multidimensional array that happens to have only one dimension.
            You cannot use this method overload to create a vector type; if rank
            is 1, this method overload returns a multidimensional array type that
            happens to have one dimension.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly">
            <summary>
            Represent a System.Reflection.Assembly
            </summary>
        </member>
        <member name="F:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.m_modules">
            <summary>
            m_modules[0] is always the manifest module. It's the only module for single-module
            assemblies. For multi-module assemblies m_modules[1..n] contains netmodules.
            Modules have to be of type Module and not MetadataOnlyModule because Module resolver
            could return any Module type.
            </summary>
        </member>
        <member name="F:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.m_manifestModule">
            <summary>
            Same as m_modules[0]. Used to avoid casting in cases when we just need LMR
            specific information about manifest module. Manifest module always has to be
            of ManifestOnlyModule type.
            </summary>
        </member>
        <member name="F:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.m_manifestFile">
            <summary>
            The file containing the manifest information for the assembly.
            </summary>
        </member>
        <member name="F:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.m_name">
            <summary>
            A profile of running Fib(20) using a naive recursive algorithm showed that caching the
            AssemblyName reduced execution speed by 40%.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.String)">
            <summary>
            Creates an instance of a single-module or multi-module assembly.
            </summary>
            <param name="manifestModule">Module containing manifest for an assembly.</param>
            <param name="manifestFile">File containing the manifest information.</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule[],System.String)">
            <summary>
            Creates an instance of a multi-module assembly.
            </summary>
            <param name="modules">Array of modules that form a multi-module assembly. The first one
            must be the manifest module.</param>
            <param name="manifestFile">File containing the manifest information.</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.Dispose">
            <summary>
            This should only be called in the context of disposing the parent Universe.
            Caller is responsible for thread safey here and to not dispose while another thread is using.
            Caller should not use after this has been diposed.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.VerifyModules(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule[])">
            <summary>
            Verifies that modules have these properties:
                1) First module contains manifest.
                2) All other modules (if provided) do not contain manifest.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.GetFileNamesFromFilesTable(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Boolean)">
            <summary>
            Gets list of names of all dependent files from Files table based on manifest module.
            </summary>
            <remarks>
            The CLI spec is not clear on where exactly netmodules should be listed: in ModuleRefs table or in
            Files table, or both. C# compiler lists them in both places. That's what Serge Lidin's book on IL
            Assembler describes as correct. Dynamic modules generated with Reflection.Emit have both of these
            tables empty - until dynamic assembly is persisted to disk, when it becomes single module assembly.
            The only thing stored in a manifest of a dynamic assembly is information about assembly level
            custom attributes.

            ModuleRefs table is hard to use since, in addition to net modules, it lists native DLL dependencies.
            There is no way to distinguish between native and managed binaries. The table only contains names
            like mscoree.dll or moduleA.netmodule. ModuleRefs table doesn't list full closure of dependencies
            either. It only lists direct dependencies. E.g. if manifest module has dependency on module A, and
            module A in turn has dependency on module B, ModuleRefs table will only have module A listed.

            In contrast, Files table lists the full closure of all dependent netmodules, direct and indirect.
            </remarks>
            <param name="manifestModule">Module with manifest that needs to be inspected.</param>
            <param name="getResources">Specifies whether the result includes resource files.</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.GetManifestResourceStream(System.Type,System.String)">
            <summary>
            Gets resource stream for a given resource name using type for namespace name.
            </summary>
            <remarks>We can't currently rely on Reflection to do this part since they
            call their internal API from their overload (instead of calling
            GetManifestResourceStream(string name) overload.</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.GetManifestResourceStream(System.String)">
            <summary>
            Gets resource stream for a given resource name.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.GetTypes">
            <summary>
            Gets all types on the assembly.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.GetModule(System.String)">
            <summary>
            Gets module with the specified name. Returns null if there is no such module.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.GetCodeBaseFromManifestModule(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule)">
            <summary>
            The method returns a string representing the CodeBase property
            of an Assembly or AssemblyName from the manifest module.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly.GetAssemblyToken(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule)">
            <summary>
            Gets the assembly token for a module. If module contains manifest, it returns
            a valid assembly token; otherwise returns Token.Nil.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonArrayType">
            <summary>
            This class defines a common base type for vector types and multi-dimensional array types.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType" -->
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType.Resolver">
            <summary>
            Get the resolver object that the type's TypeDef token is valid in.
            The resolver provides the tie back to LMR and LMR services, such as:
            - the raw metadata import,
            - the creation Factory.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType.GetDeclaredMethods">
            <summary>
            Internal helper for implementing Type.GetMethods().
            This returns *all* the methods declared on the current type including:
            - public, private
            - static, instance
            - fabricated (eg, on Array)
            This does not including any inherited methods.

            Type.GetMethods() is a complicated algorithm that uses this information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType.Equals(System.Object)">
            <remarks>
            We can't rely on System.Type's default implementation since that assume object equality.
            </remarks>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType.ContainsGenericParameters">
            <summary>
            Recursive check if this type has any unresolved generics.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType.IsSubclassOf(System.Type)">
            <summary>
            Determines if this type is a subclass of a given type.
            </summary>
            <remarks>We can't rely on Reflection's implementation of
            this method since it uses reference equality (operator ==).</remarks>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType.ReflectedType">
            <summary>
            LMR types doesn't support ReflectedType.
            ReflectedType is not actually in the metadata. Instead, it tracks which Type this object was obtained from.
            Mostly makes sense for MethodInfos, PropertyInfos, etc.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType.DeclaringMethod">
            <remarks>
            Runtime type throws here for types that are not type variables.
            </remarks>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyConstructorInfo">
            <summary>
            Represent an System.Reflection.ConstructorInfo.

            Reflection requires that constructors derive from ConstructorInfo, not MethodInfo.
            However, Constructors are just methods at the metadata level complete with MethodDef tokens.
            Since we can only have a single base class, this makes it hard to share between Constructors and Methods.

            This class is an adapter that lets LMR represent constructors as MethodInfos underneath
            (which leads to a more natural implementation and significantly better sharing with methods)
            but wraps everything and expose sit as a ConstructorInfo.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyConstructorInfo.#ctor(System.Reflection.MethodBase)">
            <summary>
            Create a ConstructorInfo around the given method base. This is done purely for conformance to
            reflection's object model and does not provide any additional benefit.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCustomAttributeData">
            <summary>
            Represent a custom attribute. ConstructorInfo is eagerly fetched here since that's usually what
            a caller wants when the fetch the custom attributes. The argument blob (for typed and named
            arguments) is lazily fetched. Many code paths will just check the presence of an attribute, and so
            just need the constructor info.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCustomAttributeData.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token,System.Reflection.ConstructorInfo)">
            <summary>
            Constructor used when attribute info is obtained by parsing CA blobs.
            </summary>
            <param name="module">module that the custom attribute token is valid in. This will be the module
            containing the member that the attribute is on. </param>
            <param name="token">custom attribute token.</param>
            <param name="ctor">constructor for attributer. This provides the name of the attribute.</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCustomAttributeData.#ctor(System.Reflection.ConstructorInfo,System.Collections.Generic.IList{System.Reflection.CustomAttributeTypedArgument},System.Collections.Generic.IList{System.Reflection.CustomAttributeNamedArgument})">
            <summary>
            Constructor used for pseudo-custom attributes.
            </summary>
            <param name="ctor">Attribute's constructor.</param>
            <param name="typedArguments">List of attribute's typed arguments. Can't be null.</param>
            <param name="namedArguments">List of attribute's named arguments. Can't be null.</param>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyEventInfo">
            <summary>
            Implement a FieldInfo based off an IMetadataImport.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyEventInfo.InitializeName">
            <summary>
            Lookup event name only when really needed and cache it in this instance.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyFieldInfo">
            <summary>
            Implement a FieldInfo based off an IMetadataImport.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyFieldInfo.InitializeName">
            <summary>
            Gets just field name. If this is never needed we avoid allocating string for it.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyFieldInfo.GetRvaField">
            <summary>
            implementation of IField2
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBody">
            <summary>
            Base implementation for a MethodBody. This provides stub implementations of the methods. It also
            provides a default implementation of the LocalVariables property built on the LocalSignatureMetadataToken property.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBody.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo)">
            <summary>
            constructor
            </summary>
            <param name="method">method that this body corresponds to.</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBody.TryCreate(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo)">
            <summary>
            Helper to create a method body and invoke the reflection factory .
            </summary>
            <param name="method">method to request the body for</param>
            <returns>null if the method does not have an IL body, else the instantiated body.</returns>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBody.Method">
            <summary>
            Method that this body belongs to.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBody.ExceptionHandlingClauses">
            <summary>
            empty implementation from base class
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBody.InitLocals">
            <summary>
            empty implementation from base class
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBody.LocalSignatureMetadataToken">
            <summary>
            empty implementation from base class.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBody.LocalVariables">
            <summary>
            Default implementation built on top of code:LocalSignatureMetadataToken
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBody.MaxStackSize">
            <summary>
            empty implementation from base class.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBody.GetILAsByteArray">
            <summary>
            empty implementation from base class.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker">
            <summary>
            MethodBody implementation that reads data from static metadata.
            This may not work in cases where the metadata is not valid (like dynamic modules or edit-and-continue).
            </summary>
        </member>
        <member name="F:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.m_header">
            <summary>
            unmanaged header from metadata. This may be a tiny or fat header.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo,Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IMethodHeader)">
            <summary>
            Constructor
            </summary>
            <param name="method">method that the body is for</param>
            <param name="header">raw metadata header containing information for body</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.Create(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo)">
            <summary>
            Helper function to create.
            </summary>
            <param name="method">method to create body for</param>
            <returns>null if no method body, else the new method body.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.GetMethodHeader(System.UInt32,Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule)">
            <summary>
            Get the method header from the metadata at the given RVA.
            </summary>
            <param name="rva">rva of method header, from MethodDefProps. </param>
            <param name="scope">scope that the RVA is valid in.</param>
            <returns>a method header</returns>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.MaxStackSize">
            <summary>
            override from base class
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.GetILAsByteArray">
            <summary>
            override from base class
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.InitLocals">
            <summary>
            override from base class
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.LocalSignatureMetadataToken">
            <summary>
            override from base class
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IMethodHeader">
            <summary>
            Base interface to provide uniform access to tiny and fat method headers.
            Since the headers are LayoutKind.Sequential, they can't inherit from a base class, so this must
            be an interface.

            See IIb.24.4 for details on MethodBody layout in the metadata.
            This somewhat corresponds to the IMAGE_COR_ILMETHOD in CorHdr.h.

            A method header is located at the RVA specified in the GetMethodProps(). The method header is
            followed by the IL bytes stream. That's followed by 'extra' sections', which may describe
            exception handling regions.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IMethodHeader.MaxStack">
            <summary>
            maximum il stack depth that this function may use.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IMethodHeader.CodeSize">
            <summary>
            Size of the IL code in bytes
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IMethodHeader.LocalVarSigTok">
            <summary>
            Local signature token. 0 if no locals.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IMethodHeader.Flags">
            <summary>
            Flags for this method
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IMethodHeader.HeaderSizeBytes">
            <summary>
            Size of the method header in bytes.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.MethodHeaderFlags">
            <summary>
            Flags for method headers. See spec IIb.24.4.4
            </summary>
        </member>
        <member name="F:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.MethodHeaderFlags.FatFormat">
            <summary>
            Method header is fat. Use code:FatHeader
            </summary>
        </member>
        <member name="F:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.MethodHeaderFlags.TinyFormat">
            <summary>
            Method header is tiny. Use code:TinyHeader
            </summary>
        </member>
        <member name="F:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.MethodHeaderFlags.MoreSects">
            <summary>
            More sections follow after this header. See IIb.24.4.5.
            </summary>
        </member>
        <member name="F:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.MethodHeaderFlags.InitLocals">
            <summary>
            Call default constructor on all local variables.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.TinyHeader">
            <summary>
            Tiny header layout. spec IIb.24.4.2. This corresponds to IMAGE_COR_ILMETHOD_TINY in CorHdr.h
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.TinyHeader.Flags">
            <summary>
            Implement IMethodHeader
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.TinyHeader.CodeSize">
            <summary>
            Implement IMethodHeader
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.TinyHeader.MaxStack">
            <summary>
            Implement IMethodHeader
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.TinyHeader.LocalVarSigTok">
            <summary>
            Implement IMethodHeader
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.TinyHeader.HeaderSizeBytes">
            <summary>
            Implement IMethodHeader
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.FatHeader">
            <summary>
            Fat header layout. spec IIb.24.4.3. This corresponds to IMAGE_COR_ILMETHOD_FAT in CorHdr.h
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.FatHeader.Flags">
            <summary>
            Implement IMethodHeader
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.FatHeader.MaxStack">
            <summary>
            Implement IMethodHeader
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.FatHeader.CodeSize">
            <summary>
            Implement IMethodHeader
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.FatHeader.LocalVarSigTok">
            <summary>
            Implement IMethodHeader
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.FatHeader.HeaderSizeBytes">
            <summary>
            Implement IMethodHeader
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IEHClause.Flags">
            <summary>
            Flags describing exception clause type (catch-block, filter, finally, or fault)
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IEHClause.TryOffset">
            <summary>
            IL offset in bytes from start of header
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IEHClause.TryLength">
            <summary>
            Length in bytes of the try block
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IEHClause.HandlerOffset">
            <summary>
            IL offset in bytes of the handler for the try block
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IEHClause.HandlerLength">
            <summary>
            length in bytes of the IL code for the handler
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IEHClause.ClassToken">
            <summary>
            metadata Token for a type-based exception handler. This is valid in the scope of the method
            containing the IL code.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.IEHClause.FilterOffset">
            <summary>
            Offset in method body ofr filter-based exception handler.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.EHSmall">
            <summary>
            Raw layout of a small version of an EH Clause.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodBodyWorker.EHFat">
            <summary>
            Raw layout of a fat version of an EH clause.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo">
            <summary>
            Represent a LMR implementation of System.Reflection.MethodInfo.
            This is for MethodInfos backed by real metadata with real a MethodDef token.
            Use a different derived class for fabricated methodInfos.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo.Create(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)">
            <summary>
            Helper method to create a MethodInfo or a Constructor
            </summary>
            <param name="resolver">module resolution scope</param>
            <param name="methodDef">metadata token for methodDef of method body</param>
            <param name="context">generic arguments</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo)">
            <summary>
            Copy constructor for a MethodInfo. This allows a derived class to easily override a MethodInfo
            without having to wrap every property.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token,System.Type[],System.Type[])">
            <summary>
            Internal constructor for creating a MethodInfo. If method is a constructor, it must get wrapped in
            a ConstructorInfo object before being handed out.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo.Initialize">
            <summary>
            Get all the non-core information about the method from metadata. This is relatively expensive
            so we perform it only when needed.
            </summary>
            <remarks>We have to use lock here to avoid race in updating m_tOwner field.</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo.GetOwnerTypeAndTypeArgs(System.Type@,System.Type[]@)">
            <summary>
            Retreives information about containing type and its context from metadata.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo.GetGenericMethodArgs">
            <summary>
            Retreives information about method's generic arguments if there are any.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyMethodInfo.GetParameters">
            <summary>
            Get parameters, not including this arg and get return parameter
            (if it's present).
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule">
            <summary>
            TokenResolver represents a module. Derived classes may:
            - override caching and creation policy. (although this could be deferred to a policy object)
            - associate auxillary data (although they could do this via a Hash; or via a 'object Tag' property)

            Token resolver for scopes within an MDbgModule
            This will create Type, MethodInfo, etc for metadata tokens within the module.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.Policy">
            <summary>
            Get policy object that specifies reflection behavior not directly corresponding to metadata.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.ReadEmbeddedBlob(System.Reflection.Adds.EmbeddedBlobPointer,System.Int32)">
            <summary>
            Helper to read bytes embedded in metadata blob.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.RawMetadata">
            <summary>
            Get the raw low level metadata file.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetThreadSafeImporter">
            <summary>
            CLR v4.0: Gets a raw Importer that's usable by all threads since in v4.0 object that
            implements this interface implements FTM too.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.ResolveTypeTokenInternal(System.Reflection.Adds.Token,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)" -->
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.ResolveTypeTokenInternal(System.Reflection.Adds.Token,System.Reflection.Adds.CorElementType,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)">
            <summary>
            Internal API to resolve tokens and their element type to Type objects.
            This handles TypeDefs, TypeRefs and TypeSpecs.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetGenericType(System.Reflection.Adds.Token,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)" -->
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.ResolveMethodSpec(System.Reflection.Adds.Token,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)">
            <summary>
            Resolves a reference to an instantiated generic method.
            </summary>
            <param name="methodToken">MethodSpec token.</param>
            <param name="context">Generic context containing types used for intantiation.</param>
            <returns>MethodInfo instance containing info about an instantiated generic method.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.ResolveMethodRef(System.Reflection.Adds.Token,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext,System.Type[])">
            <summary>
            Resolves a MethodRef token to a method/constructor.
            </summary>
            <remarks>
            Since ResolveTypeTokenInternal could return a non-LMR type we can't rely on having
            access to its metadata through IMetaDataImport interface. Instead, we have to go through
            public Reflection APIs only. Future optimization: If this approach happens to be too slow,
            we could check its type and go through a fast path is it's a LMR type (or TypeRef around
            LMR type).

            This can be used to get the constructor for a custom-attribute.
            </remarks>
            <param name="memberRef">member ref token to resolve</param>
            <param name="context">generic context of caller. </param>
            <param name="genericMethodParameters">generic parameters to method, or null</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.LookupTypeToken(System.String)">
            <summary>
            Lookup a TypeDef token for a given top-level type name. Does not handle nested classes.
            This is useful for looking up system types (Enum, Int32, etc)</summary>
            <param name="className">top-level type name to lookup</param>
            <returns>typedef token of type. Throws it type not found.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetMethodRva(System.Int32)">
            <summary>
            Get the RVA for the given method token. Return 0 if no RVA.
            In some cases (dynamic modules, edit-and-continue), there may not be a usable RVA.
            </summary>
            <param name="methodDef">method def token to get the RVA for</param>
            <returns>the RVA of the method. </returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetConstructorsOnType(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType,System.Reflection.BindingFlags)">
            <summary>
            Get the constructors that match flags on a given type.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.FilterMethod(System.Reflection.MethodInfo[],System.String,System.Reflection.BindingFlags,System.Reflection.CallingConventions,System.Type[])">
            <summary>
            Find the method matching all the criteria in the method array.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetMethodsOnType(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType,System.Reflection.BindingFlags)">
            <summary>
            Returns the methods (but not constructors) on the given Type and its base types (if requested in the flags).
            </summary>
            <remarks>
            This a helper function shared by multiple MetadataOnlyCommonType derivations to implement:
                MethodInfo[] Type.GetMethods(...)
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.WalkInheritanceChain(System.Reflection.BindingFlags)">
            <summary>
            Determines if walk up the inheritance chain is requested based on flags.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.FilterInheritedProperties(System.Collections.Generic.IList{System.Reflection.PropertyInfo},System.Collections.Generic.IList{System.Reflection.PropertyInfo},System.Reflection.BindingFlags)">
            <summary>
            Filters inherited properties by eliminating overloads.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.FilterInheritedEvents(System.Collections.Generic.IList{System.Reflection.EventInfo},System.Collections.Generic.IList{System.Reflection.EventInfo})">
            <summary>
            Filters inherited events by eliminating overloads. Overload in case of events is
            simply any inherited event that has the same name as an event directly on a type.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.IncludeInheritedMethod(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Reflection.MethodInfo},System.Reflection.BindingFlags)">
            <summary>
            Determines if an inherited method should be included when walking up inheritance chain.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.IncludeInheritedAccessor(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Reflection.MethodInfo},System.Reflection.BindingFlags)">
            <summary>
            Determines if an inherited property getter/setter should be included when walking up inheritance chain.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.IncludeInheritedField(System.Reflection.FieldInfo,System.Reflection.BindingFlags)">
            <summary>
            Determines if an inherited field should be included when walking up inheritance chain.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.EMethodKind">
            <summary>
            Filter to use with code:GetMethodsOnDeclaredTypeOnly
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetMethodBasesOnDeclaredTypeOnly(System.Reflection.Adds.Token,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext,Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.EMethodKind)">
            <summary>
            Common helper function for
              MethodInfo[] Type.GetMethods(...) and
              ConstructorInfo[] Type.GetConstructor().
            Gets just the methods and constructors that this type implements, not the ones it inherits.
            </summary>
            <remarks>
            This is on the TokenResolver so that it can be shared by multiple Type implementations.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.IsOverride(System.Collections.Generic.IEnumerable{System.Reflection.MethodInfo},System.Reflection.MethodInfo)">
             <summary>
            Check if method m overrides any of passed methods.
             </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.IsOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
             <summary>
            Check if two methods override each other.
             </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetFieldsOnType(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType,System.Reflection.BindingFlags)">
            <summary>
            Returns the fields on the given Type and its base types (if requested in the flags).
            </summary>
            <remarks>
            This a helper function shared by multiple MetadataOnlyCommonType derivations to implement:
                FieldInfo[] Type.GetFields(...)
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetFieldsOnDeclaredTypeOnly(System.Reflection.Adds.Token,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)">
            <summary>
            Gets fields on a specified type using IMetadataImport API. Does not get fields
            on base classes.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetPropertiesOnType(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType,System.Reflection.BindingFlags)">
            <summary>
            Returns the properties on the given Type and its base types (if requested in the flags).
            </summary>
            <remarks>
            This a helper function shared by multiple MetadataOnlyCommonType derivations to implement:
                MethodInfo[] Type.GetProperties(...)
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetPropertiesOnDeclaredTypeOnly(System.Reflection.Adds.Token,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)">
            <summary>
            Common helper function for
              PropertyInfo[] Type.GetProperties(...)
            Gets just properties that this type implements, not the ones it inherits.
            </summary>
            <remarks>
            This is on the TokenResolver so that it can be shared by multiple Type implementations.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetEventsOnType(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType,System.Reflection.BindingFlags)">
            <summary>
            Returns the events on the given Type and its base types (if requested in the flags).
            </summary>
            <remarks>
            This a helper function shared by multiple MetadataOnlyCommonType derivations to implement:
                MethodInfo[] Type.GetEvents(...)
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetEventsOnDeclaredTypeOnly(System.Reflection.Adds.Token,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)">
            <summary>
            Common helper function for
              PropertyInfo[] Type.GetEvents(...)
            Gets just events that this type implements, not the ones it inherits.
            </summary>
            <remarks>
            This is on the TokenResolver so that it can be shared by multiple Type implementations.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetCustomAttributeData(System.Int32)">
            <summary>
            Gets all custom attributes on a member.
            </summary>
            <param name="memberTokenValue">Member's metadata token.</param>
            <returns>List of CustomAttributeData instances describing all custom attributes.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.ResolveCustomAttributeConstructor(System.Reflection.Adds.Token)">
             <summary>
             Return a ConstructorInfo proxy for the ctor token which can be used in a Custom Attribute information.
             This proxy just supports getting the custom attribute name without resolving (eg, calling ctor.DeclaringType.FullName.)
             </summary>
             <param name="customAttributeConstructorTokenValue">token from custom attr  representing the contstructor. </param>
             <returns></returns>
             <remarks>
             Reflection API has Custom Attributes expose the constructor Info, but what clients really want
             is a fast way to get to the string name without resolution.

             We want to do lazy resolution here:
             - performance: faster filtering of custom attributes. Clients just need the string name and
                not the fully resolved constructor Info (which would require resolving all the type parameters
                too).
             - avoid eager assembly resolution. CustomAttr args require assembly resolution, but not
                if we're just getting the attribute name,
             </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.LazyAttributeParse(System.Reflection.Adds.Token,System.Reflection.ConstructorInfo,System.Collections.Generic.IList{System.Reflection.CustomAttributeTypedArgument}@,System.Collections.Generic.IList{System.Reflection.CustomAttributeNamedArgument}@)">
            <summary>
            Parses the custom attribute blob and returns list of constructor arguments and
            list of named arguments. This allows lazily parsing the attribute blob.
            </summary>
            <param name="token">metadata token for the attribute instance. This can be used to lookup the
            attribute's parameter blob.</param>
            <param name="constructorInfo"> constructor for the attribute. </param>
            <param name="constructorArguments"> out parameter set to non-null (potentially 0-length)  list of constructor arguments. </param>
            <param name="namedArguments">out parameter set to non-null (potentially 0-length) list of named arguments. </param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetConstructorArguments(System.Reflection.ConstructorInfo,System.Byte[],System.Int32@)">
            <summary>
            Parses the custom attribute blob and returns list of constructor arguments. Assumes that prolog is
            already verified and skipped.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetNamedArguments(System.Reflection.ConstructorInfo,System.Byte[],System.Int32@)">
            <summary>
            Parses the custom attribute blob and returns list of named arguments. Assumes that typed
            arguments are already parsed.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetCustomAttributeArgumentValue(System.Reflection.Adds.CorElementType,System.Type,System.Byte[],System.Int32@)">
            <summary>
            Gets custom attribute argument's value from the blob.
            </summary>
            <param name="typeId">Value's type ID.</param>
            <param name="type">Value's type. Only needed for values that are arrays. Ignored for other values.</param>
            <param name="customAttributeBlob">Blob that contains custom attribute encoding.</param>
            <param name="index">Current index into the blob.</param>
            <returns>Custom attributes argument's value.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetUnderlyingType(System.Type)">
            <summary>
            Finds the underlying type of an enum type.
            </summary>
            <remarks>We might need to expose this on our own Enum derivation if it turns out that our types
            can't be passed to System.Enum.GetUnderlyingType.</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetAssemblyNameFromAssemblyRef(System.Reflection.Adds.Token)">
            <summary>
            Gets the Assembly Name for the given assembly ref token.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.GetGenericParameterTokens(System.Int32)">
            <summary>
            Get the tokens of the generic parameters in the type or method.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.CheckIsStaticAndIsPublicOnProperty(System.Reflection.PropertyInfo,System.Boolean@,System.Boolean@)">
            <summary>
            Checks if property is static and/or public.
            Property is static if one of its set/get accessors is static.
            Property is public if one of its set/get accessors is public.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.CheckIsStaticAndIsPublicOnEvent(System.Reflection.EventInfo,System.Boolean@,System.Boolean@)">
            <summary>
            Checks if event is static and/or public.
            Event is static if one of its add/remove/raise accessors is static.
            Event is public if one of its add/remove/raise accessors is public.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.CheckIsStaticAndIsPublic(System.Reflection.MethodInfo,System.Boolean@,System.Boolean@)">
            <summary>
            Check if a Method is static or public. Used for properties and events. They are considered static/public
            if any of accessor methods are static/public.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.IsSystemModule">
            <summary>
            Determine if this module is the symbol module, as decided by the TypeUniverse.
            </summary>
            <returns>Return true iff this is the system module (mscorlib). </returns>
            <remarks>This is needed if the caller wants to compare cached token or name values for
            builtin types.</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.IsWindowsRuntime(System.Reflection.Module)">
            <summary>
            Determine if the module is a windows runtime metadata module
            </summary>
            <param name="module">The module to determine if it is a windows runtime metadata module</param>
            <returns>True if the module is a windows runtime metadata module</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.CreateTypeCodeMapping">
            <summary>
            Return a mapping for code:m_typeCodeMapping. See that field for exact semantics of this array.
            This must be called from the assembly's module.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.Dispose">
            <summary>
            Dispose this module. This should be called in the context of disposing the parent assembly.
            This will release the unmanaged metadata pointers this module owns.
            Caller is responsible for thread safey here and to not dispose while another thread is using.
            Caller should not use after this has been diposed.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule.RowCount(System.Reflection.Adds.MetadataTable)">
            <summary>
            Gets number of rows in a metadata table.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyParameterInfo.GetMarshalInfo">
            <summary>
            New API to get at any marshaling information on this parameter
            </summary>
            <remarks>
            Note that LMR doesn't expose most pseudo-custom attributes as attributes like reflection does.
            We could do that instead but it would be slower (need to synthesize a ConstructorInfo, etc.),
            and this is easier to use anyway.
            </remarks>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyPropertyInfo">
            <summary>
            Implement a PropertyInfo based off an IMetadataImport.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef">
            <summary>
            Represent a TypeDef token. It can contain generic arguments: opened, closed or partialy closed.
            See http://msdn.microsoft.com/en-us/library/system.type.isgenerictype.aspx for a list of key invariants
            of generic-related properties on System.Type.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token,System.Type[])">
            <summary>
            Creates LMR representation for TypeDef token.
            </summary>
            <param name="scope">Module in which TypeDef token is defined.</param>
            <param name="tokenTypeDef">TypeDef token representing a type.</param>
            <param name="typeParameters">Generic type arguments, if this is generic type.</param>
            <remarks>
            If this type represents generic type instantiation, here is how it's represented in metadata.
            From the Ecma spec:
             TypeSpecBlob ::=
               GENERICINST (CLASS | VALUETYPE) TypeDefOrRefEncoded GenArgCount Type Type*
            TypeDefOrRefEncoded can be a TypeRef,Def or Spec token. (And spec can be anything, like an Array)
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.FullName" -->
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.GetSimpleName(System.Text.StringBuilder)">
            <summary>
            Constructs simple portion of type's complete name i.e. it does not
            include generic argument list (if there is any).
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.Namespace">
            <summary>
            Gets namespace for this type.
            </summary>
            <remarks>
            E.g. fullName = System.Reflection.MethodInfo
                namespace = System.Reflection
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.ToString">
            <summary>
            Constructs string representation for this type.
            </summary>
            <remarks>
            ToString is different than FullName when there are generic parameters.
            </remarks>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.BaseType">
            <summary>
            Get the base type that this derives from.
            Null if the curernt type is System.Object.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.Equals(System.Type)">
            <summary>
            Determines if two types are the same.
            </summary>
            <remarks>
            EqualsImpl should not call FullName since that could create infinite recursion for generic
            types. FullName needs to call IsGenericTypeDefinition, which in turn needs to call EqualsImpl.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.MakeGenericType(System.Type[])">
            <summary>
            Creates generic type from generic type definition.
            </summary>
            <remarks>
            See http://msdn.microsoft.com/en-us/library/system.type.makegenerictype.aspx for details on invariants here.
            </remarks>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.IsGenericType">
            <summary>
            Determines if this is a generic type based on number of type arguments.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.GetGenericArguments">
            <summary>
            Creates type array of generic arguments. Returns empty array if this
            is not generic type.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.GetGenericTypeDefinition">
            <summary>
            Gets generic type definition (aka template) if this is generic type.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.IsGenericTypeDefinition">
            <summary>
            Determines if this is a generic type definition i.e. fully open generic type.
            </summary>
            <remarks>
            Important: this method should not be directly or indirectly called from EqualsImpl
            since it would cause infinite reqursion. E.g. that's why EqualsImpl does not call
            FullName or ToString(); both of these APIs call IsGenericTypeDefinition.
            </remarks>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeDef.InterfaceImpl">
            <summary>
            Represents an interface implemented directly by another type
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeVariable">
            <summary>
            Represents an uninstantiated type variable.  For now, most method are unimplemented.
            The defining property of this is that IsGenericParameter returns true; whereas most other Type
            implementations return false.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeVariableRef">
            <summary>
            Represents a type variable extracted from memberRef signature.
            It is only used for signature matching.
            </summary>
            <remarks>
            This class is used internally only and it should not be exposed
            publicly even when all LMR APIs become public. That's why most
            methods throw exceptions.
            </remarks>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyVectorType">
            <summary>
            This class represents vector types.
            The CLR makes a distinction between vectors (that is, one-dimensional
            arrays that are always zero-based) and multidimensional arrays.
            A vector, which always has only one dimension, is not the same
            as a multidimensional array that happens to have only one dimension.
            You cannot use this method overload to create a vector type; if rank
            is 1, this method overload returns a multidimensional array type that
            happens to have one dimension.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.OpenGenericContext">
            <summary>
            Represents generic context used for signature blob parsing when we have MemberRef.
            Lets us create method's template that we can use for comparison with all the methods
            on a target class.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.OpenGenericContext.#ctor(System.Type[],System.Type[])">
            <summary>
            Initializes both type arguments and method arguments.
            Used when we already know number of method arguments i.e.
            after verification.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.OpenGenericContext.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Type,System.Reflection.Adds.Token)">
            <summary>
            Only initializes type arguments (if there are any). Method arguments are initialized
            later, once we have information for signature blob.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.OpenGenericContext.VerifyAndUpdateMethodArguments(System.Int32)">
            <summary>
            Called once we know generic method's arity to initialize metod arguments.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.ProxyGenericType">
            <summary>
            Type proxy for generic instantiation around another type-proxy.
            This can be used to build up type algebra trees without resolution.
            This is similar to ModifierType and ArrayType.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes">
            <summary>
            Utility class that parses metadata for information about pseudo-custom attributes.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes.GetTypeForwardedToAttributes(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly)">
            <summary>
            Get the TypeForwardedToAttributes on an assembly.
            </summary>
            <param name="assembly">assembly to look for attributes on.</param>
            <returns>List of CustomAttributeData instances describing TypeForwardedToAttributes if present.
            Empty list if TypeForwardedToAttribute is not present.</returns>
            <remarks>
            TypeForwardedTo attributes only occur on the assembly. So this overload is useful when we're explicitly operating with the assembly and
            looking for these attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes.GetTypeForwardedToAttributes(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token)">
            <summary>
            Finds info about TypeForwardedToAttributes if present.
            </summary>
            <param name="module">Module in which a given token is valid.</param>
            <param name="token">Token representing object that's target of attributes. Must be a mtAssembly</param>
            <returns>List of CustomAttributeData instances describing TypeForwardedToAttributes if present.
            Empty list if TypeForwardedToAttribute is not present.</returns>
            <remarks>This calls the Type Name Parser which will force assembly resolution because it will force loading the forwarded type to store it as a System.Type arg
            in the custom attribute data</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes.GetRawTypeForwardedToAttributes(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly)">
            <summary>
            Convenience overload for assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes.GetRawTypeForwardedToAttributes(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule)">
            <summary>
            Enumerate type forwarders. This provides the raw metadata and explicitly avoids doing any resolution.
            Returns UnresolvedTypeNames instead of Type to avoid doing an eager resolution.
            </summary>
            <param name="manifestModule">the manifest module to search. TypeForward data is only on a manifest module</param>
            <returns>enumerate of TypeForward data in the module.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes.GetRawTypeForwardedToAttribute(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyAssembly,System.String,System.Boolean)">
            <summary>
            Convenience overload for assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes.GetRawTypeForwardedToAttribute(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.String,System.Boolean)">
            <summary>
            Enumerate type forwarders and finds one that matches given full name.
            Returns UnresolvedTypeNames instead of Type to avoid doing an eager resolution.
            </summary>
            <param name="manifestModule">The module to search in.</param>
            <param name="fullname">Type's full name.</param>
            <param name="ignoreCase">If true, the fullname comparison will be not be case sensitive.</param>
            <returns>An unresolved type retrieved from type forwarded attributes or null if type with given name
            cannot be found.</returns>
            <remarks>
            Having this version of API saves us from converting StringBuilder content to string when we are only looking
            for one specific forwarder.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes.GetTypeFromTypeForwardToAttribute(System.Reflection.CustomAttributeData)">
            <summary>
            Given the representation of a TypeForwarededToAttribute, get the Type parameter from it.
            </summary>
            <param name="data">a custom attribute representation for a TypeForwardedAttribute</param>
            <returns>the System.Type parameter stored in the attribute. This encapsulates where the type is forwarded to.</returns>
            <remarks>
            This is the inverse on GetTypeForwardedToAttributes.
            Given an attribute of: [assembly: TypeForwardedTo(typeof(Widget))]
            This returns Typeof(Widget).
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes.GetSerializableAttribute(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token)">
            <summary>
            Finds info about SerializableAttribute if present on a type.
            </summary>
            <param name="module">Module in which a given token is valid.</param>
            <param name="token">Token representing object that's target of attribute.</param>
            <returns>CustomAttributeData instance describing SerializableAttribute if present.
            Null otherwise.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.PseudoCustomAttributes.GetSerializableAttribute(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Boolean)">
            <summary>
            Creates attribute data for SerializableAttribute.
            </summary>
            <param name="module">Module to be used to get appropriate type universe and system assembly.</param>
            <param name="isRequired">If true, SerializableAttribute must be present in the system assembly (mscorlib).
            If false, returns null if SerializableAttribute cannot be found. E.g. Silverlight mscorlib does not
            contain this attribute.</param>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodFilter">
            <summary>
            Describes criteria used to filter methods.
            This filter will find methods that have right "shape" i.e. that share same:
                a) name
                b) generic or not; if generic share the same number of generic arguments
                c) number of parameters
                d) calling convention
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodFilter.Name">
            <summary>
            Name of a method
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodFilter.GenericParameterCount">
            <summary>
            Number of generic parameters that method has.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodFilter.ParameterCount">
            <summary>
            Number of arguments that method has.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodFilter.CallingConvention">
            <summary>
            Calling convention that method uses.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureComparer">
            <summary>
            Compares method signatures (calling convention, parameter types, etc) to find matches.
            </summary>
            <remarks>Comparing signatures is safer and more flexible than converting signature blobs,
            which requires complete knowledge of signature blob structure, including all corner cases
            and accross all metadata versions.</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureComparer.FilterMethods(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodFilter,System.Reflection.MethodInfo[])">
            <summary>
            Filters methods based on passed filter.
            </summary>
            <returns>Subset of methods that have requested "shape".</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureComparer.FilterConstructors(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodFilter,System.Reflection.ConstructorInfo[])">
            <summary>
            Filters constructors based on passed filter.
            </summary>
            <returns>Subset of constructors that have requested "shape".</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureComparer.IsParametersTypeMatch(System.Reflection.MethodBase,Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeSignatureDescriptor[])">
            <summary>
            Determines if method's parameters match corresponding parameter descriptors.
            </summary>
            <remarks>
            Method parameters come from open version of declaring type since that's what's described
            in a signature blob. For non-generic types, this is just direct list of method's parameters.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureComparer.FindMatchingMethod(System.String,System.Type,Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodSignatureDescriptor,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)" -->
        <!-- Badly formed XML comment ignored for member "M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureComparer.GetTemplateMethod(System.Type,System.Int32)" -->
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.NamedArgumentType">
            <summary>
            Custom attribute named argument identificators.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeSignatureDescriptor">
            <summary>
            Encapsulates information about types as encoded in signature blobs.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeSignatureDescriptor.Type">
            <summary>
            Final type encoded in sig blob. For generic types, this could be type after instantiation.
            E.g T is instantiated with int.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeSignatureDescriptor.CustomModifiers">
            <summary>
            Custom modifiers for this parameter, if any are present.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeSignatureDescriptor.IsPinned">
            <summary>
            Determines if parameter was pinned or not.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodSignatureDescriptor">
            <summary>
            Encapsulates information encoded in method signature blobs.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodSignatureDescriptor.CallingConvention">
            <summary>
            Method's calling convention.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodSignatureDescriptor.GenericParameterCount">
            <summary>
            Number of generic method arguments if this is a generic method.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodSignatureDescriptor.ReturnParameter">
            <summary>
            Descriptor of return parameter.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MethodSignatureDescriptor.Parameters">
            <summary>
            Descriptors of all parameters.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.ExtractCustomModifiers(System.Byte[],System.Int32@,Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)">
            <summary>
            Extract optional and required custom modifiers from the signature blob.
            An optional modifier is a type following CorElementType.CModOpt.
            An required modifier is a type following CorElementType.CModReqd.
            </summary>
            <returns>
            return null if there is no custom modifiers.
            </returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.ExtractType(System.Byte[],System.Int32@,Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext,System.Boolean)">
            <summary>
            Extracts type from method signature + any additional information encoded.
            </summary>
            <param name="sig">Signature blob.</param>
            <param name="index">Current index into signature blob; updated as type is extracted</param>
            <param name="resolver">Module in which this signature is valid.</param>
            <param name="context">Generic context that should be used when type variables need to be instantiated.</param>
            <param name="fAllowPinned">Determines if pinned types are allowed.</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.ExtractCustomAttributeArgumentType(System.Reflection.Adds.ITypeUniverse,System.Reflection.Module,System.Byte[],System.Int32@,System.Reflection.Adds.CorElementType@,System.Type@)">
            <summary>
            Constructs type of a custom attribute argument (typed or named) based on its
            type ID extracted from the custom attribute blob.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.ExtractInt(System.Byte[],System.Int32@)" -->
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.GetTypeId(System.Type)">
            <summary>
            Maps Type to its CorElementType value for Types valid in custom attribute signatures.
            This throws if the type is not a primitive type definde in the system assembly, an enum, or array.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.ExtractStringValue(System.Byte[],System.Int32@)">
            <summary>
            Extracts a string value from the blob array.
            </summary>
            <remarks>This is just a convenience method to make dealing with strings easier.</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.ExtractUIntValue(System.Byte[],System.Int32@)">
            <summary>
            Extracts an unsigned int value from the blob array.
            </summary>
            <remarks>This is just a convenience method to make dealing with uints easier.</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.ExtractTypeValue(System.Reflection.Adds.ITypeUniverse,System.Reflection.Module,System.Byte[],System.Int32@)">
            <summary>
            Extracts full name of a type from custom attribute blob and uses that name to
            construct appropriate type object instance.
            </summary>
            <param name="universe">Universe that type resolution should happen in.</param>
            <param name="module">Module that contains this custom attribute blob.</param>
            <param name="blob">Custom attribute blob that's being parsed.</param>
            <param name="index">Current index inside the blob. Updated as type name is extracted.</param>
            <returns>Appropriate type instance or null if type name is null.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.ExtractValue(System.Reflection.Adds.CorElementType,System.Byte[],System.Int32@)">
            <summary>
            Extracts value at a given index from blob using passed type ID.
            </summary>
            <remarks>Implementation depends on BitConverter class. This is important from
            little/big-endian perspective since custom attribute signatures are encoded in
            little-endian format. This is ok on Windows but might not be ok on Mac for example.</remarks>
            <param name="typeId">Type ID of value that needs to be extracted.</param>
            <param name="blob">Byte array containing value.</param>
            <param name="index">Offset from which to start extracting value.</param>
            <returns>Value extracted from byte array.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.ExtractListOfValues(System.Type,System.Reflection.Adds.ITypeUniverse,System.Reflection.Module,System.UInt32,System.Byte[],System.Int32@)">
            <summary>
            Creates a ready-only list of typed arguments populated by values extracted from byte array.
            </summary>
            <remarks>Reflection wraps each array element into CustomAttributeTypedArgument even when
            custom attribute's constructor parameter is stronly typed array like int[]. That's why we don't
            create int[] but list of wrapped integers.</remarks>
            <param name="elementType">Type of list elements.</param>
            <param name="universe">Universe in which type resolution should happen.</param>
            <param name="module">Module that contains custom attribute blob.</param>
            <param name="size">Size of list - previously extracted from the same custom attribute blob.</param>
            <param name="blob">Custom attribute blob.</param>
            <param name="index">Current index into custom attribute blob. Will be updated to new position
            as list elements are parsed.</param>
            <returns>Read only list of CustomAttributeTypedArguments that describe each element in the list.
            This matches what Reflection constructs and returns.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.IsValidCustomAttributeElementType(System.Reflection.Adds.CorElementType)">
            <summary>
            Detemines if a given element type can be a custom attribute argument.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.VerifyElementType(System.Reflection.Adds.CorElementType)">
            <summary>
            Verifies that element type read from a custom attribute blob is
            one of allowed types.
            </summary>
            <remarks>These values come straight from metadata so we have to
            make sure they make sense before interpreting them.</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.ExtractNamedArgumentType(System.Byte[],System.Int32@)">
            <summary>
            Determines if named argument represents field or property.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.ExtractMethodSignature(Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureBlob,Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,Microsoft.UI.Xaml.Markup.Compiler.Lmr.GenericContext)">
            <summary>
            Extracts information about a method from its signature blob.
            </summary>
            <param name="methodSignatureBlob">Encoded method signature.</param>
            <param name="resolver">Module in which signature blob is valid.</param>
            <param name="context">Generic context that should be used when type variables need to be instantiated.</param>
            <returns>Method signature description.</returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.GetReflectionCallingConvention(Microsoft.UI.Xaml.Markup.Compiler.Lmr.CorCallingConvention)">
            <summary>
            Gets Reflection calling convention coresponding to passed CorCallingConvention.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.IsCallingConventionMatch(System.Reflection.MethodBase,System.Reflection.CallingConventions)">
            <summary>
            Determines if method's calling convention matches passed calling convention.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.IsGenericParametersCountMatch(System.Reflection.MethodInfo,System.Int32)">
            <summary>
            Checks if method has expected number of generic parameters.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.IsParametersTypeMatch(System.Reflection.MethodBase,System.Type[])">
            <summary>
            Determines if method's parameter types match the passed type array.
            The types need to be exactly the same.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.GetStringComparison(System.Reflection.BindingFlags)">
            <summary>
            Determines which string comparison should be used based on
            binding flags passed in. It could be either case sensitive or
            case insensitive.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.TypeMapForAttributes.IsValidCustomAttributeElementType(System.Reflection.Adds.CorElementType)">
            <summary>
            Detemines if a given element type can be a custom attribute argument.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureUtil.TypeMapForAttributes.LookupPrimitive(System.Type,System.Reflection.Adds.CorElementType@)">
            <summary>
            lookup the given primitive type
            </summary>
            <param name="type">type to lookup. Must be a primitive</param>
            <param name="result">the corelement type for the name</param>
            <returns>true if result is valid</returns>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureBlob">
            <summary>
            Represent a raw signature blob from the Metadata.
            Run this through a signature parser to get a friendly form.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureBlob.#ctor(System.Byte[])">
            <summary>
            create a signature blob around a set of bytes.
            </summary>
            <param name="data">raw bytes in the signature</param>
            <remarks>This just provides the semantics that the given byte[] is a metadata signature.</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureBlob.ReadSignature(System.Reflection.Adds.MetadataFile,System.Reflection.Adds.EmbeddedBlobPointer,System.Int32)">
            <summary>
            Read a signature blob from metadata storage.
            </summary>
            <param name="storage">the raw metadata storage that provides the backing unmanaged memory</param>
            <param name="pointer">a pointer into the raw metadata storage</param>
            <param name="countBytes">number of bytes to read</param>
            <returns>signature copied from the storage</returns>
            <remarks>This is conceptually just a ReadMemory() at the pointer's address. We pass in the underlying
            storage object so that we can validate that the unmanaged memory address is actually valid.</remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SignatureBlob.GetSignatureAsByteArray">
            <summary>
            Get the signature as a byte-array. Caller should not mutate the bytes; although we don't enforce
            this for efficiency.
            </summary>
            <returns>A byte array of the signature.</returns>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.SimpleParameterInfo">
            <summary>
            A ParameterInfo constructed purely from information in the method signature without any other
            backing metadata. Contrast to code:MetadataOnlyParameterInfo, which is backed by real metadata.
            The CLR just needs the method signature and doesn't actually need parameter metadata. Compilers may
            emit parameter metadata at their discretion. One case where the C# compiler omits the metadata is
            for anonymous delegates whose body does not use any parameters.

            Properties not passed to the constructor return values to match reflection's existing
            implementation. Reflection's choice here is arguably an arbitrary policy decision, which is why
            these ParameterInfos are routed through code:IMetadataExtensionsPolicy.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.StringBuilderPool">
            <summary>
            This is a very simple pool with a fixed size (MaxListSize). Additional allocations are allowed to GC.
            Exposes two static methods, Get and Release which are threadsafe and protected via a synclock.
            </summary>
            <remarks>
            Used to decrease GC pressure and avoid lots of small allocation for each interop call.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.StringBuilderPool.Get">
            <summary>
            Returns a stringbuilder from the pool or creates a new one with the default capacity.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.StringBuilderPool.Get(System.Int32)">
            <summary>
            Returns a stringbuilder from the pool or creates a new one, ensuring the capacity is at least "capacity".
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.StringBuilderPool.Release(System.Text.StringBuilder@)">
            <summary>
            Releases the stringbuilder back into the pool.
            The parameter is passed by reference and set to null so that no further access to it is done.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeNameQuoter">
            <summary>
            The class is used to quote type names (including the namespace name).
            The type names in the metadata are all unquoted but reflection returns the quoted name.
            For example, if a type name is "[Foo]", reflection returns "\[Foo\]" for the Name property of the type.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeProxy">
            <summary>
            Base class helper for implementing a LMR Type that proxies to another type (such as a TypeRef or TypeSpec)
            </summary>
            <remarks>
            Explicitly have a DebuggerDisplay here to avoid
            1) inheriting from debug display of MetadataOnlyCommonType for calling Name and FullName,
            2) the debugger implicitly calling ToString() here,
            which could throw exceptions when the type resolution fails.
            This derives from MetadataOnlyCommonType instead of System.Type directly because we can only have 1 base class,
            and derived classes need to derive from CommonType.

            Important: TypeProxy must overload and forward all virtual methods from System.Type instead of providing its
            own implementation - even when this implementation is correct for all LMR types. This is because proxy could
            resolve to non-LMR representation of Type and they might have their own implementation to which we should
            forward to.
            </remarks>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeProxy.Resolver">
             <summary>
            Implements MetadataOnlyCommonType.Resolver
            Unlike Type.DeclaringScope, this specifically returns a LMR module, not just a Reflection module.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeProxy.GetResolvedType">
            <summary>
            Implementation of ITypeProxy.GetResolvedType().
            Get the resolved type that we proxy to.
            Every other method then forwards to this type.
            </summary>
            <remarks>
            Resolution is bad when it requires external information which we may not have or which may be
            very difficult to get. This is the case for TypeRefs.
            It's not as bad for type aliasing, such as with TypeSpecs.

            Note: this can still return a proxy i.e. not resolve completely.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeProxy.ToString">
            <summary>
            We need to forward ToString() calls for correctness, but that means we have a non-trivial ToString()
            impl that may invoke assembly resolution callbacks. Therefore we don't want the debugger to call
            it implicitly via func-evals. So Use a DebuggerDisplay() attribute on this class to mitigate.
            This isn't bullet proof since any other implicit eval could potentially call this ToString().
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeProxy.FullName">
            <summary>
            Helpers to get various pieces of the name.
            Derived class may be able to use their extra knowledge to avoid resolution here.
            Typenames can get complicated (especially with generics, especated chars), so it's hard
            to correctly compute the namespace,name from the FullName.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeProxy.GetHashCode">
            <summary>
            TypeRef's values for those must match that of the proxy.
            (eg this.GetHashCode() == this.GetResolvedType().GetHashCode()).
            Since the resolved type does not need to be a MetadataOnlyCommonType, TypeRef can't just inherits
            MetadataOnlyCommonType's impls of GetHashCode().
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeReference">
            <summary>
            TypeReference (TypeRef token).
            This implements the TypeReference interface to allow getting TypeRef specific data.
            It also implements the regular Type interface, and then forwards on that to the resolved type.
            The base implementations will call these derived properties which will resolve the proxy.
            See code:Ilrun.ITypeReference for more details on the contract.
            </summary>
            <remarks>
            MetadataOnlyTypeReference does not inherit DebuggerDisplayAttribute from TypeProxy. Instead,
            it contains Name and FullName, the same as MetadataOnlyCommonType. This is safe since Name and FullName
            are always available for MetadataOnlyTypeReference. Also, the token of the typeref is included.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeReference.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token)">
            <summary>
            Encapsulate a type reference from a metadata scope.
            </summary>
            <param name="resolver">metadata scope that the typeref is in (this is likely not the
            scope that the type will actually resolve to.</param>
            <param name="typeRef">typeref token for the typeref.</param>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyTypeReference.RequestedAssemblyName">
            <summary>
            Get the asssembly name that this TypeRef requests to be resolved to. This is a higher level view
            over the ResolutionScope token.
            A sane universe should resolve an assembly to the requested name or fail. However, if the universe
            does resolve the assembly to something else, then the actual assembly name may not match the requested
            assembly name.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlySignatureTypeReference">
            <summary>
            SignatureTypeReference (TypeRef token that occurs in a signature).
            This is a special case of TypeReference in which we know the CorElementType under which it
            was used.
            </summary>
            <remarks>
            This is useful to satisfy some requests without resolving the type
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlySignatureTypeReference.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token,System.Reflection.Adds.CorElementType)">
            <summary>
            Encapsulate a type reference from a metadata scope.
            </summary>
            <param name="resolver">metadata scope that the typeref is in (this is likely not the
            scope that the type will actually resolve to.</param>
            <param name="typeRef">typeref token for the typeref.</param>
            <param name="elemType">element type in which TypeRef occured under</param>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.UnresolvedTypeName">
            <summary>
            Represents raw data from the metadata, prior to being converted into the reflection object model.
            This class is useful for representing typerefs that are encoded as strings names, such as how TypeRefs
            are stored in custom attributes.

            This is semantically equivalent to a TypeRef, but this form gaurantees we don't do any eager resolution.

            Once LMR is fully fixed to avoid eager resolution, then this class can safely be replaced with usages
            of Type.
            This is converted to a System.Type by parsing it.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.UnresolvedTypeName.#ctor(System.String,System.Reflection.AssemblyName)">
            <summary>
            Constructor
            </summary>
            <param name="typeName">The full type name, which will eventually be parsed.</param>
            <param name="assemblyName">the assembly that the type will be resolved to.</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.UnresolvedTypeName.ConvertToType(System.Reflection.Adds.ITypeUniverse,System.Reflection.Module)">
            <summary>
            Parse the name to convert to a reflection System.Type.
            </summary>
            <param name="universe">type universe that resulting type will be valid in.</param>
            <param name="moduleContext">module that the typeName was obtained from. This is passed to the parser
            and may be required to disambiguate the type name. See type name parser for details.</param>
            <returns>a System.Type for the given type.</returns>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.Lmr.UnresolvedTypeName.TypeName">
            <summary>
            Get the full type name, excluding assembly
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeSpec">
            <summary>
            Represent a type object around a TypeSpec token.
            A TypeSpec could become any other type, including a TypeDef, TypeRef, Generic instantation, array, modifier, etc.
            TypeSpecs become very common when dealing with generics.
            </summary>
            Explicitly have a DebuggerDisplay here to display the typespec token and not inherit the debugger display from
            TypeProxy. ToString(), Name and FullName cannot be used in the debugger display since they may cause exceptions when
            the type resolution fails.
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.TypeSpec.#ctor(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyModule,System.Reflection.Adds.Token,System.Type[],System.Type[])">
            <summary>
            Represent a type spec
            </summary>
            <param name="module">module scope that the token is valid in. </param>
            <param name="typeSpecToken">a typespec token in that scope</param>
            <param name="typeArgs">the generic type args for resolving vars</param>
            <param name="methodArgs">the generic method args for resolving mvars.</param>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Utility">
            <summary>
            Provide utility functionality to LMR consumers.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Utility.Compare(System.String,System.String,System.Boolean)">
            <summary>
            Do a string comparison, respecting case sensitivity flag.
            </summary>
            <param name="string1">first string</param>
            <param name="string2">second string</param>
            <param name="ignoreCase">true if strings should be compares case insensitive; else false to compare case sensitive</param>
            <returns>true if strings are equal, else false</returns>
            <remarks>
            Many of the name lookup functions take a boolean ignoreCase flag. This helper provides a convenient signature that matches up
            with the reflection conventions.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Utility.IsBindingFlagsMatching(System.Reflection.MemberInfo,System.Boolean,System.Boolean,System.Boolean,System.Reflection.BindingFlags)">
            <summary>
            Helper to filter our a MemberInfo against BindingFlags.
            </summary>
            <param name="memberInfo">member to check against binding flags.</param>
            <param name="isStatic">true iff the member is static.</param>
            <param name="isPublic">true iff the member is public. </param>
            <param name="isInherited">true if filtering will allow inherited members. </param>
            <param name="bindingFlags">binding flags to match against the member</param>
            <returns>true if the members static,public,inherited values match that of the binding flags.</returns>
            <remarks>Public and Static can be fetched directly from certain derived members, like FieldInfo. But not other members, like PropertyInfo. </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Utility.GetNamespaceHelper(System.String)">
            <summary>
            Extracts namespace portion of type's name. Assumes that fullName
            parameter doesn't contain any generic arguments listed.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Utility.GetTypeNameFromFullNameHelper(System.String,System.Boolean)">
            <summary>
            Gets the type name from its full name.
            </summary>
            <param name="fullname">Type's full name. Can't have any generic arguments listed.</param>
            <param name="isNested">Is type nested or not.</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Utility.VerifyNotByRef(Microsoft.UI.Xaml.Markup.Compiler.Lmr.MetadataOnlyCommonType)">
            <summary>
            Verifies that type is not one of ByRef types. If it is, it throws TypeLoadException.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.Lmr.Utility.IsValidPath(System.String)">
            <summary>
            Checks path to a module.
            </summary>
            <remarks>
            We use this instead of File.Exists for these reasons:

            1)	File.Exists throws first-chance exceptions if the path isn’t valid.
                It catches them internally, which makes debugging more difficult.
            2)	File.Exist() is not correct because, as long as the path is valid, we still want to
                call the Uri constructor, even if the path doesn’t exist on the local machine.
                For example, if VS interpreter us used for minidump debugging, the code base will
                be the path on the machine the dump was collected on, which might not exist on
                the machine that is being used to examine the dump.
            3)	We want to disallow cases where a filename is specified without a full path.
                File.Exist() will succeed here, but the Uri constructor down the line will throw.
            </remarks>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.DirectUI.DirectUISchemaContext.#ctor">
            <summary>
            For use by DirectUIXamlLanguage only
            This should only be called after a successfull call to the public Ctor
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.DirectUI.DirectUISchemaContext.ProxyTypes">
            <summary>
            A collection of types that exist in XAML UI but don't exist as actual types in the Jupiter Object Model.
            The Xaml Schema needs a type to find properties, constructors etc.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.TypeInfoCollector.ShouldTreatAsPropertyPath(Microsoft.UI.Xaml.Markup.Compiler.XamlDom.XamlDomMember)">
            <summary>
            A workaround for OSG-2051809. Some Properties are defined as strings instead of PropertyPaths.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.XamlFileMustEndInDotXaml">
            <summary>
            Error moved from top level driver into XBF generator.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.XamlXBindParseError">
            <summary>
            Error moved from top level driver into XBF generator.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ConnectionIdElement.NeedsConnectCase">
            <summary>
            Needs a connect case if it's a user named field in the file root namescope (we don't need this for named elements in templates), or has events.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.FieldDefinition.HasSameAttributes(Microsoft.UI.Xaml.Markup.Compiler.FieldDefinition)">
            <summary>
            Compare two FieldDefinitions to see if they are identical and don't need merging.
            Does not look at line number infomation
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.FieldDefinition.CanBeMerged(Microsoft.UI.Xaml.Markup.Compiler.FieldDefinition)">
            <summary>
            Compare two FieldDefinitions check for Irreconcilable differneces.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.FieldDefinition.CreateMerged(Microsoft.UI.Xaml.Markup.Compiler.FieldDefinition,Microsoft.UI.Xaml.Markup.Compiler.FieldDefinition)">
            <summary>
            Create a new FieldDefinition with a best common base class.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.XamlClassCodeInfo.IsApplication">
            <summary>
            Is App.xaml
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.XamlClassCodeInfo.ClassXamlType">
            <summary>
            Class type, only availible in Pass2.
            This can also be null if the class is not public.  (like the App Class)
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.XamlProjectInfo.GenerateOtherProvidersForCX">
            <summary>
            We generate calls to other providers if we're an app (old case),
            or if we're building with FullXamlMetadataProvider.
            This is used by CX only, where we have missbehaving clients.
            C# and VB have always generated "other providers"
            and C++\WinRT will follow their lead.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.InternalErrorException">
            <summary>
            This exception is to be thrown whenever an assumption we have made in the code turns out to be false. Thus, if this
            exception ever gets thrown, it is because of a bug in our own code, not because of something the user or project author
            did wrong.

            !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
            WARNING: When this file is shared into multiple assemblies each assembly will view this as a different type.
                     Don't throw this exception from one assembly and catch it in another.
            !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~

            </summary>
            <owner>RGoel</owner>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.InternalErrorException.#ctor">
            <summary>
            Default constructor.
            </summary>
            <owner>RGoel</owner>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.InternalErrorException.#ctor(System.String)">
            <summary>
            Creates an instance of this exception using the given message.
            </summary>
            <owner>RGoel</owner>
            <param name="message"></param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.InternalErrorException.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of this exception using the given message.
            </summary>
            <owner>RGoel</owner>
            <param name="message"></param>
            <param name="showAssert">Whether or not to show the assert dialog.</param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.InternalErrorException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an instance of this exception using the given message and inner exception.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.InternalErrorException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor used for (de)serialization. The constructor is private as this class is sealed
            If we ever add new members to this class, we'll need to update this.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.InternalErrorException.ShowAssertDialog(System.Boolean)">
            <summary>
            Show the assert if showAssert==true.
            </summary>
            <param name="showAssert"></param>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.KS">
            <summary>
            String compare and formating class.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.KS.Eq(System.String,System.String)">
            <summary>
            Standard String Compare operation.
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.KS.EqIgnoreCase(System.String,System.String)">
            <summary>
            Standard String Compare operation.  (ignore case)
            </summary>
        </member>
        <member name="M:Microsoft.UI.Xaml.Markup.Compiler.StringExtensions.GetMemberFriendlyName(System.String)">
            <summary>
            Returns a name that could be used in code.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Parsing.BailErrorStrategy">
            <summary>
            BailErrorStrategy
            Disables Antlr's automatic error recovery mechanisms following the example in
            The Definitive Antlr 4 Reference - section 9.5 on page 172.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Parsing.BindingPathListener">
            <summary>
            BindingPathListener overrides the generated BindingPathBaseListener class
            to provide implementations for the different parsing rules specified in the
            BindingPath.g4 file.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.Parsing.ConditionalNamespaceListener">
            <summary>
            ConditionalNamespaceListener
            Overrides the generated ConditionalNamespaceBaseListener class to provide implementations
            for the different parsing rules specified in the ConditionalNamespace.g4 file.  This allows
            us to build up the BindPathSteps that will be returned from BindPathParser.ParsePath.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.FunctionStep.ValueTypeIsConditional">
            <summary>
            ValueTypeIsConditional indicates if a step if of a conditional type. It is different than
            checking ApiInformation on the step itself, which is used to tell to not use that step unless the
            ApiInformation check is satisfied. This checks against the step value type itself.
            ex: a conditional namespace root field step.
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.RootNamedElementStep">
            <summary>
            RootNamedElementStep represents a bind path step that is the first field or named element in the path.
            This can either refer to one of:
                1. A field on the file root
                2. A named element on the file root (note: this is equivalent to 1 as we
                   codegen a field for all named elements in the file root namescope)
                3. A field on the template root
                4. A named element within a template
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.BindPathStep.Dependents">
            <summary>
            Dependents are steps that depend on this step, for instance,
            a FunctionStep would be a dependent of this step, if the FunctionStep
            would have this step as an argument.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.BindPathStep.AssociatedBindAssignments">
            <summary>
            AssociatedBindAssignments returns any BindAssignments associated with this step. This means any assignments
            this step is directly connected to, or any BindAssignments that one of its Dependents
            (i.e. parameters in a FunctionStep) are associated with.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.BindPathStep.IsValueRequired">
            <summary>
            IsValueRequired indicates if the step is annoted with the [System.ComponentModel.DataAnnotations.RequiredAttribute]
            </summary>
        </member>
        <member name="T:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.CastCannotStartWithAttachedProperty">
            <summary>
              Looks up a localized string similar to Starting a cast with an Attached Property is not supported.  Try a syntax like: path.(owner.property)..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.ExpectingDigit">
            <summary>
              Looks up a localized string similar to Expecting a digit..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.ExpectingMethod">
            <summary>
              Looks up a localized string similar to Expecting a method..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.ExpectingStaticFunction">
            <summary>
              Looks up a localized string similar to Expecting &apos;{0}&apos; on type &apos;{1}&apos; to be a static function..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.ExpectingStaticProperty">
            <summary>
              Looks up a localized string similar to Expecting &apos;{0}&apos; on type &apos;{1}&apos; to be a static property..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.FunctionAsParameter">
            <summary>
              Looks up a localized string similar to Functions cannot have other functions as parameters..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.FunctionNotLeaf">
            <summary>
              Looks up a localized string similar to Functions are only supported at the end of the bind path..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.InvalidCast">
            <summary>
              Looks up a localized string similar to Unable to cast type &apos;{0}&apos; to &apos;{1}&apos;.  Use a converter or function binding to change the type..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.InvalidParameter">
            <summary>
              Looks up a localized string similar to Invalid or missmatched parameter at position &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.MissmatchedParameterCount">
            <summary>
              Looks up a localized string similar to Missmatched function parameter count..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.MultipleNamespaceConditionalStatements">
            <summary>
              Looks up a localized string similar to Multiple namespace conditional statements found..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.MultipleTargetPlatforms">
            <summary>
              Looks up a localized string similar to Multiple target platforms found..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.NoMatchingOverload">
            <summary>
              Looks up a localized string similar to Cannot find an overload that takes {0} parameters..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.PropertyNotFound">
            <summary>
              Looks up a localized string similar to Property &apos;{0}&apos; not found on type &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.PropertyWithoutGet">
            <summary>
              Looks up a localized string similar to Property &apos;{0}&apos; on type &apos;{1}&apos; does not have a &apos;get&apos; accessor..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.SyntaxError">
            <summary>
              Looks up a localized string similar to Syntax error at &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.TypeNotFound">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; not found..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.UnbindableMemberConflict">
            <summary>
              Looks up a localized string similar to Named element &apos;{0}&apos; conflicts with an unbindable member on root data type &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.UnexpectedArrayIndexer">
            <summary>
              Looks up a localized string similar to Unexpected array indexer..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.UnmatchedApiInformationParameters">
            <summary>
              Looks up a localized string similar to Unmatched API information parameters for method &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.UnrecognizedApiInformation">
            <summary>
              Looks up a localized string similar to Unrecognized API information &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.UnsuportedOutParameter">
            <summary>
              Looks up a localized string similar to Unsuported ref/out parameter at position &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.UI.Xaml.Markup.Compiler.ErrorMessages.UsingNamedElement">
            <summary>
              Looks up a localized string similar to Named element &apos;{0}&apos; also exists on root data type &apos;{1}&apos;. Using field from root data type..
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ArrayInsideArrayInAttributeNotSupported">
            <summary>
              Looks up a localized string similar to Arrays inside other arrays in custom attributes is not supported..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.AssemblyRefTokenExpected">
            <summary>
              Looks up a localized string similar to Assembly reference token expected..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.CannotDetermineSystemAssembly">
            <summary>
              Looks up a localized string similar to Type universe has not selected an assembly as the system assembly..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.CannotFindTypeInModule">
            <summary>
              Looks up a localized string similar to Cannot find type {0} in module {1}..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.CannotResolveModuleRefOnNetModule">
            <summary>
              Looks up a localized string similar to Cannot resolve module reference on a single net module..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.CannotResolveRVA">
            <summary>
              Looks up a localized string similar to Cannot resolve RVA..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.CaseInsensitiveTypeLookupNotImplemented">
            <summary>
              Looks up a localized string similar to Case insensitive type lookup is not implemented..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.CorruptImage">
            <summary>
              Looks up a localized string similar to Image is corrupt. Attempting to read an out of range RVA..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.DefaultTokenResolverRequired">
            <summary>
              Looks up a localized string similar to Without an assembly qualified name, a default token resolver is required..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.DifferentTokenResolverForOuterType">
            <summary>
              Looks up a localized string similar to Outer type has different token resolver..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.EscapeSequenceMissingCharacter">
            <summary>
              Looks up a localized string similar to Escape sequence missing character after the backslash..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ExpectedPositiveNumberOfGenericParameters">
            <summary>
              Looks up a localized string similar to Expected positive number of generic parameters. .
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ExpectedPropertyOrFieldId">
            <summary>
              Looks up a localized string similar to Expected property or field ID..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ExpectedTokenType">
            <summary>
              Looks up a localized string similar to {0} token expected..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ExtraAssemblyManifest">
            <summary>
              Looks up a localized string similar to Non-manifest module contains assembly manifest or module is corrupted..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ExtraCharactersAfterTypeName">
            <summary>
              Looks up a localized string similar to Extra characters after type name..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ExtraInformationAfterLastParameter">
            <summary>
              Looks up a localized string similar to More information left after last parameter is processed..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.HostSpecifierMissing">
            <summary>
              Looks up a localized string similar to Assembly qualified name requires a host..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.IdTokenTypeExpected">
            <summary>
              Looks up a localized string similar to Id token type expected..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.IllegalElementType">
            <summary>
              Looks up a localized string similar to Illegal element type {0}..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.IllegalLayoutMask">
            <summary>
              Looks up a localized string similar to Illegal layout mask..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.IncorrectElementTypeValue">
            <summary>
              Looks up a localized string similar to Incorrect core element type value..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.InvalidCustomAttributeFormat">
            <summary>
              Looks up a localized string similar to Invalid custom attribute format..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.InvalidCustomAttributeFormatForEnum">
            <summary>
              Looks up a localized string similar to Invalid custom attribute blob. Enum parameters must have full type name specified..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.InvalidElementTypeInAttribute">
            <summary>
              Looks up a localized string similar to Invalid core element type in custom attribute blob..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.InvalidFileFormat">
            <summary>
              Looks up a localized string similar to Invalid file format..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.InvalidFileName">
            <summary>
              Looks up a localized string similar to Invalid file name: &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.InvalidMetadata">
            <summary>
              Looks up a localized string similar to Invalid metadata..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.InvalidMetadataSignature">
            <summary>
              Looks up a localized string similar to Invalid metadata signature..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.InvalidMetadataToken">
            <summary>
              Looks up a localized string similar to Invalid metadata token {0}..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.InvalidPublicKeyTokenLength">
            <summary>
              Looks up a localized string similar to Length of public key token must be even..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.JaggedArrayInAttributeNotSupported">
            <summary>
              Looks up a localized string similar to Jagged array in custom attributes is not supported..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ManifestModuleMustBeProvided">
            <summary>
              Looks up a localized string similar to Manifest module must be provided..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.MethodIsUsingUnsupportedBindingFlags">
            <summary>
              Looks up a localized string similar to {0} is using unsupported binding flags {1}.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.MethodTokenExpected">
            <summary>
              Looks up a localized string similar to Method token expected..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.NoAssemblyManifest">
            <summary>
              Looks up a localized string similar to Manifest module does not contain assembly manifest or module is corrupted..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.OperationInvalidOnAutoLayoutFields">
            <summary>
              Looks up a localized string similar to This operation cannot be be applied to RVA fields with auto-layout..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.OperationValidOnArrayTypeOnly">
            <summary>
              Looks up a localized string similar to This operation is valid on an array type only..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.OperationValidOnEnumOnly">
            <summary>
              Looks up a localized string similar to This operation is valid on Enum types only..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.OperationValidOnLiteralFieldsOnly">
            <summary>
              Looks up a localized string similar to This operation can be applied to literal fields only..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.OperationValidOnRVAFieldsOnly">
            <summary>
              Looks up a localized string similar to This operation is valid on RVA fields only..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ResolvedAssemblyMustBeWithinSameUniverse">
            <summary>
              Looks up a localized string similar to Resolved assembly must be within the same universe..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ResolverMustResolveToValidAssembly">
            <summary>
              Looks up a localized string similar to Resolver must resolve to a valid assembly..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ResolverMustResolveToValidModule">
            <summary>
              Looks up a localized string similar to Resolver must resolve module reference to a valid module..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ResolverMustSetAssemblyProperty">
            <summary>
              Looks up a localized string similar to Resolver must set assembly property to this assembly..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.RVAUnsupported">
            <summary>
              Looks up a localized string similar to This metadata importer doesn&apos;t have a base address to resolve RVA address against..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.TypeArgumentCannotBeResolved">
            <summary>
              Looks up a localized string similar to Type argument cannot be resolved..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.TypeTokenExpected">
            <summary>
              Looks up a localized string similar to Type token expected..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.UnexpectedCharacterFound">
            <summary>
              Looks up a localized string similar to Unexpected character found while parsing..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.UnexpectedEndOfInput">
            <summary>
              Looks up a localized string similar to Unexpected end of input..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.UniverseCannotResolveAssembly">
            <summary>
              Looks up a localized string similar to Type universe cannot resolve assembly: {0}..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.UnrecognizedAssemblyAttribute">
            <summary>
              Looks up a localized string similar to Unrecognized assembly attribute: {0}..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.UnsupportedExceptionFlags">
            <summary>
              Looks up a localized string similar to Unsupported exception flags {0}..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.UnsupportedImageType">
            <summary>
              Looks up a localized string similar to Unsupported image type..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.UnsupportedTypeInAttributeSignature">
            <summary>
              Looks up a localized string similar to Unsupported type argument in custom attribute signature..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.ValidOnGenericParameterTypeOnly">
            <summary>
              Looks up a localized string similar to Method may only be called on a Type for which Type.IsGenericParameter is true..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.VarargSignaturesNotImplemented">
            <summary>
              Looks up a localized string similar to Signatures with variable number of arguments are not implemented..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.VersionAlreadyDefined">
            <summary>
              Looks up a localized string similar to Version already defined..
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.WindowsRuntimeTypeNotFound">
            <summary>
              Looks up a localized string similar to Windows runtime type {0} cannot be found.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Resources.WrongNumberOfGenericArguments">
            <summary>
              Looks up a localized string similar to Wrong number of generic arguments..
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.AssemblyProxy">
            <summary>
            An assembly proxy object. All methods just forward to the resolved assembly.
            Derived classes can implemen the resolution function.
            This is a general purpose object that can work with different type providers.
            Explicitly have a DebuggerDisplay here to avoid calling the ToString() method,
            which could throw exceptions when the resolution fails.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.AssemblyProxy.Dispose">
            <summary>
            This should only be called in the context of disposing the parent Universe.
            Caller is responsible for thread safey here and to not dispose while another thread is using.
            Caller should not use after this has been diposed.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.AssemblyProxy.GetResolvedAssemblyWorker">
            <summary>
            Implemented by derived class to resolve the assembly.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ConstructorInfoProxy">
            <summary>
            Helper for proxy ConstructorInfo that forwards all calls.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.ConstructorInfoProxy.GetResolvedWorker">
            <summary>
            Derived classes implement to provide the real constructor object that we forward to.
            </summary>
            <returns></returns>
        </member>
        <member name="T:System.Reflection.Adds.CorElementType">
            <summary>
            Represents a raw element type.  Values in this enum are chosen to be castable to the CorElementType enumeration
            used by the CLR api's, as well as the internal PrimitiveType enumeration.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ElementTypeUtility">
            <summary>
            Provides a utility mapping to get string names from built in types.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.FileMapping">
            <summary>
            Map a file into memory and expose access.
            This is internal and intended to support Metadata files.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.FileMapping.#ctor(System.IntPtr,System.Int64,System.String)">
            <summary>
            Create a file mapping around the given filename with already available
            base address and file size.
            </summary>
            <param name="fileName">Path to the mapped file; can be relative.</param>
        </member>
        <member name="M:System.Reflection.Adds.FileMapping.#ctor(System.String)">
            <summary>
            Create a file mapping around the given filename
            </summary>
            <param name="fileName">filename to open; can be relative</param>
        </member>
        <member name="P:System.Reflection.Adds.FileMapping.Path">
            <summary>
            Full path to the file.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.FileMapping.Length">
            <summary>
            Length of file in bytes.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.FileMapping.BaseAddress">
            <summary>
            Base address of file. This can be used in direct memory operations to read the file contents.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.NativeMethods">
            <summary>
            Import of native definitions supporting FileMapping class.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.NativeMethods.SafeOpenFile(System.String)">
            <summary>
            Wrapper method to directly get a file handle from Win32 API.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.NativeMethods.FileSize(Microsoft.Win32.SafeHandles.SafeFileHandle)">
            <summary>
            Wrapper to get file size as long.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ImageHelper">
            <summary>
            Internal support for cracking PE files.
            The metadata import interfaces just give RVAs to key data (like method bodies), and so fully
            cracking the metadata requires resolving those RVAs.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.ImageHelper.ImageType">
            <summary>
            Defines image type: 32-bit or 64-bit.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.ImageHelper.GetResourcesSectionStart">
            <summary>
            Finds real pointer to the start of managed resources section.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.ImageHelper.GetCor20Header">
            <summary>
            Get the IMAGE_COR20_HEADER.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Reflection.Adds.ImageHelper.GetEntryPointToken">
            <summary>
            Get the token that specifies the method  where execution in this module should start (as defined in ecma II.25.3.3.2 )
            or a null token if no such method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Reflection.Adds.ImageHelper.ResolveRva(System.Int64)">
            <summary>
            Resolve an Relative-Virtual-Address (RVA) within a file to a real address.
            The RVA is likely obtained as data embedded in the PE image, and used to refer to data elsewhere
            in the PE image.
            </summary>
            <param name="rva">rva within the PE image</param>
            <returns>a real address within the process, or 0 if the RVA can't be resolved. </returns>
            <remarks>You can't just resolve an RVA by adding it to the base address because RVAs the loaded
            image and the on-disk image are different. RVAs baked into the image are designed to be used in
            the loaded case, in which case it can just be added to the base address. But the on-disk image
            may have the sections in a compressed form. So we need to walk the sections to determine where
            the RVA would go. </remarks>
        </member>
        <member name="P:System.Reflection.Adds.ImageHelper.IMAGE_DOS_HEADER.IsValid">
            <summary>
            Determine if this is a valid DOS image.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ImageHelper.IMAGE_FILE_HEADER">
            <summary>
            Native import for IMAGE_FILE_HEADER.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ImageHelper.IMAGE_NT_HEADERS_HELPER">
            <summary>
            Defines first part of IMAGE_NT_HEADERS that's processor architecture independant.
            Used to read "Magic" field that contains image type: 32-bit or 64-bit.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ImageHelper.IMAGE_NT_HEADERS_32">
            <summary>
            Native import for IMAGE_NT_HEADER on 32-bit architecture.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ImageHelper.IMAGE_NT_HEADERS_64">
            <summary>
            Native import for IMAGE_NT_HEADER on 64-bit architecture.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ImageHelper.IMAGE_SECTION_HEADER">
            <summary>
            Native import for IMAGE_NT_HEADERs.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ImageHelper.IMAGE_OPTIONAL_HEADER_32">
            <summary>
            Managed definition for IMAGE_OPTIONAL_HEADER32 from Winnt.h.
            See Serge Lidin's book .NET IL assembler (page 47) for full description.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ImageHelper.IMAGE_OPTIONAL_HEADER_64">
            <summary>
            Managed definition for IMAGE_OPTIONAL_HEADER64 from Winnt.h.
            See Serge Lidin's book .NET IL assembler (page 47) for full description.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ImageHelper.IMAGE_DATA_DIRECTORY">
            <summary>
            Managed definition for IMAGE_DATA_DIRECTORY from Winnt.h.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ImageHelper.IMAGE_COR20_HEADER">
            <summary>
            Managed definition for CLR Header structure.
            See Serge Lidin's book .NET IL assembler (page 56) for full description.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.ImageHelper.MarshalAt``1(System.UInt32)">
            <summary>
            Marshal an unmanaged data structure from the image
            </summary>
            <typeparam name="T">managed type for the data structure to marshal</typeparam>
            <param name="offset">offset within the image to copy from. This must be in the image's range. </param>
            <returns>a managed version of the data structure marshaled from the image.</returns>
        </member>
        <member name="T:System.Reflection.Adds.IMutableTypeUniverse">
            <summary>
            Mutable universe extends a ITypeUniverse with operations to actually load assemblies into the universe.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.IMutableTypeUniverse.AddAssembly(System.Reflection.Assembly)">
            <summary>
            Register the assembly as being loaded into this universe
            </summary>
            <param name="assembly">An assembly that was created to be in this universe. It should implement IAssembly2
            and have its TypeUniverse set to this instance.</param>
        </member>
        <member name="T:System.Reflection.Adds.ITypeProxy">
            <summary>
            Represents a type that can resolve to another type.
            This can commonly handle TypeRef and TypeSpecs in the metadata.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.ITypeProxy.TypeUniverse">
            <summary>
            Get the type universe that this type is in. A type and its resolved type are in the same universe.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ITypeSignatureBlob">
            <summary>
            Represents a type signature blob.
            This derives from ITypeProxy to provide a Type object model over the raw byte array.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.ITypeSignatureBlob.Blob">
            <summary>
            Get the raw bytes for the blob.
            Anything that has a blob also means a signature parser and TypeAlgebra tree.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.ITypeSignatureBlob.DeclaringScope">
            <summary>
            The scope that the tokens in the blob are valid in.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.ITypeSpec">
            <summary>
            Represents a TypeSpec in the metadata.
            Represents a metadata signature.
            </summary>
            <remarks>
            Some metadata items return a TypeSpec (such as a Type's base type token)
            Others return the signature blob directly (such as a Field's Type).
            </remarks>
        </member>
        <member name="T:System.Reflection.Adds.ITypeUniverse">
            <summary>
            This describes a "TypeUniverse".
            This is a full transitive closure of all possible types, along with key operations on the universe
            such as type-lookup and resolution between scopes.
            Universes are completely isolated and so a host can maintain multiple type universes.

            Common universe implementations may be:
            1. A static universe -  a host may implement a universe based on static metadata. In this case, the
            host can resolve assemblies using arbitrary policy.
            2. A "debuggee process" universe - a debugger application may implement a universe to describe the
            types in another process. In this case, the assembly resolution must match what the existing process
            actually did, so use ICorDebugModule2.ResolveAssembly.

            Some functionality is explicitly not on the type universe:
            - Enumerate all assemblies: this can impede lazily loading assemblies into the universe.
            </summary>
            <remarks>
            An ITypeUniverse is read-only and doesn't provide loading facilities. See IMutableTypeUniverse for loading.
            </remarks>
        </member>
        <member name="M:System.Reflection.Adds.ITypeUniverse.GetBuiltInType(System.Reflection.Adds.CorElementType)">
            <summary>
            Callback to the universe to resolve the builtin types.

            From standard I.8.2.2: Builtin types, determined by the virtual execution system.
            Also, encoding for builtin types must use the short form (I4) instead of the long form
            (TypeRef("System.Int32", mscorlib).
            Get a type for a given CLR element type (eg, COR_ELEMENT_TYPE I4)
            This is redundant with GetSystemAssembly().GetType(NameFrom(elementType), true, false)), however
            the lookup by type code allows a more efficient lookup without having to go through strings.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.ITypeUniverse.GetTypeXFromName(System.String)">
            <summary>
            Get a type from the given full name, (eg  "System.Object").
            This is only valid for types in mscorlib.
            This is redundant with GetSystemAssembly().GetType()
            </summary>        ///
        </member>
        <member name="M:System.Reflection.Adds.ITypeUniverse.GetSystemAssembly">
             <summary>
             The CLR execution implicitly requires a single system assembly.  On desktop CLR, this is "mscorlib.dll".
             This is used for things including:
             - resolving built-in types such as I4 --> "mscorlib!System.Int32".
             - providing critical types such as System.Object and System.Array (base class for all Arrays)
             - providing System.ValueType, System.Enum, System.Delegate
             Many APIs on reflection require knowing the system assembly such as Type.IsEnum

             The type-universe can fail to implement this, but many APIs that require knowledge of the system
             assembly will fail. APIs that don't innately require that knowledge should still be able to work.
             </summary>
        </member>
        <member name="M:System.Reflection.Adds.ITypeUniverse.GetSystemRuntimeAssembly">
            <summary>
            For UAP scenarios, mscorlib type forwards all types to system.runtime.dll. Checks previously dependent on the value for type.Assembly
            Should account for the new dll as well.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Reflection.Adds.ITypeUniverse.ResolveAssembly(System.Reflection.AssemblyName)">
            <summary>
            Simple assembly resolution by name. This is similar to Assembly.Load(AssemblyName).
            This can not properly model multiple loader contexts (see Assembly.LoadFrom), and therefore it
            can not fully model an existing process.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.ITypeUniverse.ResolveAssembly(System.Reflection.AssemblyName,System.Boolean)">
            <summary>
            Simple assembly resolution by name. This is similar to Assembly.Load(AssemblyName).
            This can not properly model multiple loader contexts (see Assembly.LoadFrom), and therefore it
            can not fully model an existing process.
            </summary>
            <param name="name">Assembly name to resolve</param>
            <param name="throwOnError">True to throw an exception if the assembly cannot be found otherwise
            false to return null when the assembly cannot be found</param>
            <returns></returns>
        </member>
        <member name="M:System.Reflection.Adds.ITypeUniverse.ResolveAssembly(System.Reflection.Module,System.Reflection.Adds.Token)">
            <summary>
            Fine-grain Assembly resolution using the calling assembly and the token of the assembly ref.
            Scope represents a module that has an IMetadataImport scope.
            tokenAssemblyRef is an assembly ref token valid in the given scope.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.ITypeUniverse.WouldResolveToAssembly(System.Reflection.AssemblyName,System.Reflection.Assembly)">
            <summary>
            Test whether assembly resolution would resolve the specified name to the given assembly
            if it was part of this universe.
            This doesn't actually do a resolution, just uses the same algorithm that ResolveAssembly
            uses to compare names to Assembly definitions.
            Note that the caller would need to also check that the supplied assembly is actually part
            of this universe before knowing that ResolveAssembly would succeed on the supplied name.
            </summary>
            <param name="name">The assembly name that would be resolved</param>
            <param name="assembly">The assembly to test</param>
            <returns>True if (and only if) the name would resolve to the supplied assembly if it were
            part of this universe</returns>
        </member>
        <member name="M:System.Reflection.Adds.ITypeUniverse.ResolveModule(System.Reflection.Assembly,System.String)">
            <summary>
            Netmodule resolution by name for multi-module assemblies.
            </summary>
            <param name="containingAssembly">Multi-module assembly resolved module will be part of.
            It should already contain manifest module.
            ITypeUniverse implementation can use information like assembly location to determine
            where dependent netmodules should be loaded from.</param>
            <param name="moduleName">Name of a net module that needs to be resolved. This name comes from
            the manifest module and its Files table. It's equal to the module's Name property.</param>
        </member>
        <member name="M:System.Reflection.Adds.ITypeUniverse.ResolveWindowsRuntimeType(System.String,System.Boolean,System.Boolean)">
            <summary>
            Resolves a Windows Runtime type using windows metadata rules. Example: if the type name
            is RootNamespace.SubNamespace.TypeName first look in RootNamespace.Subnamespace.winmd for
            TypeName if the assembly does not exist or it is not found look in RootNamespace.winmd.
            </summary>
            <param name="typeName">The type name to resolve</param>
            <param name="throwOnError">True to throw an exception if the type cannot be found otherwise
            false to return null when the type cannot be found</param>
            <param name="ignoreCase">true to perform a case-insensitive search for typeName, false to
            perform a case-sensitive search for typeName.</param>
            <returns></returns>
        </member>
        <member name="T:System.Reflection.Adds.MetadataDispenser">
            <summary>
            Helper class to open up a Metadata scope from a file.
            This can be called on multiple threads.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.MetadataDispenser.GetDispenserShim">
            <summary>
            Creates dispenser appropriately based on runtime version.
            </summary>
            <remarks>
            In v4, interfaces in mscoree need to be created through indirection
            to make sure we'll get v4 implementation instead of v2. This is due
            to in-proc SxS changes introduced in CLR v4.
            </remarks>
        </member>
        <member name="M:System.Reflection.Adds.MetadataDispenser.OpenFromByteArray(System.Byte[])">
            <summary>
            Open a metadata file from the given stream. The stream should contain the same contents as the file on disk.
            This will read all bytes from the stream.
            </summary>
            <param name="data">stream for metadata file. This should start with 'mz', not 'bsjb'.</param>
            <returns>a wrapper around a raw importer created on the raw bytes of data.</returns>
        </member>
        <member name="T:System.Reflection.Adds.MetadataDispenser.MetadataFileOnByteArray">
            <summary>
            MetadataFile for an in-memory importer. This protects the backing memory.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.MetadataDispenser.MetadataFileOnByteArray.#ctor(System.Runtime.InteropServices.GCHandle@,System.IntPtr)">
            <summary>
            constructor
            </summary>
            <param name="h">gchandle pinning the memory pointed to by pUnk. If the ctor succeeds,
            it will clear h to indicate to caller that we've taken ownership of freeing the GC handle.</param>
            <param name="pUnk">pointer to raw metadata bytes</param>
        </member>
        <member name="M:System.Reflection.Adds.MetadataDispenser.OpenFileAsFileMapping(System.String)">
            <summary>
            Open file retrieving the RVA so that we have full access to metadata.
            </summary>
            <param name="fileName">filename to open</param>
            <returns>a metadata file object with RVA resolution abilities</returns>
        </member>
        <member name="M:System.Reflection.Adds.MetadataDispenser.OpenFileAsFileMapping(System.Object,System.String)">
            <summary>
            Creates MetadataFile object over already available IMetadataImport interface (instead of opening
            scope and getting it manually like in other overloads). E.g. this is useful when clients need to use
            IVsSmartOpenScope to faciliate sharing. It will also retrieve the RVA so that we have full access to metadata.
            </summary>
            <param name="importer">An RCW around an IMetadataImport interface. Caller is responsible for importer's lifetime.</param>
            <param name="fileName">Full path to the opened file in case we need to fall back on mapping the file manually.
            E.g. this would happen when the file is in the GAC because CLR doesn't support it.</param>
            <returns>A metadata file object with RVA resolution abilities.</returns>
        </member>
        <member name="M:System.Reflection.Adds.MetadataDispenser.OpenFile(System.String)">
            <summary>
            Open a metadata scope from a file on disk for read-only.
            </summary>
            <param name="fileName">filename to pass to </param>
            <returns>a metadata scope object representing the file. It can't resolve RVAs.</returns>
        </member>
        <member name="F:System.Reflection.Adds.MetadataDispenser.m_openFlags">
            <summary>
            The flags to use when opening a new importer
            In this version of LMR we always want the raw view of WinMD files (NoTransform).  For more general use we
            probably want to give the host the option to choose.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.EmbeddedBlobPointer">
            <summary>
            Represents an live IntPtr that points into the loaded metadata blob.
            This wraps the live pointer to protect access to it.
            The only way to actually read the contents from the pointer requires going through the MetadataFile,
            which can validate that the region of memory is valid.
            </summary>
            <remarks>The danger of exposing this pointer directly is that if the underlying storage was unloaded, the read
            becomes invalid. For example, a bug would be caching the raw pointer in a global, and then the underlying metadata
            file may get unloaded, and then reading from the pointer may crash.
            By wrapping these embedded poitnters here, we force the read to go through the MetadataFile, which owns
            the storage and can thus vouch that the read is safe.</remarks>
        </member>
        <member name="P:System.Reflection.Adds.EmbeddedBlobPointer.GetDangerousLivePointer">
            <summary>
            internal helper to get the pointer for reading. Caller should validate.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.MetadataFile">
            <summary>
            Represents a raw IMetadataImporter.
            Metadata has RVAs to data. However, a raw importer object doesn't have a base address. Since the creator of the metadata
            almost always has a base address, so we couple the base address and metadata object together.
            This is also disposable, which will just Release the underlying native IMetadataImport pointer. That's important because it
            may hold file locks.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFile.#ctor(System.Object)">
            <summary>
            Create a wrapper around an existing imported Metadata reader object.  This is problematic
            because the importer may have thread affinity.
            </summary>
            <param name="importer">a RCW around an IMetadataImport interface</param>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFile.#ctor(System.IntPtr)">
            <summary>
            Create a wrapper around a raw intPtr to a raw IMetadataImport
            This will take a reference to importer, so the caller can release their reference to transfer
            ownership to this object.
            </summary>
            <param name="rawImporter">a direct pointer to a IMetadataImport interface </param>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFile.Dispose">
            <summary>
            Implementation of IDisposable.Dispose. Explcitly release resources.
            Caller is responsible for thread safey here and to not dispose while another thread is using.
            Caller should not use after this has been diposed.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.MetadataFile.RawPtr">
            <summary>
            The raw IMetadataImport pointer. This may not yet have a RCW associated with it.
            This class owns a reference on the ptr and will call Release().
            This uses a IntPtr instead of a System.Object to avoid having an RCW to avoid thread-affinity issues.
            See code:MetadataDispenser.OpenFile for details.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.MetadataFile.FilePath">
            <summary>
            The path of the metadata file.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFile.ReadRva(System.Int64,System.Int32)">
            <summary>
            Read a region of memory specified by a Relative Virtual Address (RVA) in the given metadata scope.
            Fails if the data can't be read. This can
            include cases where the scope may not have a base address (dynamic modules, enc, etc)
            Never returns null.
            This can be used to read the raw bytes of RVA based static fields, such as in the case of the
            opaque struct blobs used in arrayliteral intializers, as well as MethodBody data.
            </summary>
            <param name="rva">rva encoded in metadata. </param>
            <param name="countBytes">number of bytes to read at</param>
            <returns>an array of bytes for the rva data. Throws on any failures. Never returns null.</returns>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFile.ReadResource(System.Int64)">
            <summary>
            Reads managed resource based on a given offset.
            </summary>
            <param name="offset">Offset on which a resource starts.</param>
            <returns>Content of resource. Throws on any failures. Never returns null.</returns>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFile.ReadEmbeddedBlob(System.Reflection.Adds.EmbeddedBlobPointer,System.Int32)">
            <summary>
            Read a blob embedded in the metadata
            </summary>
            <param name="pointer">live pointer into the metadata blob</param>
            <param name="countBytes">count of bytes to read</param>
            <returns>array of bytes of requested length copied from metadata blob.</returns>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFile.ValidateRange(System.IntPtr,System.Int32)">
            <summary>
            Derived class (which knows about the underlying storage of the IMDI) can validate that the region
            of memory is valid to read from.
            </summary>
            <param name="ptr">live pointer to within metadata blob</param>
            <param name="countBytes">count of bytes to read</param>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFile.ReadEntryPointToken">
            <summary>
            Get the entry point token from the IMAGE_COR20_HEADER in the PE file.
            See Ecma II 24.3.3.2 for details.
            This can be a MethodDEf or a File token. Although in C# apps, this will usually be the methodDef for Main().
            This requires RVA resolution.
            </summary>
            <returns>entry point token from the headers. Nil token if no entry point specified (such as with dlls).</returns>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFile.ReadRvaStruct``1(System.Int64)">
            <summary>
            Read a unmanaged structure at the region memory at the given RVA.
            </summary>
            <typeparam name="T">type of structure to be read</typeparam>
            <param name="rva">rva encoded in metadata. </param>
            <returns>an instance of T marshaled from the given RVA</returns>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFile.EnsureNotDispose">
            <summary>
            internal helper to throw if the object is disposed. Nop if class is ok.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.MetadataFileAndRvaResolver">
            <summary>
            Metadata file wrapper with RVA resolver capabilities.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFileAndRvaResolver.#ctor(System.IntPtr,System.Reflection.Adds.FileMapping)">
            <summary>
            Bind a metadata importer scope together with a file mapping that can be used to fully resolve
            any RVAs.
            </summary>
            <param name="importer">a raw pointer to an IMetadataImporter object. The importer should be
            retrieved via Dispenser.OpenScopeOnMemory() for memory backed by the file mapping.</param>
            <param name="file">a file mapping object that owns the raw buffer that the importer operates on.</param>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFileAndRvaResolver.#ctor(System.IntPtr,System.Reflection.Adds.FileMapping,System.Boolean)">
            <summary>
            Bind a metadata importer scope together with a file mapping that can be used to fully resolve
            any RVAs.
            </summary>
            <param name="importer">a raw pointer to an IMetadataImporter object. The importer should be
            retrieved via Dispenser.OpenScopeOnMemory() for memory backed by the file mapping.</param>
            <param name="file">a file mapping object that owns the raw buffer that the importer operates on.</param>
            <param name="disableRangeValidation">If true turns of range validation. This is required if the importer was opende without setting the NoTransform open flag.</param>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFileAndRvaResolver.#ctor(System.Object,System.Reflection.Adds.FileMapping)">
            <summary>
            Bind a metadata importer scope together with a file mapping that can be used to fully resolve
            any RVAs.
            </summary>
            <param name="importer">An RCW around an IMetadataImport interface.</param>
            <param name="file">a file mapping object that owns the raw buffer that the importer operates on.</param>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFileAndRvaResolver.ResolveRva(System.Int64)">
            <summary>
            Resolve an RVA to its real virtual address within this process space.
            </summary>
            <param name="rva">rva from this metadata file.</param>
            <returns>the resolved address</returns>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFileAndRvaResolver.ReadRva(System.Int64,System.Int32)">
            <summary>
            override base class definition.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFileAndRvaResolver.ReadResource(System.Int64)">
            <summary>
            Reads managed resource based on a given offset.
            </summary>
            <param name="offset">Offset on which a resource starts.</param>
            <returns>Resource content. Throws on any failures. Never returns null.</returns>
        </member>
        <member name="M:System.Reflection.Adds.MetadataFileAndRvaResolver.ReadRvaStruct``1(System.Int64)">
            <summary>
            override base class definition.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.IAssembly2">
            <summary>
            New APIs on System.Reflection.Assembly
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.IFieldInfo2">
            <summary>
            New APIs on System.Reflection.FieldInfo
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.IFieldInfo2.GetRvaField">
            <summary>
            Read the raw bytes for an Rva based field
            </summary>
            <returns>byte array of contents</returns>
            <remarks>See Ecma IIa.15.3.2 for more details.
            A common case for RVA fields is array literal initialization. </remarks>
        </member>
        <member name="T:System.Reflection.Adds.IModule2">
            <summary>
            New APIs on System.Reflection.Module
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.IModule2.RowCount(System.Reflection.Adds.MetadataTable)">
            <summary>
            Gets number of rows in a metadata table.
            </summary>
            <param name="metadataTableIndex">Metadata table index.</param>
            <returns>Number of rows in the specified metadata table.</returns>
        </member>
        <member name="M:System.Reflection.Adds.IModule2.GetAssemblyNameFromAssemblyRef(System.Reflection.Adds.Token)">
            <summary>
            Get the assembly name for the given assembly token in the metadata scope.
            </summary>
            <param name="token">assembly ref token valid in this module's scope.</param>
            <returns>Assembly name containing information from the metadata scope for the given assembly token.</returns>
            <remarks>An AssemblyName object represents the metadata stored in an assembly ref token.
            This is similar to Assembly.GetReferencedAssemblies(), except that this provides information at the module
            granularity and it can map a specific assembly ref token.</remarks>
        </member>
        <member name="M:System.Reflection.Adds.Helpers.Universe(System.Type)">
            <summary>
            Get the type universe from a type.
            </summary>
            <param name="type">type to get universe.</param>
            <returns>Returns null if type is not in a universe (such as with refleciton types)
            For ITypeProxy, get universe without resolving. </returns>
        </member>
        <member name="M:System.Reflection.Adds.Helpers.EnsureResolve(System.Type)">
            <summary>
            Return a resolved version of the type, if applicable.
            </summary>
            <param name="type">type to ensure resolved</param>
            <returns>a resolved version of the type</returns>
            <remarks>LMR's deferred resolution is directly at odds with Reflection's eager validation.
            This can be used to resolve a type and force validation to occur to get reflection error semantics.
            </remarks>
        </member>
        <member name="T:System.Reflection.Adds.SimpleUniverse">
            <summary>
            A basic universe implementation that is agnostic to any particular type provider implementation.
            This provides services like:
            - default implementations of universe methods
            - tracking a list of loaded assemblies
            - picking the system assembly
            - default resolution policy, plus a resolution callback for further customization.
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.SimpleUniverse.Assemblies">
            <summary>
            Get list of assemblies that have been explicitly loaded into this universe.
            Clients can use this to detect if an assembly is already loaded to avoid double-loading it.
            This can also be used to search the entire set of types in the universe.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.SimpleUniverse.AddAssembly(System.Reflection.Assembly)">
            <summary>
            Register the assembly as part of this universe. This is agnostic to the assembly implementation.
            </summary>
            <param name="assembly">an assembly in this universe. The assembly should implement IAssembly2
            and already be associated with this universe.</param>
            <remarks></remarks>
        </member>
        <member name="M:System.Reflection.Adds.SimpleUniverse.SetSystemAssembly(System.Reflection.Assembly)">
            <summary>
            Explicitly set the system assembly.  This will be used by ITypeUniverse.GetSystemAssembly().
            </summary>
            <param name="systemAssembly">The system assembly. This should already be in this universe.</param>
            <remarks>If this isn't called ITU.GetsystemAssembly() will use heuristics to select
            the most likely assembly.</remarks>
        </member>
        <member name="E:System.Reflection.Adds.SimpleUniverse.OnResolveEvent">
            <summary>
            Invoke the delegate when an assembly name doesn't resolve to within the loaded set.
            The delegate implementation can then add the assembly (or even multiple assemblies) into the universe
            and return the assembly it resolves to.

            This is only fired if the default implementation of ResolveAssembly can't match the assembly name
            to within the loaded set. Override ResolveAssembly to get ealier notification.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.SimpleUniverse.FindSystemAssembly">
            <summary>
            Search amongst the loaded assemblies for one that may be the system assembly
            </summary>
            <returns>the system assembly, or null if none found.</returns>
            <remarks>This can't invoke assembly resolve events. It's tempting to define the system assembly as
            ResolveAssembly("mscorlib"), but
            1) that chooses arbitrary policy for the assembly name (eg, "mscorlib"),
            2) that just punts the problem back to the host. </remarks>
        </member>
        <member name="M:System.Reflection.Adds.SimpleUniverse.ResolveWindowsRuntimeType(System.String,System.Boolean,System.Boolean)">
            <summary>
            Resolves a type from a Windows Runtime type name
            </summary>
            <param name="typeName">The name of the Windows Runtime type to resolve.
            The name can be a simple type name or an assemblyQualifiedTypeName.</param>
            <param name="throwOnError">True to throw an exception if the type cannot be found otherwise
            false to return null when the type cannot be found</param>
            <param name="ignoreCase">true to perform a case-insensitive search for typeName, false to
            perform a case-sensitive search for typeName.</param>
            <returns>Returns null if the assembly cannot be found otherwise return an assembly that contains a
            definition for the assemblyQualifiedTypeName</returns>
        </member>
        <member name="M:System.Reflection.Adds.SimpleUniverse.Dispose">
            <summary>
            Dispose this universe. This will release all native metadata objects within this universes's
            assemblies and modules.
            Do not use this universe after it's disposed.
            Caller is responsible for thread-safety and ensuring no other threads are using universe once
            the dispose is called.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.UnresolvedAssemblyException">
            <summary>
            Exception thrown when assembly can't resolve.
            </summary>
            Having an internal exception class deriving from System.Exception causes the following FxCop violation.
            It is ok to suppress it now since the exception type is only internally used and is not supposed to be
            caught by external users.
        </member>
        <member name="T:System.Reflection.Adds.ResolveAssemblyNameEventArgs">
            <summary>
            Assembly resolution callback, used by the AgnosticUniverse.
            </summary>
            <param name="args">an assembly name for that could not be matched to an already loaded assembly. </param>
            <returns>The assembly that the name resolves to. </returns>
        </member>
        <member name="T:System.Reflection.Adds.TokenType">
            <summary>
            Types for metadata tokens. These are from the unmanaged metadata interfaces in Cor.h
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.MetadataTable">
            <summary>
            Metadata table indexes as defined by the CLI standard.
            </summary>
        </member>
        <member name="T:System.Reflection.Adds.Token">
            <summary>
            Wrapper around an arbitrary metadata token. This should be sizeof(int).
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Token.Value">
            <summary>
            Get the token as an integer
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Token.TokenType">
            <summary>
            Get the type of token (MethodDef, MethodRef, TypeDef, etc)
            </summary>
        </member>
        <member name="P:System.Reflection.Adds.Token.Index">
            <summary>
            Get the row index (RID) of the token. This generally starts at 1,
            but 0 can be used for special cases (like invalid token)
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.Token.IsType(System.Reflection.Adds.TokenType)">
            <summary>
            Check if this token is of the given type.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.Token.ToString">
            <summary>
            Get a user-friendly string representation of the token.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.TypeNameParser.ParseTypeName(System.Reflection.Adds.ITypeUniverse,System.Reflection.Module,System.String)">
            <summary>
            Parses type name and returns type instance represented by type name.
            </summary>
            <param name="universe">If non-null, the univese that the returned type is valid in. This
            can be used to search for names.</param>
            <param name="module">If non-null, this is the module that input is valid in.
            If null, then universe must be non-null and the type is search throughout the entire universe.</param>
            <param name="input">String containing type name.</param>
            <returns>Type that corresponds to given type name.</returns>
            <exception cref="T:System.TypeLoadException">Thrown when type can't be found in a given module/universe.</exception>
            <exception cref="T:System.ArgumentException">Thrown when input contains more characters than expected.</exception>
        </member>
        <member name="M:System.Reflection.Adds.TypeNameParser.ParseTypeName(System.Reflection.Adds.ITypeUniverse,System.Reflection.Module,System.String,System.Boolean)">
            <summary>
            Parses type name and returns type instance represented by type name. Uses CLR's type name
            parser that's new in CLR v4.
            </summary>
            <param name="universe">If non-null, the univese that the returned type is valid in. This
            can be used to search for names.</param>
            <param name="module">If non-null, this is the module that input is valid in.
            If null, then universe must be non-null and the type is search throughout the entire universe.</param>
            <param name="input">String containing type name.</param>
            <param name="throwOnError">Controls behavior for cases when type with a given name cannot be found.</param>
            <returns>Type that corresponds to given type name. Can return null if type cannot be found and
            throwOnError flag is false.</returns>
            <exception cref="T:System.TypeLoadException">Thrown when type can't be found in a given module/universe and
            throwOnError flag is true.</exception>
            <exception cref="T:System.ArgumentException">Thrown when input contains more characters than expected.</exception>
        </member>
        <member name="M:System.Reflection.Adds.TypeNameParser.ParseTypeName(System.Reflection.Adds.ITypeUniverse,System.Reflection.Module,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Parses type name and returns type instance represented by type name. Uses CLR's type name
            parser that's new in CLR v4.
            </summary>
            <param name="universe">If non-null, the univese that the returned type is valid in. This
            can be used to search for names.</param>
            <param name="module">If non-null, this is the module that input is valid in.
            If null, then universe must be non-null and the type is search throughout the entire universe.</param>
            <param name="input">String containing type name.</param>
            <param name="useSystemAssemblyToResolveTypes">True if the system assembly(mscorlib) should be used to
            resolve types when the type cannot be found in module</param>
            <param name="useWindowsRuntimeResolution">True if Windows Runtime type resolution should be used</param>
            <param name="throwOnError">Controls behavior for cases when type with a given name cannot be found.</param>
            <returns>Type that corresponds to given type name. Can return null if type cannot be found and
            throwOnError flag is false.</returns>
            <exception cref="T:System.TypeLoadException">Thrown when type can't be found in a given module/universe and
            throwOnError flag is true.</exception>
            <exception cref="T:System.ArgumentException">Thrown when input contains more characters than expected.</exception>
            <returns></returns>
        </member>
        <member name="M:System.Reflection.Adds.TypeNameParser.IsGenericType(System.String,System.Int32)">
            <summary>
            Determines if input contains generic type specifier.
            </summary>
            <remarks>
            A left-bracket could either be a generic arg list or an array
             []  [,]  [*]  are arrays
             [T] [T1, T2] [[T1, AssemblyName], T2]  are generic arg lists
               Elements in the generic arg list are enclosed in a set of [] if it has an assembly
               qualified name. (AQNs include commas; so this determine whether the comma is separating
               generic args or separating the type from the AssemblyName)
            </remarks>
            <param name="input">String containing type name that's being parsed.</param>
            <param name="idx">Current index in input string.</param>
            <returns>True if type is generic type; otherwise false.</returns>
        </member>
        <member name="M:System.Reflection.Adds.TypeNameParser.Resolve(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Type},System.Reflection.Assembly)">
            <summary>
            Given the parsed string components of a type, create an actual type object.
            Caller can then apply modifiers to this.
            </summary>
            <param name="path">Type name parts.</param>
            <param name="genericTypeArgs">Type arguments for generic types.</param>
            <param name="assembly">Assembly in which type should be looked up.</param>
            <returns>Type that corresponds to given type name or null if type cannot be found.</returns>
        </member>
        <member name="M:System.Reflection.Adds.TypeNameParser.ReadIdToken(System.String,System.Int32@)">
            <summary>
            The string returned for the IdToken may contain whitespaces,
            including leading and ending whitespaces, e.g. " Foo ".
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.TypeNameParser.ReadIdWithoutLeadingSpaces(System.String,System.Int32@)">
            <summary>
            Return a string without leading spaces, e.g. used for type name.
            The result can have ending spaces, e.g. "Type Name ".
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.TypeNameParser.ReadIdWithoutLeadingAndEndingSpaces(System.String,System.Int32@)">
            <summary>
            Return a string without leading end ending spaces, e.g. for assmbly name.
            The result may contain spaces in the middle, e.g. "Assembly Name".
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.TypeNameParser.TrimLeadingSpaces(System.String)">
            <summary>
            The method rips off the leading whitespaces in the input.
            The result is String.Empty if the input only contains whitespaces.
            </summary>
        </member>
        <member name="M:System.Reflection.Adds.TypeNameParser.IsCompoundType(System.String)">
            <summary>
            Detemines if given type name represents a compound type (e.g. generic, array, nested,
            pointer, or reference).
            </summary>
            <returns>True if the typename requires any parsing and is not just found in the TypeDef name table.</returns>
        </member>
        <member name="T:System.Windows.Markup.MarkupExtensionBracketCharactersAttribute">
            <summary>
            Attribute to declare that this associated property will have special parsing rules
            for any text that is enclosed between these special characters.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.MarkupExtensionBracketCharactersAttribute.#ctor(System.Char,System.Char)">
            <summary>
            Constructor for an MarkupExtensionBracketCharactersAttribute
            </summary>
            <param name="openingBracket">Opening character for the Bracket characters. For example, '(' , '[' </param>
            /// <param name="closingBracket">Closing character for the Bracket characters. For example, ')' , ']' </param>
        </member>
        <member name="T:System.Windows.Markup.ConstructorArgumentAttribute">
            <summary>
            Attribute to declare that this associated property can be initialized by a
            constructor parameter and should be ignored for serialization if the constructor
            with an argument of the supplied name is used to construct the instance.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.ConstructorArgumentAttribute.#ctor(System.String)">
            <summary>
            Constructor for an ConstructorArgumentAttribute
            </summary>
            <param name="argumentName">Name of the constructor argument that will initialize this property</param>
        </member>
        <member name="P:System.Windows.Markup.ConstructorArgumentAttribute.ArgumentName">
            <summary>
            Name of the constructor argument that will initialize this property
            </summary>
        </member>
        <member name="T:System.Windows.Markup.ContentPropertyAttribute">
            <summary>
            An attribute that specifies which property the direct content of a XAML
            element should be associated with.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.ContentPropertyAttribute.#ctor">
            <summary>
            Creates a new content property attriubte that indicates that associated
            class does not have a content property attribute. This allows a descendent
            remove an ancestors declaration of a content property attribute.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.ContentPropertyAttribute.#ctor(System.String)">
            <summary>
            Creates a new content property attribute that associates the direct content
            of XAML content with property of the given name
            </summary>
            <param name="name">The property to associate to direct XAML content</param>
        </member>
        <member name="P:System.Windows.Markup.ContentPropertyAttribute.Name">
            <summary>
            The name of the property that is associated with direct XAML content
            </summary>
        </member>
        <member name="T:System.Windows.Markup.ContentWrapperAttribute">
            <summary>
            Can be specified on a collection type to indicate which
            types are used to wrap content foreign content such as
            strings in a strongly type Collection.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.ContentWrapperAttribute.#ctor(System.Type)">
            <summary>
            Declares the given type as being a content wrapper for the collection
            type this attribute is declared on.
            </summary>
            <param name="contentWrapper"></param>
        </member>
        <member name="P:System.Windows.Markup.ContentWrapperAttribute.ContentWrapper">
            <summary>
            The type that is declared as a content wrapper for the collection type
            this attribute is declared on.
            </summary>
        </member>
        <member name="P:System.Windows.Markup.ContentWrapperAttribute.TypeId">
            <summary>
            Override to ensure AttributeCollection perserves all instances
            </summary>
        </member>
        <member name="M:System.Windows.Markup.ContentWrapperAttribute.Equals(System.Object)">
            <summary>
                Overrides Object.Equals to implement correct equality semantics for this
                attribute.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.ContentWrapperAttribute.GetHashCode">
            <summary>
                Overrides Object.GetHashCode to implement correct hashing semantics.
            </summary>
        </member>
        <member name="T:System.Windows.Markup.DependsOnAttribute">
            <summary>
            DependsOnAttribute allows declaring that one property
            depends on the value of another property. The serialization
            system will ensure that the listed property is serialized
            prior to the property that this attribute is set on.
            Care must be taken to avoid circular dependencies. They
            are only detected when writing all the properties in the
            cycle.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.DependsOnAttribute.#ctor(System.String)">
            <summary>
            Constructor for DependsOnAttribute
            </summary>
            <param name="name">The name of the property that the property depends on</param>
        </member>
        <member name="P:System.Windows.Markup.DependsOnAttribute.TypeId">
            <summary>
            Override of Attribute.TypeId
            </summary>
        </member>
        <member name="P:System.Windows.Markup.DependsOnAttribute.Name">
            <summary>
            The name of the property that is declared to depend on
            </summary>
        </member>
        <member name="T:System.Windows.Markup.MarkupExtensionReturnTypeAttribute">
            <summary>
            </summary>
        </member>
        <member name="M:System.Windows.Markup.MarkupExtensionReturnTypeAttribute.#ctor(System.Type)">
            <summary>
            </summary>
        </member>
        <member name="M:System.Windows.Markup.MarkupExtensionReturnTypeAttribute.#ctor">
            <summary>
            </summary>
        </member>
        <member name="P:System.Windows.Markup.MarkupExtensionReturnTypeAttribute.ReturnType">
            <summary>
            </summary>
        </member>
        <member name="T:System.Windows.Markup.RootNamespaceAttribute">
            <summary>
            An attribute that identifies the value of the RootNamespace property in a project file.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.RootNamespaceAttribute.#ctor(System.String)">
            <summary>
            Creates a new RootNamespaceAttribute that describes the value of the RootNamespace
            property in a project file.
            </summary>
            <param name="nameSpace">The root namespace value</param>
        </member>
        <member name="P:System.Windows.Markup.RootNamespaceAttribute.Namespace">
            <summary>
            The root namespace value corresponding to the value of the RootNamespace property in a project file.
            </summary>
        </member>
        <member name="T:System.Windows.Markup.TrimSurroundingWhitespaceAttribute">
            <summary>
            An attribute that specifies that the whitespace surrounding an element should be trimmed
            </summary>
        </member>
        <member name="M:System.Windows.Markup.TrimSurroundingWhitespaceAttribute.#ctor">
            <summary>
            Creates a new trim surrounding whitespace attribute.
            </summary>
        </member>
        <member name="T:System.Windows.Markup.UidPropertyAttribute">
            <summary>
                An attribute that specifies which property the xml:lang value should
            be directed to.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.UidPropertyAttribute.#ctor(System.String)">
            <summary>
                Creates a new UidPropertyAttribute with the given string
            as the property name.
            </summary>
        </member>
        <member name="P:System.Windows.Markup.UidPropertyAttribute.Name">
            <summary>
                The name of the property that is designated to accept the x:Uid value
            </summary>
        </member>
        <member name="T:System.Windows.Markup.WhitespaceSignificantCollectionAttribute">
            <summary>
            An attribute that specifies that a collection considers whitespacing to be significant.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.WhitespaceSignificantCollectionAttribute.#ctor">
            <summary>
            Creates a new content property attriubte that indicates that the associated
            class does consider whitespace to be signifant.
            </summary>
        </member>
        <member name="T:System.Windows.Markup.XmlLangPropertyAttribute">
            <summary>
                An attribute that specifies which property the xml:lang value should
            be directed to.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.XmlLangPropertyAttribute.#ctor(System.String)">
            <summary>
                Creates a new XmlLangPropertyAttribute with the given string
            as the property name.
            </summary>
        </member>
        <member name="P:System.Windows.Markup.XmlLangPropertyAttribute.Name">
            <summary>
                The name of the property that is designated to accept the xml:lang value
            </summary>
        </member>
        <member name="T:System.Windows.Markup.XmlnsCompatibleWithAttribute">
             <summary>

             This attribute allows an assembly to declare that previously published
             XmlnsDefinitions are subsumed by a new version.

             Such as

                "http://schemas.example.com/2003/mynamespace"

             is changed to

                "http://schemas.example.com/2005/mynamespace"

             </summary>
        </member>
        <member name="M:System.Windows.Markup.XmlnsCompatibleWithAttribute.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="oldNamespace">old Xml namespce</param>
            <param name="newNamespace">new xml namespace</param>
        </member>
        <member name="P:System.Windows.Markup.XmlnsCompatibleWithAttribute.OldNamespace">
            <summary>
            Old Xml Namespace
            </summary>
        </member>
        <member name="P:System.Windows.Markup.XmlnsCompatibleWithAttribute.NewNamespace">
            <summary>
            New Xml Namespace
            </summary>
        </member>
        <member name="T:System.Windows.Markup.XmlnsDefinitionAttribute">
             <summary>

             XmlnsDefinitionAttribute keeps a mapping between Xml namespace and CLR namespace in an Assembly.
             The Xml namespace can be used in a Xaml Markup file.


             To find the appropriate types for element and attribute in xaml file, xaml processors MUST
             search each referenced assembly for XmlnsDefinitionAttribute. If the xmlns for element tag
             or attribute matches with the XmlNamespace in this XmlnsDefinitionAttibute, the Xaml processor
             then takes use of the ClrNamespace and AssemblyName stored in this Attibute instance to check
             if the element or attribute matches any type inside this namespace in the Assembly.

             For a WinFX assembly, it can set this attibute like below:

             [assembly:XmlnsDefinition("http://schemas.fabrikam.com/mynamespace", "fabrikam.myproduct.mycategory1")]
             [assembly:XmlnsDefinition("http://schemas.fabrikam.com/mynamespace", "fabrikam.myproduct.mycategory2")]

             [assembly:XmlnsDefinition("xmlnamsspace", "clrnamespace", AssemblyName="myassembly or full assemblyname")]

             If fabrikam.myproduct.mycategory namespace in this assembly contains a UIElement such as "MyButton", the
             xaml file could use it like below:

               Page xmlns:myns="http://schemas.fabrikam.com/mynamespace" ....
                  myns:MyButton ...../myns:MyButton
               /Page

             </summary>
        </member>
        <member name="M:System.Windows.Markup.XmlnsDefinitionAttribute.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="xmlNamespace">
            XmlNamespace used by Markup file
            </param>
            <param name="clrNamespace">
            Clr namespace which contains known types that are used by Markup File.
            </param>
        </member>
        <member name="P:System.Windows.Markup.XmlnsDefinitionAttribute.XmlNamespace">
            <summary>
            XmlNamespace which can be used in Markup file.
            such as XmlNamespace is set to
            "http://schemas.fabrikam.com/mynamespace".

            The markup file can have definition like
            xmlns:myns="http://schemas.fabrikam.com/mynamespace"

            </summary>
        </member>
        <member name="P:System.Windows.Markup.XmlnsDefinitionAttribute.ClrNamespace">
            <summary>
            ClrNamespace which map to XmlNamespace.
            This ClrNamespace should contain some types which are used
            by Xaml markup file.
            </summary>
        </member>
        <member name="P:System.Windows.Markup.XmlnsDefinitionAttribute.AssemblyName">
            <summary>
            The name of Assembly that contains some types inside CLRNamespace.
            If the assemblyName is not set, the code should take the assembly
            for which the instance of this attribute is created.
            </summary>
        </member>
        <member name="T:System.Windows.Markup.XmlnsPrefixAttribute">
             <summary>

             This attribute allows an assembly to recommend a prefix to be used when writing elements and
             attributes in a xaml file.

             For a WinFX assembly, it can set the attributes as follows:

             <code>
             [assembly:XmlnsDefinition("http://schemas.fabrikam.com/mynamespace", "fabrikam.myproduct.mycategory1")]
             [assembly:XmlnsDefinition("http://schemas.fabrikam.com/mynamespace", "fabrikam.myproduct.mycategory2")]
             [assembly:XmlnsPrefix("http://schemas.fabrikam.com/mynamespace", "myns")]
             </code>

             If fabrikam.myproduct.mycategory namespace in this assembly contains a UIElement such as "MyButton", the
             xaml file could use it like below:
               <code>
               &lt;Page xmlns:myns="http://schemas.fabrikam.com/mynamespace" .... &gt;
                  &lt;myns:MyButton&gt; ..... &lt;/myns:MyButton&gt;
               &lt;/Page&gt;
               </code>
             </summary>
        </member>
        <member name="M:System.Windows.Markup.XmlnsPrefixAttribute.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="xmlNamespace">XML namespce</param>
            <param name="prefix">recommended prefix</param>
        </member>
        <member name="P:System.Windows.Markup.XmlnsPrefixAttribute.XmlNamespace">
            <summary>
            XML Namespace
            </summary>
        </member>
        <member name="P:System.Windows.Markup.XmlnsPrefixAttribute.Prefix">
            <summary>
            New Xml Namespace
            </summary>
        </member>
        <member name="T:System.Windows.Markup.DateTimeValueSerializer">
            <summary>
                ValueSerializer for DateTime.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.DateTimeValueSerializer.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:System.ComponentModel.DateTimeConverter"></see> class.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.DateTimeValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)">
            <summary>
                Indicate that we do convert DateTime's from string.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.DateTimeValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)">
            <summary>
                Indicate that we do convert a DateTime to string.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.DateTimeValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)">
            <summary>
                Converts the given value object to a <see cref="T:System.DateTime"></see>.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.DateTimeValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)">
            <summary>
                Converts the given value object to a <see cref="T:System.DateTime"></see> using the arguments.
            </summary>
        </member>
        <member name="T:System.Windows.Markup.INameScope">
            <summary>
            INameScope- Defines the basic Name Scoping interface for root classes
            </summary>

        </member>
        <member name="M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)">
            <summary>
            Registers the name - element combination
            </summary>
            <param name="name">Name of the element</param>
            <param name="scopedElement">Element where name is defined</param>
        </member>
        <member name="M:System.Windows.Markup.INameScope.UnregisterName(System.String)">
            <summary>
            Unregisters the name - element combination
            </summary>
            <param name="name">Name of the element</param>
        </member>
        <member name="M:System.Windows.Markup.INameScope.FindName(System.String)">
            <summary>
            Find the element given name
            </summary>
        </member>
        <member name="T:System.Windows.Markup.IProvideValueTarget">
            <summary>
            This interface is used for MarkupExtension's to indicate
            in the ProvideValue method the object and property to which
            this value will be set.  The TargetObject and TargetProperty
            values may be null.
            </summary>
        </member>
        <member name="P:System.Windows.Markup.IProvideValueTarget.TargetObject">
            <summary>
            </summary>
        </member>
        <member name="P:System.Windows.Markup.IProvideValueTarget.TargetProperty">
            <summary>
            </summary>
        </member>
        <member name="T:System.Windows.Markup.IUriContext">
            <summary>
                 The IUriContext interface allows elements (like Frame, PageViewer) and type converters
                 (like BitmapImage TypeConverters) a way to ensure that base uri is set on them by the
                 parser, codegen for xaml, baml and caml cases.  The elements can then use this base uri
                 to navigate.
            </summary>
        </member>
        <member name="P:System.Windows.Markup.IUriContext.BaseUri">
            <summary>
                Provides the base uri of the current context.
            </summary>
        </member>
        <member name="T:System.Windows.Markup.IValueSerializerContext">
            <summary>
            Context provided to ValueSerializer that can be used to special case serialization for different users of the
            ValueSerializaer or for modes of serialization.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor(System.Type)">
            <summary>
            Get the value serializer associated with the given type.
            </summary>
            <param name="type">The type of the value that is to be convert</param>
            <returns>A value serializer for capable of serializing the given type</returns>
        </member>
        <member name="M:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor(System.ComponentModel.PropertyDescriptor)">
            <summary>
            Get a value serializer for the given property descriptor. A property can override the value serializer that
            is to be used to serialize the property by specifing either a ValueSerializerAttribute or a
            TypeConverterAttribute. This method takes these attributes into account when determining the value
            serializer.
            </summary>
            <param name="descriptor">The property descriptor for whose property value is being converted</param>
            <returns>A value serializer capable of serializing the given property</returns>
        </member>
        <member name="T:System.Windows.Markup.IXamlTypeResolver">
            <summary>
            Provides services to help resolve nsPrefix:LocalName into the appropriate Type.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.IXamlTypeResolver.Resolve(System.String)">
            <summary>
            Resolves nsPrefix:LocalName into the appropriate Type.
            </summary>
            <param name="qualifiedTypeName">TypeName that appears in Xaml - nsPrefix:LocalName or LocalName.</param>
            <returns>
             The type that the qualifiedTypeName represents.
            </returns>
        </member>
        <member name="T:System.Windows.Markup.ValueSerializer">
            <summary>
            ValueSerializer allows a type to declare a serializer to control how the type is serializer to and from string
            If a TypeConverter is declared for a type that converts to and from a string, a default value serializer will
            be created for the type. The string values must be loss-less (i.e. converting to and from a string doesn't loose
            data) and must be stable (i.e. returns the same string for the same value). If a type converter doesn't  meet
            these requirements, a custom ValueSerializer must be declared that meet the requirements or associate a null
            ValueSerializer with the type to indicate the type converter should be ignored. Implementation of ValueSerializer
            should avoid throwing exceptions. Any exceptions thrown could possibly terminate serialization.
            </summary>

        </member>
        <member name="M:System.Windows.Markup.ValueSerializer.#ctor">
            <summary>
            Constructor for a ValueSerializer
            </summary>
        </member>
        <member name="M:System.Windows.Markup.ValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)">
            <summary>
            Returns true if the given value can be converted to a string.
            </summary>
            <param name="value">Value to convert</param>
            <param name="context">Context information</param>
            <returns>Whether or not the value can be converted to a string</returns>
        </member>
        <member name="M:System.Windows.Markup.ValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)">
            <summary>
            Returns true if the given value can be converted from a string.
            </summary>
            <param name="value">The string to convert</param>
            <param name="context">Context information</param>
            <returns>Whether or not the value can be converted from a string</returns>
        </member>
        <member name="M:System.Windows.Markup.ValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)">
            <summary>
            Converts the given value to a string for use in serialization. This method should only be
            called if CanConvertToString returns true for the given value.
            </summary>
            <param name="value">The value to convert to a string</param>
            <param name="context">Context information</param>
            <returns>A string representation of value</returns>
        </member>
        <member name="M:System.Windows.Markup.ValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)">
            <summary>
            Convert a string to an object. This method should only be called if CanConvertFromString
            returns true for the given string.
            </summary>
            <param name="value">The string value to convert</param>
            <param name="context">Context information</param>
            <returns>An object corresponding to the string value</returns>
        </member>
        <member name="M:System.Windows.Markup.ValueSerializer.TypeReferences(System.Object,System.Windows.Markup.IValueSerializerContext)">
            <summary>
            Returns an enumeration of the types referenced by the value serializer. If the value serializer asks for
            a value serializer for System.Type, any types it asks to convert should be supplied in the returned
            enumeration. This allows a serializer to ensure a de-serializer has enough information about the types
            this serializer converts.

            Since a value serializer doesn't exist by default, it is important the value serializer be requested from
            the IValueSerializerContext, not ValueSerializer.GetSerializerFor. This allows a serializer to encode
            context information (such as xmlns definitions) to the System.Type converter (for example, which prefix
            to generate).
            </summary>
            <param name="value">The value being serialized</param>
            <param name="context">Context information</param>
            <returns>An enumeration of the types converted by this serializer</returns>
        </member>
        <member name="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)">
            <summary>
            Get the value serializer declared for the given type.
            </summary>
            <param name="type">The value type to serialize</param>
            <returns>The value serializer associated with the given type</returns>
        </member>
        <member name="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor)">
            <summary>
            Get the value serializer declared for the given property. ValueSerializer can be overriden by an attribute
            on the property declaration.
            </summary>
            <param name="descriptor">PropertyDescriptor for the property to be serialized</param>
            <returns>A value serializer associated with the given property</returns>
        </member>
        <member name="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type,System.Windows.Markup.IValueSerializerContext)">
            <summary>
            Get the value serializer declared for the given type. This version should be called whenever the caller
            has a IValueSerializerContext to ensure that the correct value serializer is returned for the given
            context.
            </summary>
            <param name="type">The value type to serialize</param>
            <param name="context">Context information</param>
            <returns>The value serializer associated with the given type</returns>
        </member>
        <member name="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor,System.Windows.Markup.IValueSerializerContext)">
            <summary>
            Get the value serializer declared for the given property. ValueSerializer can be overriden by an attribute
            on the property declaration. This version should be called whenever the caller has a
            IValueSerializerContext to ensure that the correct value serializer is returned for the given context.
            </summary>
            <param name="descriptor">PropertyDescriptor for the property to be serialized</param>
            <param name="context">Context information</param>
            <returns>A value serializer associated with the given property</returns>
        </member>
        <member name="M:System.Windows.Markup.ValueSerializer.GetConvertToException(System.Object,System.Type)">
            <summary>
            Return a exception to throw if the value cannot be converted
            </summary>
        </member>
        <member name="M:System.Windows.Markup.ValueSerializer.GetConvertFromException(System.Object)">
            <summary>
            Return a exception to throw if the string cannot be converted
            </summary>
        </member>
        <member name="T:System.Windows.Markup.MarkupExtension">
            <summary>
             Base class for all Xaml markup extensions.  Only subclasses can
             be instantiated.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.MarkupExtension.ProvideValue(System.IServiceProvider)">
            <summary>
             Return an object that should be set on the targetObject's targetProperty
             for this markup extension.
            </summary>
            <param name="serviceProvider">Object that can provide services for the markup extension.</param>
            <returns>
             The object to set on this property.
            </returns>
        </member>
        <member name="T:System.Windows.Markup.ArrayExtension">
            <summary>
             Class for Xaml markup extension for Arrays.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.ArrayExtension.#ctor">
            <summary>
             Constructor that takes no parameters.  This creates an empty array.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.ArrayExtension.#ctor(System.Type)">
            <summary>
             Constructor that takes one parameter.  This initializes the type of the array.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.ArrayExtension.#ctor(System.Array)">
            <summary>
            Constructor for writing
            </summary>
            <param name="elements">The array to write</param>
        </member>
        <member name="M:System.Windows.Markup.ArrayExtension.AddChild(System.Object)">
            <summary>
             Called to Add an object as a new array item.  This will append the object to the end
             of the array.
            </summary>
            <param name="value">
             Object to add to the end of the array.
            </param>
        </member>
        <member name="M:System.Windows.Markup.ArrayExtension.AddText(System.String)">
            <summary>
             Called to Add a text as a new array item.  This will append the object to the end
             of the array.
            </summary>
            <param name="text">
             Text to Add to the end of the array
            </param>
        </member>
        <member name="P:System.Windows.Markup.ArrayExtension.Type">
            <summary>
             Get and set the type of array to be created when calling ProvideValue
            </summary>
        </member>
        <member name="P:System.Windows.Markup.ArrayExtension.Items">
            <summary>
            An IList accessor to the contents of the array
            </summary>
        </member>
        <member name="M:System.Windows.Markup.ArrayExtension.ProvideValue(System.IServiceProvider)">
            <summary>
             Return an array that is sized to the number of objects added to the ArrayExtension.
            </summary>
            <param name="serviceProvider">Object that can provide services for the markup extension.</param>
            <returns>
             The Array containing all the objects added to this extension.
            </returns>
        </member>
        <member name="T:System.Windows.Markup.IComponentConnector">
            <summary>
            Provides methods used internally by the BamlReader
            on compiled content.
            </summary>

        </member>
        <member name="M:System.Windows.Markup.IComponentConnector.Connect(System.Int32,System.Object)">
            <summary>
            Called by the BamlReader to attach events and Names on compiled content.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.IComponentConnector.InitializeComponent">
            <summary>
            Called by a component to load its compiled content.
            </summary>
        </member>
        <member name="T:System.Windows.Markup.NullExtension">
            <summary>
             Class for Xaml markup extension for Null.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.NullExtension.#ctor">
            <summary>
             Default constructor
            </summary>
        </member>
        <member name="M:System.Windows.Markup.NullExtension.ProvideValue(System.IServiceProvider)">
            <summary>
             Return an object that should be set on the targetObject's targetProperty
             for this markup extension.  In this case it is simply null.
            </summary>
            <param name="serviceProvider">Object that can provide services for the markup extension.</param>
            <returns>
             The object to set on this property.
            </returns>
        </member>
        <member name="T:System.Windows.Markup.StaticExtension">
            <summary>
             Class for Xaml markup extension for static field and property references.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.StaticExtension.#ctor">
            <summary>
             Constructor that takes no parameters
            </summary>
        </member>
        <member name="M:System.Windows.Markup.StaticExtension.#ctor(System.String)">
            <summary>
             Constructor that takes the member that this is a static reference to.
             This string is of the format
                Prefix:ClassName.FieldOrPropertyName.  The Prefix is
             optional, and refers to the XML prefix in a Xaml file.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.StaticExtension.ProvideValue(System.IServiceProvider)">
            <summary>
             Return an object that should be set on the targetObject's targetProperty
             for this markup extension.  For a StaticExtension this is a static field
             or property value.
            </summary>
            <param name="serviceProvider">Object that can provide services for the markup extension.</param>
            <returns>
             The object to set on this property.
            </returns>
        </member>
        <member name="P:System.Windows.Markup.StaticExtension.Member">
            <summary>
             The static field or property represented by a string.  This string is
             of the format Prefix:ClassName.FieldOrPropertyName.  The Prefix is
             optional, and refers to the XML prefix in a Xaml file.
            </summary>
        </member>
        <member name="T:System.Windows.Markup.TypeExtension">
            <summary>
             Class for Xaml markup extension for a Type reference.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.TypeExtension.#ctor">
            <summary>
             Default Constructor
            </summary>
        </member>
        <member name="M:System.Windows.Markup.TypeExtension.#ctor(System.String)">
            <summary>
             Constructor that takes a type name
            </summary>
        </member>
        <member name="M:System.Windows.Markup.TypeExtension.#ctor(System.Type)">
            <summary>
            Constructor that takes a type
            </summary>
        </member>
        <member name="M:System.Windows.Markup.TypeExtension.ProvideValue(System.IServiceProvider)">
            <summary>
             Return an object that should be set on the targetObject's targetProperty
             for this markup extension.  TypeExtension resolves a string into a Type
             and returns it.
            </summary>
            <param name="serviceProvider">Object that can provide services for the markup extension.</param>
            <returns>
             The object to set on this property.
            </returns>
        </member>
        <member name="P:System.Windows.Markup.TypeExtension.TypeName">
            <summary>
             The typename represented by this markup extension.  The name has the format
             Prefix:Typename, where Prefix is the xml namespace prefix for this type.
            </summary>
        </member>
        <member name="P:System.Windows.Markup.TypeExtension.Type">
            <summary>
             The type represented by this markup extension.
            </summary>
        </member>
        <member name="M:System.Windows.Markup.StaticExtensionConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <SecurityNote>
                 Critical: calls InstanceDescriptor ctor which LinkDemands
                 TreatAsSafe: can only make an InstanceDescriptor for StaticExtension, not an arbitrary class
            </SecurityNote>
        </member>
        <member name="M:System.Windows.Markup.TypeExtensionConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <SecurityNote>
                 Critical: calls InstanceDescriptor ctor which LinkDemands
                 TreatAsSafe: can only make an InstanceDescriptor for TypeExtension, not an arbitrary class
            </SecurityNote>
        </member>
        <member name="T:System.Windows.Markup.RuntimeNamePropertyAttribute">
            <summary>
            This attribute is placed on a class to identify the property that will
            function as an Name for the given class
            </summary>
        </member>
        <member name="M:System.Windows.Markup.RuntimeNamePropertyAttribute.#ctor(System.String)">
            <summary/>
        </member>
        <member name="P:System.Windows.Markup.RuntimeNamePropertyAttribute.Name">
            <summary>
            The Name of the property in the class that will contain the ID of
            the class, this property needs to be of type string and have
            both get and set access
            </summary>
        </member>
        <member name="M:System.Windows.Markup.DateTimeOffsetConverter2.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <SecurityNote>
            Critical: Uses InstanceDescriptor, which LinkDemands
            Safe: InstanceDescriptor for DateTimeOffset doesn't contain any private data.
                  Also, the Descriptor is returned intact to the caller, who would need to satisfy a LinkDemand to do anything with it.
            </SecurityNote>
        </member>
        <member name="T:System.Xaml.TypeConverterHelper">
            <summary>
            Class that provides fucntionality to obtain a TypeConverter from a property or the
            type of the property, based on logic similar to TypeDescriptor.GetConverter.
            </summary>
        </member>
        <member name="M:System.Xaml.TypeConverterHelper.GetTypeConverter(System.Type)">
            <summary>
            Returns a TypeConverter for the given target Type, otherwise null if not found.
            First, if the type is one of the known system types, it lookups a table to determine the TypeConverter.
            Next, it tries to find a TypeConverterAttribute on the type using reflection.
            Finally, it looks up the table of known typeConverters again if the given type derives from one of the
            known system types.
            </summary>
            <param name="type">The target Type for which to find a TypeConverter.</param>
            <returns>A TypeConverter for the Type type if found. Null otherwise.</returns>
        </member>
        <member name="T:System.Xaml.ReflectionHelper">
            <summary>
            Class that provides helper functions for the parser to reflect on types, properties,
            custom attributes and load assemblies.
            </summary>
        </member>
        <member name="M:System.Xaml.ReflectionHelper.GetQualifiedType(System.String)">
            <summary>
            Parse and get the type of the passed in string
            </summary>
        </member>
        <member name="M:System.Xaml.ReflectionHelper.IsPublicType(System.Type)">
            <summary>
            Helper for determine if the type is a public class.
            </summary>
            <param name="type">Type to check</param>
            <returns>True if type is public</returns>
        </member>
        <member name="M:System.Xaml.SafeSecurityHelper.GetLoadedAssembly(System.Reflection.AssemblyName)">
             <summary>
                 This function iterates through the assemblies loaded in the current
                 AppDomain and finds one that has the same assembly name passed in.
             </summary>
             <SecurityNote>
                 The method is being kept in this class to ease auditing and
                 should have a security review if changed.

                 WARNING! Don't use this method for retrievals of assemblies that
                          should rely on a strong match with the given assembly name
                          since this method allows assemblies with the same short name
                          to be returned even when other name parts are different.

                    E.g.  FooBar
                 matches  FooBar, Version=2.0.0.0, Culture=en-us, PublicKeyToken=b03f5f7f11d50a3a
             </SecurityNote>
        </member>
        <member name="T:System.Xaml.NameScope">
            <summary>
            Used to store mapping information for names occuring
            within the logical tree section.
            </summary>
        </member>
        <member name="M:System.Xaml.NameScope.RegisterName(System.String,System.Object)">
            <summary>
            Register Name-Object Map
            </summary>
            <param name="name">name to be registered</param>
            <param name="scopedElement">object mapped to name</param>
        </member>
        <member name="M:System.Xaml.NameScope.UnregisterName(System.String)">
            <summary>
            Unregister Name-Object Map
            </summary>
            <param name="name">name to be registered</param>
        </member>
        <member name="M:System.Xaml.NameScope.FindName(System.String)">
            <summary>
            Find - Find the corresponding object given a Name
            </summary>
            <param name="name">Name for which context needs to be retrieved</param>
            <returns>corresponding Context if found, else null</returns>
        </member>
        <member name="T:System.Xaml.NameValidationHelper">
            <summary>
                The string used in RuntimeNameProperty is expected to follow certain
            rules.  IsValidIdentifierName checks the given string against the rules.
            NameValidationCallback extends to all object types and is in the right
            format to be used as a DependencyProperty ValidateValueCallback
            </summary>
        </member>
        <member name="M:System.Xaml.NameValidationHelper.IsValidIdentifierName(System.String)">
            <summary>
            Validates the name to follow Naming guidelines
            </summary>
            <param name="name">string to validate</param>
        </member>
        <member name="F:System.Xaml.Schema.MemberReflector._getter">
            <SecurityNote>
            Critical: We cache visibility check based on this member, so it must be idempotent
            </SecurityNote>
        </member>
        <member name="F:System.Xaml.Schema.MemberReflector._setter">
            <SecurityNote>
            Critical: We cache visibility check based on this member, so it must be idempotent
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.MemberReflector.#ctor(System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Boolean)">
            <SecurityNote>
            Critical: Accesses critical fields _getter and _setter
            Safe: Constructor is single-threaded, so idempotence is preserved
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.MemberReflector.#ctor(System.Xaml.XamlType,System.Xaml.Schema.XamlValueConverter{System.ComponentModel.TypeConverter})">
            <summary>Ctor used by directives</summary>
             <SecurityNote>
             Critical: Accesses critical fields _getter and _setter
             Safe: Constructor is single-threaded, so idempotence is preserved
             </SecurityNote>
        </member>
        <member name="P:System.Xaml.Schema.MemberReflector.UnknownReflector">
            <SecurityNote>
            Critical: Accesses critical fields _getter and _setter
            Safe: We set to constant value of null, so idempotence is preserved
            </SecurityNote>
        </member>
        <member name="P:System.Xaml.Schema.MemberReflector.Getter">
            <SecurityNote>
            Critical: Accesses critical field _getter
            Safe: Maintains idempotence via NullableReference.SetIfNull, which uses CompareExchange
            </SecurityNote>
        </member>
        <member name="P:System.Xaml.Schema.MemberReflector.GetterIsSet">
            <SecurityNote>
            Critical: Accesses critical field _getter
            Safe: Doesn't modify field
            </SecurityNote>
        </member>
        <member name="P:System.Xaml.Schema.MemberReflector.Setter">
            <SecurityNote>
            Critical: Accesses critical field _setter
            Safe: Maintains idempotence via NullableReference.SetIfNull, which uses CompareExchange
            </SecurityNote>
        </member>
        <member name="P:System.Xaml.Schema.MemberReflector.SetterIsSet">
            <SecurityNote>
            Critical: Accesses critical field _setter
            Safe: Doesn't modify field
            </SecurityNote>
        </member>
        <member name="T:System.Xaml.Schema.SafeReflectionInvoker">
             <SecurityNote>
             All invocation of user-provided reflection objects inside System.Xaml should be routed through this class.

             Invoking a reflection object directly from this class (or any class in System.Xaml)
             could potentially expose internal types or methods in System.Xaml, because
             mscorlib sees the invocation as coming from System.Xaml.  Instead, we do
             the invocation from a dynamic assembly created for this purpose.  Because
             the wrapper methods live in a separate assembly (with no internals) and are
             marked as security-transparent, the security checks in mscorlib will treat
             attempts to use internals of System.xaml the same as it treats attempts to
             use internals of any other assembly; i.e. the caller (that is, the user's
             application) must have the appropriate permissions.

             This class exposes proxy methods for each of the reflection methods we need.
             The static constructor creates the dynamic assembly and populates it with
             the wrapper methods that actually call into reflection code.  The proxy
             methods in this class merely call the corresponding dynamic wrapper methods.

             The dynamic assembly technique turns out to have perf implications - it loads
             parts of mscorlib and clr that are otherwise unneeded (for Reflection.Emit et al.),
             and requires JIT compilation of the resulting IL.  We don't need the elaborate
             techinique in full-trust scenarios (a malicious full-trust app can already
             invoke internals just by calling reflection directly).  So in full-trust we
             use the old code.
             </SecurityNote>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Xaml.Schema.SafeReflectionInvoker.UseDynamicAssembly" -->
        <!-- Badly formed XML comment ignored for member "M:System.Xaml.Schema.SafeReflectionInvoker.CreateDynamicAssembly" -->
        <member name="F:System.Xaml.Schema.SafeReflectionInvoker.s_reflectionMemberAccess">
            <SecurityNote>
            Demanded to allow instantiation of System.Xaml internals
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.SafeReflectionInvoker.IsInSystemXaml(System.Type)">
            <SecurityNote>
            Critical: Used to detect luring attack described in class-level comments.
            Safe: Gets the information from reflection.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.SafeReflectionInvoker.CreateDelegate(System.Type,System.Type,System.String)">
            <SecurityNote>
            Critical: See class-level comment
            Safe: See class-level comment
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.SafeReflectionInvoker.CreateDelegateCritical(System.Type,System.Type,System.String)">
            <SecurityNote>
            This method doesn't do security checks, it should be treated as critical.
            The reason it's not marked as critical is so that it doesn't satisfy a SecurityCritical
            requirement on the target method.
            The reason it's marked NoInlining|NoOptimization is so that the call
            isn't optimized back into a critical caller.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.SafeReflectionInvoker.CreateDelegate(System.Type,System.Object,System.String)">
            <SecurityNote>
            Critical: See class-level comment
            Safe: See class-level comment
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.SafeReflectionInvoker.CreateDelegateCritical(System.Type,System.Object,System.String)">
            <SecurityNote>
            This method doesn't do security checks, it should be treated as critical.
            The reason it's not marked as critical is so that it doesn't satisfy a SecurityCritical
            requirement on the target method.
            The reason it's marked NoInlining|NoOptimization is so that the call
            isn't optimized back into a critical caller.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.SafeReflectionInvoker.CreateInstance(System.Type,System.Object[])">
            <SecurityNote>
            Critical: See class-level comment
            Safe: See class-level comment. Note that this checks the UnderlyingSystemType,
                  which is what is actually created by Activator.CreateInstance.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.SafeReflectionInvoker.CreateInstanceCritical(System.Type,System.Object[])">
            <SecurityNote>
            This method doesn't do security checks, it should be treated as critical.
            The reason it's not marked as critical is so that it doesn't satisfy a SecurityCritical
            requirement on the target of the invocation.
            The reason it's marked NoInlining|NoOptimization is so that the call
            isn't optimized back into a critical caller.
            CLR is currently planning a change to turn all reflection invocation of SecurityCritical
            members into demands for full trust; if that change goes through, then this method will
            become unnecessary.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.SafeReflectionInvoker.DemandMemberAccessPermission">
            <SecurityNote>
            Critical: Sets critical field s_reflectionMemberAccess
            Safe: Sets the field to a known good value
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.SafeReflectionInvoker.InvokeMethod(System.Reflection.MethodInfo,System.Object,System.Object[])">
            <SecurityNote>
            Critical: See class-level comment
            Safe: See class-level comment
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.SafeReflectionInvoker.InvokeMethodCritical(System.Reflection.MethodInfo,System.Object,System.Object[])">
            <SecurityNote>
            This method doesn't do security checks, it should be treated as critical.
            The reason it's not marked as critical is so that it doesn't satisfy a SecurityCritical
            requirement on the target of the invocation.
            The reason it's marked NoInlining|NoOptimization is so that the call
            isn't optimized back into a critical caller.
            CLR is currently planning a change to turn all reflection invocation of SecurityCritical
            members into demands for full trust; if that change goes through, then this method will
            become unnecessary.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.SafeReflectionInvoker.IsSystemXamlNonPublic(System.Reflection.MethodInfo)">
            <SecurityNote>
            Critical: Used to detect luring attack described in class-level comments.
            Safe: Gets the information from reflection.
                  The MethodInfo (and MemberInfo) have an InheritanceDemand so derived class
                  spoofing in PT is not an issue.
            Note: The [SecurityCritical] attribute isn't functionally necessary but flags the
                  method as security critical and changes should be reviewed.
            </SecurityNote>
        </member>
        <member name="T:System.Xaml.Schema.XamlMemberInvoker">
            <SecurityNote>
            This class makes the assumption that any internal ShouldSerialize methods in System.Xaml are safe
            for public invocation. If this becomes untrue, then ShouldSerializeValue needs an IsSystemXamlNonPublic
            check, just like GetValue and SetValue have.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.XamlMemberInvoker.GetValueSafeCritical(System.Object)">
            <SecurityNote>
            Critical: See explanation in SafeReflectionInvoker
            Safe: See explanation in SafeReflectionInvoker.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.XamlMemberInvoker.SetValueSafeCritical(System.Object,System.Object)">
            <SecurityNote>
            Critical: See explanation in SafeReflectionInvoker
            Safe: See explanation in SafeReflectionInvoker.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.XamlMemberInvoker.IsSystemXamlNonPublic(System.Xaml.ThreeValuedBool@,System.Reflection.MethodInfo)">
            <SecurityNote>
            Critical: Sets critical fields _getterIsSystemXamlNonPublic and _setterIsSystemXamlNonPublic
            Safe: Gets the result from SafeCritical method SafeReflectionInvoker.IsSystemXamlNonPublic.
                  The MethodInfo we're checking is exactly the one we're invoking, so even if the
                  MethodInfo lies about its visibility, there is no harm.
            Note: The [SecurityCritical] attribute isn't functionally necessary but flags the
                  method as security critical and changes should be reviewed.
            </SecurityNote>
        </member>
        <member name="T:System.Xaml.Schema.XamlTypeInvoker">
            <SecurityNote>
            This class uses SafeReflectionInvoker to invoke all user-supplied methods
            and constructors, including the "add methods" for collections.   Normally
            these are merely public methods from standard interfaces like IList, but
            they can be spoofed by a derived class that overrides GetAddMethod.
            </SecurityNote>
        </member>
        <member name="F:System.Xaml.Schema.XamlTypeInvoker._constructorDelegate">
            <SecurityNote>
            Critical: Used in combination with GetUninitializedObject to ensure that the object
                      is initialized.
                      Can be used to instantiate object bypassing ctor access checks.
            </SecurityNote>
        </member>
        <member name="F:System.Xaml.Schema.XamlTypeInvoker._isPublic">
            <SecurityNote>
            Critical: Used to determine whether it's safe to instantiate this object via _constructorDelegate,
                      and thus bypass security checks.
            </SecurityNote>
        </member>
        <member name="F:System.Xaml.Schema.XamlTypeInvoker._isInSystemXaml">
            <SecurityNote>
            Critical: Used to determine whether we need to demand ReflectionPermission before instantiating this type
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.XamlTypeInvoker.GetAddMethod(System.Xaml.XamlType)">
            <SecurityNote>
            Because this is a public virtual method, idempotence cannot be guaranteed.
            S.X doesn't use this method at all; but any externals consumers who are doing security checks
            based on the returned method should make sure that they are resillient to changing results.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.XamlTypeInvoker.GetEnumeratorMethod">
            <SecurityNote>
            Because this is a public virtual method, idempotence cannot be guaranteed.
            S.X doesn't use this method at all; but any externals consumers who are doing security checks
            based on the returned method should make sure that they are resillient to changing results.
            </SecurityNote>
        </member>
        <member name="P:System.Xaml.Schema.XamlTypeInvoker.IsInSystemXaml">
            <SecurityNote>
            Critical: Sets critical field _isInSystemXaml
            Safe: Gets the result from SafeCritical SafeReflectionInvoker.IsInSystemXaml.
                  Uses the type's UnderlyingSystemType, which is what's actually created by Activator.CreateInstance.
            </SecurityNote>
        </member>
        <member name="P:System.Xaml.Schema.XamlTypeInvoker.IsPublic">
            <SecurityNote>
            Critical: Sets critical field _isPublic
            Safe: Gets the result from SafeCritical method TypeReflector.IsPublic.
                  Uses the type's UnderlyingSystemType, which is what's actually created by Activator.CreateInstance.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.XamlTypeInvoker.CreateInstanceWithActivator(System.Type,System.Object[])">
            <SecurityNote>
            Critical: See explanation in SafeReflectionInvoker.
            Safe: See explanation in SafeReflectionInvoker.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.XamlTypeInvoker.DefaultCtorXamlActivator.CallCtorDelegate(System.Xaml.Schema.XamlTypeInvoker)">
            <SecurityNote>
            Critical: Calls critical method FormatterServices.GetUninitializedObject
            Safe: Never leaks the uninitialized object, always calls constructor first.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.XamlTypeInvoker.DefaultCtorXamlActivator.InvokeDelegate(System.Action{System.Object},System.Object)">
            <SecurityNote>
            Must NOT be critical: we don't want to accidentally satisfy SecurityCritical or
            LinkDemand from the target of the invocation.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.Schema.XamlTypeInvoker.DefaultCtorXamlActivator.EnsureConstructorDelegate(System.Xaml.Schema.XamlTypeInvoker)">
            <SecurityNote>
            Critical: sets critical field XamlType.ConstructorDelegate
            Safe: gets the value from reflection. Doesn't set it if it's non-public
                  (so it can't be accidentally reused on a partial-trust callstack).
            </SecurityNote>
        </member>
        <member name="T:System.Xaml.XamlReaderSettings">
            <SecurityNote>
            The LocalAssembly and AllowProtectedMembersOnRoot properties are not SecurityCritical.
            XamlXmlReader uses these properties to surface non-public members in the nodestream, but it
            does not actually enable invocation of those members.
            XamlObjectReader invokes the non-public members, but does so transparently.
            Any component which allows invocation of non-public members in partial trust should demand
            an appropriate permission (such as ReflectionPerission or XamlLoadPermisison).
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.XamlObjectWriter.GetKeyFromInstance(System.Object,System.Xaml.XamlType,MS.Internal.Xaml.Runtime.IAddLineInfo)">
            <summary>
            Gets the Key alias property when x:Key is not present.
            </summary>
        </member>
        <member name="M:System.Xaml.XamlObjectWriter.Logic_AssignProvidedValue(MS.Internal.Xaml.Context.ObjectWriterContext)">
            <summary>
            Process the call to a MarkupExtension.ProvideValue() and assign the result
            </summary>
        </member>
        <member name="M:System.Xaml.XamlObjectWriter.Logic_WillParentCollectionAdd(MS.Internal.Xaml.Context.ObjectWriterContext,System.Type,System.Boolean)">
            <summary>
             Returns true when the item type of the collection is assignable from
             the given type. Normally we wouldn't call this (Let the CLR check and
             throw if the item doesn't fit)  but for Markup Extensions we check this
             Before calling ProvideValue();
            </summary>
            <param name="ctx">The context</param>
            <param name="type">The type of the new item</param>
            <param name="excludeObjectType">return false if collection Item Type is Object</param>
            <returns></returns>
        </member>
        <member name="P:System.Xaml.XamlObjectWriterSettings.SourceBamlUri">
            <summary>
            SourceBamlUri will be used by XamlObjectWriter in BeginInitHandler's SourceBamlUri property, in place of the actual BaseUri.
            This is only useful to give the correct info in that handler, while keeping runtime behavior fully compatible.
            </summary>
        </member>
        <member name="P:System.Xaml.IXamlNameResolver.IsFixupTokenAvailable">
            <summary>
            Returns true if GetFixupToken is implemented and will return a non-null token
            when called at this time.  For example GetFixupToken will not return a token
            when the Type Converter or Markup Extension is called for the second reparse.
            </summary>
        </member>
        <member name="M:System.Xaml.IXamlNameResolver.Resolve(System.String)">
            <summary>
            Returns a reference to the named object.
            </summary>
            <param name="name">name of object</param>
            <returns></returns>
        </member>
        <member name="M:System.Xaml.IXamlNameResolver.Resolve(System.String,System.Boolean@)">
            <summary>
            Returns a reference to the named object.
            </summary>
            <param name="name">name of object</param>
            <param name="isFullyInitialized">whether or not the object has any dependencies on unresolved references</param>
            <returns></returns>
        </member>
        <member name="M:System.Xaml.IXamlNameResolver.GetFixupToken(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a token for a Type Converter or Markup Extension to return when called
            from the System, for the currently unresolvable names.  When all the forward
            referenced names are resolvable the user code will be called back for a "reparse".
            </summary>
            <param name="names">currently unresolvable names</param>
            <returns></returns>
        </member>
        <member name="M:System.Xaml.IXamlNameResolver.GetFixupToken(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Creates a token for a Type Converter or Markup Extension to return when called
            from the System, for the currently unresolvable names.  When all the forward
            referenced names are resolvable the user code will be called back for a "reparse".
            </summary>
            <param name="names">currently unresolvable (forward reference) names</param>
            <param name="canAssignDirectly">If true, do not call the user code for a reparse,
            instead immediately assign the resolved name reference to the target property</param>
            <returns></returns>
        </member>
        <member name="P:System.Xaml.MS.Impl.FrugalListBase`1.Count">
            <summary>
            Number of entries in this store
            </summary>
        </member>
        <member name="P:System.Xaml.MS.Impl.FrugalListBase`1.Capacity">
            <summary>
            Capacity of this store
            </summary>
        </member>
        <member name="M:System.Xaml.MS.Impl.FrugalListBase`1.Clear">
            <summary>
            Removes all values from the store
            </summary>
        </member>
        <member name="M:System.Xaml.MS.Impl.FrugalListBase`1.Contains(`0)">
            <summary>
            Returns true if the store contains the entry.
            </summary>
        </member>
        <member name="M:System.Xaml.MS.Impl.FrugalListBase`1.IndexOf(`0)">
            <summary>
            Returns the index into the store that contains the item.
            -1 is returned if the item is not in the store.
            </summary>
        </member>
        <member name="M:System.Xaml.MS.Impl.FrugalListBase`1.Insert(System.Int32,`0)">
            <summary>
            Insert item into the store at index, grows if needed
            </summary>
        </member>
        <member name="M:System.Xaml.MS.Impl.FrugalListBase`1.Remove(`0)">
            <summary>
            Removes the item from the store. If the item was not
            in the store false is returned.
            </summary>
        </member>
        <member name="M:System.Xaml.MS.Impl.FrugalListBase`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item from the store
            </summary>
        </member>
        <member name="M:System.Xaml.MS.Impl.FrugalListBase`1.EntryAt(System.Int32)">
            <summary>
            Return the item at index in the store
            </summary>
        </member>
        <member name="M:System.Xaml.MS.Impl.FrugalListBase`1.Promote(System.Xaml.MS.Impl.FrugalListBase{`0})">
            <summary>
            Promotes the values in the current store to the next larger
            and more complex storage model.
            </summary>
        </member>
        <member name="M:System.Xaml.MS.Impl.FrugalListBase`1.ToArray">
            <summary>
            Returns the entries as an array
            </summary>
        </member>
        <member name="M:System.Xaml.MS.Impl.FrugalListBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the entries to the given array starting at the
            specified index
            </summary>
        </member>
        <member name="M:System.Xaml.MS.Impl.FrugalListBase`1.Clone">
            <summary>
            Creates a shallow copy of the  list
            </summary>
        </member>
        <member name="T:System.Xaml.MS.Impl.SingleItemList`1">
            <summary>
            A simple class to handle a single item
            </summary>
        </member>
        <member name="T:System.Xaml.MS.Impl.ThreeItemList`1">
            <summary>
            A simple class to handle a list with 3 items.  Perf analysis showed
            that this yielded better memory locality and perf than an object and an array.
            </summary>
        </member>
        <member name="T:System.Xaml.MS.Impl.SixItemList`1">
            <summary>
            A simple class to handle a list with 6 items.
            </summary>
        </member>
        <member name="T:System.Xaml.MS.Impl.ArrayItemList`1">
            <summary>
            A simple class to handle an array of 7 or more items.  It is unsorted and uses
            a linear search.
            </summary>
        </member>
        <member name="T:System.Xaml.Permissions.XamlAccessLevel">
            <SecurityNote>
            This class is immutable. Various consumers copy references into SecurityCritical fields,
            and their security depends on the immutability of the members defined here.
            Derived classes may add mutable members, those have no impact on the consumers of this class.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.WriterDelegate.SetLineInfo(System.Int32,System.Int32)">
            <summary>
            </summary>
            <param name="lineNumber"></param>
            <param name="linePosition"></param>
        </member>
        <member name="T:System.Xaml.Replacements.TypeListConverter">
            <summary>
            TypeConverter for System.Type[]
            </summary>
        </member>
        <member name="T:System.Xaml.Replacements.TypeTypeConverter">
            <summary>
            TypeConverter for System.Type
            </summary>
        </member>
        <member name="M:System.Xaml.XamlException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <SecurityNote>
            Critical: calls Critical method Exception.GetObjectData
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.XamlDuplicateMemberException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <SecurityNote>
            Critical: calls Critical method Exception.GetObjectData
            </SecurityNote>
        </member>
        <member name="T:System.Xaml.XamlMember">
            <SecurityNote>
            This class is extensible; various members which could be used for visibility evaluation--
            IsReadPublic, IsWritePublic, DeclaringType--get their data either from virtual methods or
            from constructor arguments.
            For security-critical data, always check the underlying CLR member.
            </SecurityNote>
        </member>
        <member name="F:System.Xaml.XamlMember._underlyingMember">
            <summary>
            Lazy init: NullableReference.IsSet is null when not initialized
            </summary>
            <SecurityNote>
            Critical: Ensuring idempotence for consistency with UnderlyingGetter/Setter
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker,System.Xaml.Schema.MemberReflector)">
            <SecurityNote>
            Critical: Accesses critical field _underlyingMember
            Safe: Constructor is single-threaded, so idempotence is assured
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker,System.Xaml.Schema.MemberReflector)">
            <SecurityNote>
            Critical: Accesses critical field _underlyingMember
            Safe: Constructor is single-threaded, so idempotence is assured
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker,System.Xaml.Schema.MemberReflector)">
            <SecurityNote>
            Critical: Accesses critical field _underlyingMember
            Safe: Constructor is single-threaded, so idempotence is assured
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker,System.Xaml.Schema.MemberReflector)">
            <SecurityNote>
            Critical: Accesses critical field _underlyingMember
            Safe: Constructor is single-threaded, so idempotence is assured
            </SecurityNote>
        </member>
        <member name="P:System.Xaml.XamlMember.UnderlyingMember">
            <SecurityNote>
            Critical: Accesses critical field _underlyingMember
            Safe: Ensures idempotence via NullableReference.SetIfNull, which uses CompareExchange
            </SecurityNote>
        </member>
        <member name="P:System.Xaml.XamlMember.UnderlyingMemberInternal">
            <summary>Accesses _underlyingMember without initializing it</summary>
            <SecurityNote>
            Critical: Accesses critical field _underlyingMember
            Safe: Doesn't modify field. Field is value type so caller cannot modify it.
            </SecurityNote>
        </member>
        <member name="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters">
            <summary>
            Returns the value of the MarkupExtensionBracketCharacterAttribute set on
            a property of a MarkupExtension as a ReadOnlyDictionary. Opening bracket is the
            key, while the value is the closing bracket.
            </summary>
        </member>
        <member name="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters">
            <summary>
            Returns the value of the MarkupExtensionBracketCharacterAttribute set on
            a property of a MarkupExtension as a ReadOnlyDictionary. Opening bracket is the
            key, while the value is the closing bracket.
            </summary>
        </member>
        <member name="T:System.Xaml.XamlSchemaContext">
             <SecurityNote>
             SchemaContexts can potentially be shared between multiple callers in an AppDomain, including
             both full and partial trust callers. To be safe for sharing, the default implementation should
             be idempotent and order-independent--i.e. functionally immutable.

             Technically, we don't guarantee these properties (they're not enforced by the runtime), but
             we should never knowingly break them.

             This means two things:
             1. No public mutability.
                Derived classes can potentially be mutable, but the base implementation should not be.
             2. No externally observable side effects from lookups.
                This means that all cached data should be generally applicable; it can't depend on any
                input other than the ctor arguments and AppDomain state.
                (For a subtle example of this, see the security note in Initialize().)
             These principles apply to all classes in the schema hierarchy (XamlType, XamlMember, etc).
             </SecurityNote>
             <remarks>
             This class, and the closure of its references (i.e. XamlType, XamlMember, etc) are all
             thread-safe in their base implementations. Derived implementations can choose whether or not
             to be thread-safe.
             </remarks>
        </member>
        <member name="M:System.Xaml.XamlSchemaContext.InitBracketCharacterCacheForType(System.Xaml.XamlType)">
            <summary>
            Constructs a cache of all the members in this particular type that have
            MarkupExtensionBracketCharactersAttribute set on them. This cache is added to a master
            cache which stores the BracketCharacter cache for each type.
            </summary>
        </member>
        <member name="M:System.Xaml.XamlSchemaContext.BuildBracketCharacterCacheForType(System.Xaml.XamlType)">
            <summary>
            Looks up all properties via reflection on the given type, and scans through the attributes on all of them
            to build a cache of properties which have MarkupExtensionBracketCharactersAttribute set on them.
            </summary>
        </member>
        <member name="M:System.Xaml.XamlSchemaContext.AssemblyLoadHandler.Hook">
            <SecurityNote>
            Critical: Accesses Critical event AppDomain.AssemblyLoad.
            Safe: We only use the event to track what assemblies are loaded in to the AppDomain.
                  This is not privileged info, as it is available via AppDomain.GetAssemblies().
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.XamlSchemaContext.AssemblyLoadHandler.Unhook">
            <SecurityNote>
            Critical: Accesses Critical event AppDomain.AssemblyLoad.
            Safe: We just remove a handler that we ourselves added.
            </SecurityNote>
        </member>
        <member name="T:System.Xaml.XamlType">
            <SecurityNote>
            This class is extensible; various members which could be used for visibility evaluation--
            IsPublic, BaseType, CanAssignTo--are either virtual, or get their data from virtual methods.
            For security-critical data, always check the underlying CLR type.
            </SecurityNote>
        </member>
        <member name="F:System.Xaml.XamlType._underlyingType">
            <summary>
            Lazy init: NullableReference.IsSet is null when not initialized
            </summary>
            <SecurityNote>
            We cache a visibility check based on this value, so it must be idempotent
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.XamlType.#ctor(System.String,System.Type,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlTypeInvoker,System.Xaml.Schema.TypeReflector)">
            <SecurityNote>
            Critical: Accesses critical field _underlyingType
            Safe: Constructor is single-threaded, so idempotence is assured
            </SecurityNote>
        </member>
        <member name="P:System.Xaml.XamlType.UnderlyingType">
            <SecurityNote>
            Critical: Accesses critical field _underlyingType
            Safe: Ensures idempotence via NullableReference.SetIfNull, which uses CompareExchange
            </SecurityNote>
        </member>
        <member name="P:System.Xaml.XamlType.UnderlyingTypeInternal">
            <summary>
            Accesses UnderlyingType without initializing it
            </summary>
            <SecurityNote>
            Critical: Accesses critical field _underlyingType
            Safe: Doesn't modify field value. Field is value type, so caller cannot modify it.
            </SecurityNote>
        </member>
        <member name="M:System.Xaml.XamlObjectReader.ObjectMarkupInfo.ConvertToInstanceDescriptor(System.Xaml.XamlObjectReader.SerializerContext,System.Object,System.ComponentModel.TypeConverter,System.Reflection.MemberInfo@,System.Collections.ICollection@,System.Boolean@)">
             <SecurityNote>
             Critical: Accesses members on InstanceDescriptor, which has a LinkDemand
             Safe: Protected with a Full Demand

             Note: there's not really anything on InstanceDescriptor itself (other than perhaps
             the Invoke method, which we don't use) that needs to be protected; the sensitive
             work is actually done in converters that potentially access non-public members to
             return the instance data.
             However, rather than relying on converters to do the right thing, this is enforced
             via a LinkDemand on InstanceDescriptor. So we have no choice but to demand here.
             </SecurityNote>
        </member>
        <member name="T:System.Xaml.XamlObjectReader.PartiallyOrderedList`2.Entry">
            <summary>
            Private class to hold the key and the value.
            </summary>
        </member>
        <member name="M:System.Xaml.XamlObjectReader.PartiallyOrderedList`2.Add(`0,`1)">
            <summary>
            Add a value to the list. The order in the list
            is controled by the key and calls to SetOrder.
            </summary>
            <param name="key">The ordering key</param>
            <param name="value">The value</param>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.DeclareNamespaceCompatibility(System.String,System.String)">
            <summary>
            replaces all future references of namespace URI 'oldNamespace' with 'newNamespace'
            </summary>
            <param name="newNamespace">
            the namespace to subsume with
            </param>
            <param name="oldNamespace">
            the namespace to be subsumed
            </param>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.Read">
            <summary>
            Reads the next node from the stream.
            </summary>
            <returns>
            true if the next node was read successfully; false if there are no more nodes to read.
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.ReadStartElement(System.Boolean@)">
            <summary>
            Used to handle 'start element' tags.  These are actually
            just called 'element' tags, the 'start' is just for clarity
            </summary>
            <param name="more">
            is set to true if there is the document contains more elements, false if the end of the
            document has been reached.
            </param>
            <returns>
            true if an element was read that should not be ignored
            false if the element read should be ignored or the end of document has been reached
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.ReadEndElement(System.Boolean@)">
            <summary>
            Used to handle any end element tag
            </summary>
            <param name="more">
            is set to true if there is the document contains more elements, false if the end of the
            document has been reached.
            </param>
            <returns>
            true if an element was read that should not be ignored
            false if the element read should be ignored or the end of document has been reached
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.GetAttribute(System.Int32)">
            <summary>
            Gets the value of the attribute with the specified index.
            </summary>
            <param name="i">
            The index of the attribute. The index is zero-based. (The first attribute has index 0.)
            </param>
            <returns>
            The value of the specified attribute. If the attribute is not found, a null reference is returned.
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.GetAttribute(System.String)">
            <summary>
            Gets the value of the attribute with the specified name.
            </summary>
            <param name="name">
            The qualified name of the attribute.
            </param>
            <returns>
            The value of the specified attribute. If the attribute is not found, a null reference is returned.
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.GetAttribute(System.String,System.String)">
            <summary>
            Gets the value of the attribute with the specified local name and namespace URI.
            </summary>
            <param name="localName">
            The local name of the attribute.
            </param>
            <param name="namespaceURI">
            The namespace URI of the attribute.
            </param>
            <returns>
            The value of the specified attribute. If the attribute is not found, a null reference is returned.
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.MoveToAttribute(System.Int32)">
            <summary>
            Gets the value of the attribute with the specified index.
            </summary>
            <param name="i">
            The index of the attribute. The index is zero-based. (The first attribute has index 0.)
            </param>
            <returns>
            true if the attribute is found; otherwise, false. If false, the reader's position does not change.
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.MoveToAttribute(System.String)">
            <summary>
            Moves to the attribute with the specified name.
            </summary>
            <param name="name">
            The qualified name of the attribute.
            </param>
            <returns>
            true if the attribute is found; otherwise, false. If false, the reader's position does not change.
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.MoveToAttribute(System.String,System.String)">
            <summary>
            Moves to the attribute with the specified local name and namespace URI.
            </summary>
            <param name="localName">
            The local name of the attribute.
            </param>
            <param name="namespaceURI">
            The namespace URI of the attribute.
            </param>
            <returns>
            true if the attribute is found; otherwise, false. If false, the reader's position does not change.
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.MoveToFirstAttribute">
            <summary>
            Moves to the first attribute.
            </summary>
            <returns>
            true if an attribute exists (the reader moves to the first attribute);
            otherwise, false (the position of the reader does not change).
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.MoveToNextAttribute">
            <summary>
            Moves to the next attribute.
            </summary>
            <returns>
            true if there is a next attribute; false if there are no more attributes.
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.LookupNamespace(System.String)">
            <summary>
            Resolves a namespace prefix in the current element's scope.
            </summary>
            <param name="prefix">
            The prefix whose namespace URI you want to resolve. To match the default namespace,
            pass an empty string. This string does not have to be atomized.
            </param>
            <returns>
            The namespace URI to which the prefix maps or a null reference if no matching prefix is found.
            </returns>
        </member>
        <member name="P:System.Xaml.XmlCompatibilityReader.Value">
            <summary>
            This override is to ensure that the value
            for the xmlns attribute reflects all the
            compatibility (subsuming) rules.
            </summary>
        </member>
        <member name="P:System.Xaml.XmlCompatibilityReader.NamespaceURI">
            <summary>
            Gets the namespace URI (as defined in the W3C Namespace specification) of the node
            on which the reader is positioned.
            </summary>
        </member>
        <member name="P:System.Xaml.XmlCompatibilityReader.Depth">
            <summary>
            Gets the depth of the current node in the XML document.
            </summary>
        </member>
        <member name="P:System.Xaml.XmlCompatibilityReader.HasAttributes">
            <summary>
            Gets a value indicating whether the current node has any attributes
            </summary>
        </member>
        <member name="P:System.Xaml.XmlCompatibilityReader.AttributeCount">
            <summary>
            Gets the number of attributes on the current node.
            </summary>
        </member>
        <member name="P:System.Xaml.XmlCompatibilityReader.Normalization">
            <summary>
            Sets a value indicating whether to normalize white space and attribute values.
            </summary>
        </member>
        <member name="P:System.Xaml.XmlCompatibilityReader.Encoding">
            <summary>
            Answer the encoding of the underlying xaml stream
            </summary>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.GetMappedNamespace(System.String)">
            <summary>
            Retrieves the correctly mapped namespace from the namespace provided
            </summary>
            <param name="namespaceName">
            The name of the namespace to retrieve the mapping of
            </param>
            <returns>
            The name of the mapped namespace.
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.MapNewNamespace(System.String)">
            <summary>
            Adds the namespace to the namespace map.  The default is to map the namespace to itself.
            The namespace is mapped to the value returned by the callback, if a callback exists and the
            callback returns a subsuming namespace.
            </summary>
            <param name="namespaceName">
            The name of the namespace to be mapped.
            </param>
            <returns>
            The name of the mapped namespace.
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.IsSubsumingNamespace(System.String)">
            <summary>
            Used to determine whether a given namespace subsumes another namespace
            </summary>
            <param name="namespaceName">
            The name of the namespace to be checked.
            </param>
            <returns>
            true if the namespace subsumes another namespace; false otherwise
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.AddSubsumingNamespace(System.String)">
            <summary>
            Used to specify that a namespace subsumes another namespace
            </summary>
            <param name="namespaceName">
            The name of the namespace to be added.
            </param>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.IsNamespaceKnown(System.String)">
            <summary>
            Used to determine whether a given namespace is known/supported
            </summary>
            <param name="namespaceName">
            The name of the namespace to be checked.
            </param>
            <returns>
            true if the namespace is known/supported; false otherwise
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.AddKnownNamespace(System.String)">
            <summary>
            Used to specify that a namespace is known or supported
            </summary>
            <param name="namespaceName">
            The name of the namespace to be added.
            </param>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.ShouldIgnoreNamespace(System.String)">
            <summary>
            Used to determine whether a given namespace should be ignored.  A namespace should be ignored if:
            EITHER
            a) the namespace is not known/supported and has been marked Ignorable
            OR
            b) the namespace is the markup-compatibility namespace
            </summary>
            <param name="namespaceName">
            The name of the prefix to be checked.
            </param>
            <returns>
            true if the namespace should be ignored; false otherwise
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.ParseContentToNamespaceElementPair(System.String,System.String)">
            <summary>
            breaks up a space-delineated string into namespace/element pairs
            </summary>
            <param name="content">
            the string to be parsed
            </param>
            <param name="callerContext">
            The calling element, used in case of an error
            </param>
            <returns>
            the list of namespace/element pairs
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.PrefixesToNamespaces(System.String)">
            <summary>
            converts a string of space-delineated prefixes into a list of namespaces
            </summary>
            <param name="prefixes">
            the string to be parsed
            </param>
            <returns>
            the list of namespace/element pairs
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.SkipToKnownAttribute">
            <summary>
            advances the reader to the next known namespace/attribute pair
            </summary>
            <returns>
            true if a known namespace/attribute pair was found
            </returns>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.ScanForCompatibility(System.Int32)">
             <summary>
             Scans the current element for compatibility attributes.  Pushes a new
             scope onto the stack under the following conditions:
             1) Ignorable or MustUnderstand attribute read
             2) current element has not previously declared an Ignorable or
                MustUnderstand attribute

             However, if a last condition is not fulfilled, then the scope is popped off
             before the function returns
             3) current element is not empty

             stores in _ignoredAttributeCount the number of attributes on the current element
             that should be ignored, for the sake of improving perf in attribute-related
             methods/properties
             </summary>
             <param name="elementDepth">
             the depth of the Reader at the element currently being processed
             </param>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.ScanForEndCompatibility(System.Int32)">
            <summary>
            pops a scope if the end of a compatibility region.
            </summary>
            <param name="elementDepth">
            the depth of the Reader at the element currently being processed
            </param>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.PushScope(System.Int32)">
            <summary>
            pushes a new scope onto the stack with a depth passed as an arg.
            PushScope does not push a scope if the top scope on the stack is not a lower depth.
            </summary>
            <param name="elementDepth">
            the depth of the Reader at the element currently being processed
            </param>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.PopScope">
            <summary>
            pops a scope off the top of the stack.
            PopScope *always* pops, it does not check the depth before doing so
            </summary>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.HandleAlternateContent(System.Int32,System.Boolean@)">
             <summary>
             handles mc:AlternateContent element

             a good way to think of AlternateContent blocks is as a switch/case
             statement.  The AlternateContent tag is like switch, Choice is like
             case, and Fallback is like default.
             </summary>
             <param name="elementDepth">
             the depth of the Reader at the element currently being processed
             </param>
             <param name="more">
             returns whether the Reader has more to be read
             </param>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.HandleChoice(System.Int32,System.Boolean@)">
             <summary>
             handles mc:Choice element

             a good way to think of AlternateContent blocks is as a switch/case
             statement.  The AlternateContent tag is like switch, Choice is like
             case, and Fallback is like default.
             </summary>
             <param name="elementDepth">
             the depth of the Reader at the element currently being processed
             </param>
             <param name="more">
             returns whether the Reader has more to be read
             </param>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.HandleFallback(System.Int32,System.Boolean@)">
             <summary>
             handles mc:Fallback element

             a good way to think of AlternateContent blocks is as a switch/case
             statement.  The AlternateContent tag is like switch, Choice is like
             case, and Fallback is like default.
             </summary>
             <param name="elementDepth">
             the depth of the Reader at the element currently being processed
             </param>
             <param name="more">
             returns whether the Reader has more to be read
             </param>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.HandleIgnorable(System.Int32)">
             <summary>
             handles mc:Ignorable="foo" attribute

             Ignorable is used to indicate that the namespace the prefix is mapped to can
             be ignored, i.e. when the namespace/element or namespace/attribute occurs it
             is not returned by the reader.
             </summary>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.HandleMustUnderstand(System.Int32)">
             <summary>
             handles mc:MustUnderstand="foo" attribute

             MustUnderstand is used to indicate that the namespace the prefix is mapped to
             cannot be handled, and if it is not understood an exception is thrown
             </summary>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.HandleProcessContent(System.Int32)">
             <summary>
             handles mc:ProcessContent="foo:bar" attribute

             ProcessContent is used to indicate that an ignorable namespace has some
             elements that should be skipped, but contain child elements that should be processed.

             The wildcard token ("foo:*") indicates that the children of any element in that
             namespace should be processed.
             </summary>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.HandlePreserveElements(System.Int32)">
             <summary>
             handles mc:PreserveElements="foo:bar" attribute

             functionality is supported, but not implemented
             </summary>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.HandlePreserveAttributes(System.Int32)">
             <summary>
             handles mc:PreserveAttributes="foo:bar" attribute

             functionality is supported, but not implemented
             </summary>
        </member>
        <member name="M:System.Xaml.XmlCompatibilityReader.Error(System.String,System.Object[])">
            <summary>
            helper method to generate an exception
            </summary>
        </member>
        <member name="T:System.Xaml.XmlCompatibilityReader.CompatibilityScope">
            <summary>
            CompatibilityScopes are used to handle markup-compatibility elements and attributes.
            Each scope stores the "previous" or parent scope, its depth, and an associated XmlCompatibilityReader.
            At a particular Reader depth, only one scope should be pushed.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.AntlrFileStream">
            <summary>
            This is an
            <see cref="T:Antlr4.Runtime.AntlrInputStream"/>
            that is loaded from a file all at once
            when you construct the object.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.#ctor(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.#ctor(System.String,System.Text.Encoding)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.Load(System.String,System.Text.Encoding)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Antlr4.Runtime.AntlrInputStream">
            <summary>
            Vacuum all input from a
            <see cref="T:System.IO.TextReader"/>
            /
            <see cref="T:System.IO.Stream"/>
            and then treat it
            like a
            <c>char[]</c>
            buffer. Can also pass in a
            <see cref="T:System.String"/>
            or
            <c>char[]</c>
            to use.
            <p>If you need encoding, pass in stream/reader with correct encoding.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.data">
            <summary>The data being scanned</summary>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.n">
            <summary>How many characters are actually in the buffer</summary>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.p">
            <summary>0..n-1 index into string of next char</summary>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.name">
            <summary>What is name or source of this char stream?</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.String)">
            <summary>Copy data in string to a local char array</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.Char[],System.Int32)">
            <summary>This is the preferred constructor for strings as no data is copied</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.TextReader)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.TextReader,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.TextReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Load(System.IO.TextReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Reset">
            <summary>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </summary>
            <remarks>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.AntlrInputStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.
            </summary>
            <remarks>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.  The index is the index of char to
            be returned from LA(1).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Mark">
            <summary>mark/release do nothing; we have entire buffer</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Seek(System.Int32)">
            <summary>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine.
            </summary>
            <remarks>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine. If we seek backwards, just set p
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AbstractPredicateTransition">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AmbiguityInfo">
            <summary>This class represents profiling event information for an ambiguity.</summary>
            <remarks>
            This class represents profiling event information for an ambiguity.
            Ambiguities are decisions where a particular input resulted in an SLL
            conflict, followed by LL prediction also reaching a conflict state
            (indicating a true ambiguity in the grammar).
            <p>
            This event may be reported during SLL prediction in cases where the
            conflicting SLL configuration set provides sufficient information to
            determine that the SLL conflict is truly an ambiguity. For example, if none
            of the ATN configurations in the conflicting SLL configuration set have
            traversed a global follow transition (i.e.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.ReachesIntoOuterContext"/>
            is
            <see langword="false"/>
            for all
            configurations), then the result of SLL prediction for that input is known to
            be equivalent to the result of LL prediction for that input.</p>
            <p>
            In some cases, the minimum represented alternative in the conflicting LL
            configuration set is not equal to the minimum represented alternative in the
            conflicting SLL configuration set. Grammars and inputs which result in this
            scenario are unable to use
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Sll"/>
            , which in turn means
            they cannot use the two-stage parsing strategy to improve parsing performance
            for that input.</p>
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportAmbiguity(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            <seealso cref="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.AmbiguityInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.AmbiguityInfo"/>
            class with the
            specified detailed ambiguity information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state identifying the ambiguous
            alternatives for the current input
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">
            The index at which the ambiguity was identified during
            prediction
            </param>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.decisionToState">
            <summary>
            Each subrule/rule is a decision point and we must track them so we
            can go back later and build DFA predictors for them.
            </summary>
            <remarks>
            Each subrule/rule is a decision point and we must track them so we
            can go back later and build DFA predictors for them.  This includes
            all the rules, subrules, optional blocks, ()+, ()* etc...
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToStartState">
            <summary>Maps from rule index to starting state number.</summary>
            <remarks>Maps from rule index to starting state number.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToStopState">
            <summary>Maps from rule index to stop state number.</summary>
            <remarks>Maps from rule index to stop state number.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.grammarType">
            <summary>The type of the ATN.</summary>
            <remarks>The type of the ATN.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.maxTokenType">
            <summary>The maximum value for any symbol recognized by a transition in the ATN.</summary>
            <remarks>The maximum value for any symbol recognized by a transition in the ATN.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToTokenType">
            <summary>For lexer ATNs, this maps the rule index to the resulting token type.</summary>
            <remarks>
            For lexer ATNs, this maps the rule index to the resulting token type.
            For parser ATNs, this maps the rule index to the generated bypass token
            type if the
            <see cref="P:Antlr4.Runtime.Atn.ATNDeserializationOptions.GenerateRuleBypassTransitions"/>
            deserialization option was specified; otherwise, this is
            <see langword="null"/>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.lexerActions">
            <summary>
            For lexer ATNs, this is an array of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            objects which may
            be referenced by action transitions in the ATN.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.#ctor(Antlr4.Runtime.Atn.ATNType,System.Int32)">
            <summary>Used for runtime deserialization of ATNs from strings</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.NextTokens(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext)">
            <summary>
            Compute the set of valid tokens that can occur starting in state
            <paramref name="s"/>
            .
            If
            <paramref name="ctx"/>
            is
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal"/>
            , the set of tokens will not include what can follow
            the rule surrounding
            <paramref name="s"/>
            . In other words, the set will be
            restricted to tokens reachable staying within
            <paramref name="s"/>
            's rule.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.NextTokens(Antlr4.Runtime.Atn.ATNState)">
            <summary>
            Compute the set of valid tokens that can occur starting in
            <paramref name="s"/>
            and
            staying in same rule.
            <see cref="F:Antlr4.Runtime.TokenConstants.Epsilon"/>
            is in set if we reach end of
            rule.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.GetExpectedTokens(System.Int32,Antlr4.Runtime.RuleContext)">
            <summary>
            Computes the set of input symbols which could follow ATN state number
            <paramref name="stateNumber"/>
            in the specified full
            <paramref name="context"/>
            . This method
            considers the complete parser context, but does not evaluate semantic
            predicates (i.e. all predicates encountered during the calculation are
            assumed true). If a path in the ATN exists from the starting state to the
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            of the outermost context without matching any
            symbols,
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            is added to the returned set.
            <p>If
            <paramref name="context"/>
            is
            <see langword="null"/>
            , it is treated as
            <see cref="P:Antlr4.Runtime.ParserRuleContext.EmptyContext"/>
            .</p>
            </summary>
            <param name="stateNumber">the ATN state number</param>
            <param name="context">the full parse context</param>
            <returns>
            The set of potentially valid input symbols which could follow the
            specified state in the specified context.
            </returns>
            <exception cref="T:System.ArgumentException">
            if the ATN does not contain a state with
            number
            <paramref name="stateNumber"/>
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNConfig">
            <summary>A tuple: (ATN state, predicted alt, syntactic, semantic context).</summary>
            <remarks>
            A tuple: (ATN state, predicted alt, syntactic, semantic context).
            The syntactic context is a graph-structured stack node whose
            path(s) to the root is the rule invocation(s)
            chain used to arrive at the state.  The semantic context is
            the tree of semantic predicates encountered before reaching
            an ATN state.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.SuppressPrecedenceFilter">
            <summary>
            This field stores the bit mask for implementing the
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.PrecedenceFilterSuppressed"/>
            property as a bit within the
            existing
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.altAndOuterContextDepth"/>
            field.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.state">
            <summary>The ATN state associated with this configuration</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.altAndOuterContextDepth">
            <summary>This is a bit-field currently containing the following values.</summary>
            <remarks>
            This is a bit-field currently containing the following values.
            <ul>
            <li>0x00FFFFFF: Alternative</li>
            <li>0x7F000000: Outer context depth</li>
            <li>0x80000000: Suppress precedence filter</li>
            </ul>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.context">
            <summary>
            The stack of invoking states leading to the rule/states associated
            with this config.
            </summary>
            <remarks>
            The stack of invoking states leading to the rule/states associated
            with this config.  We track only those contexts pushed during
            execution of the ATN simulator.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfig.State">
            <summary>Gets the ATN state associated with this configuration.</summary>
            <remarks>Gets the ATN state associated with this configuration.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfig.Alt">
            <summary>What alt (or lexer rule) is predicted by this configuration.</summary>
            <remarks>What alt (or lexer rule) is predicted by this configuration.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfig.OuterContextDepth">
            <summary>
            We cannot execute predicates dependent upon local context unless
            we know for sure we are in the correct context.
            </summary>
            <remarks>
            We cannot execute predicates dependent upon local context unless
            we know for sure we are in the correct context. Because there is
            no way to do this efficiently, we simply cannot evaluate
            dependent predicates unless we are in the rule that initially
            invokes the ATN simulator.
            <p>
            closure() tracks the depth of how far we dip into the outer context:
            depth &gt; 0.  Note that it may not be totally accurate depth since I
            don't ever decrement. TODO: make it a boolean then</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNConfig.Equals(System.Object)">
            <summary>
            An ATN configuration is equal to another if both have
            the same state, they predict the same alternative, and
            syntactic/semantic contexts are the same.
            </summary>
            <remarks>
            An ATN configuration is equal to another if both have
            the same state, they predict the same alternative, and
            syntactic/semantic contexts are the same.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNConfigSet">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.mergedConfigs">
            <summary>
            This maps (state, alt) -&gt; merged
            <see cref="T:Antlr4.Runtime.Atn.ATNConfig"/>
            . The key does not account for
            the
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.SemanticContext"/>
            of the value, which is only a problem if a single
            <c>ATNConfigSet</c>
            contains two configs with the same state and alternative
            but different semantic contexts. When this case arises, the first config
            added to this map stays, and the remaining configs are placed in
            <see cref="F:Antlr4.Runtime.Atn.ATNConfigSet.unmerged"/>
            .
            <p/>
            This map is only used for optimizing the process of adding configs to the set,
            and is
            <see langword="null"/>
            for read-only sets stored in the DFA.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.unmerged">
            <summary>
            This is an "overflow" list holding configs which cannot be merged with one
            of the configs in
            <see cref="F:Antlr4.Runtime.Atn.ATNConfigSet.mergedConfigs"/>
            but have a colliding key. This
            occurs when two configs in the set have the same state and alternative but
            different semantic contexts.
            <p/>
            This list is only used for optimizing the process of adding configs to the set,
            and is
            <see langword="null"/>
            for read-only sets stored in the DFA.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.configs">
            <summary>This is a list of all configs in this set.</summary>
            <remarks>This is a list of all configs in this set.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.outermostConfigSet">
            <summary>
            When
            <see langword="true"/>
            , this config set represents configurations where the entire
            outer context has been consumed by the ATN interpreter. This prevents the
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.Closure(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.ATNConfigSet,System.Boolean,System.Boolean,Antlr4.Runtime.Atn.PredictionContextCache,System.Boolean)"/>
            from pursuing the global FOLLOW when a
            rule stop state is reached with an empty prediction context.
            <p/>
            Note:
            <c>outermostConfigSet</c>
            and
            <see cref="F:Antlr4.Runtime.Atn.ATNConfigSet.dipsIntoOuterContext"/>
            should never
            be true at the same time.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfigSet.RepresentedAlternatives">
            <summary>
            Get the set of all alternatives represented by configurations in this
            set.
            </summary>
            <remarks>
            Get the set of all alternatives represented by configurations in this
            set.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNDeserializationOptions">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNDeserializer">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.BaseSerializedUuid">
            <summary>This is the earliest supported serialized UUID.</summary>
            <remarks>This is the earliest supported serialized UUID.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.SupportedUuids">
            <summary>
            This list contains all of the currently supported UUIDs, ordered by when
            the feature first appeared in this branch.
            </summary>
            <remarks>
            This list contains all of the currently supported UUIDs, ordered by when
            the feature first appeared in this branch.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.SerializedUuid">
            <summary>This is the current serialized UUID.</summary>
            <remarks>This is the current serialized UUID.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNDeserializer.IsFeatureSupported(System.Guid,System.Guid)">
            <summary>
            Determines if a particular serialized representation of an ATN supports
            a particular feature, identified by the
            <see cref="T:System.Guid"/>
            used for serializing
            the ATN at the time the feature was first introduced.
            </summary>
            <param name="feature">
            The
            <see cref="T:System.Guid"/>
            marking the first time the feature was
            supported in the serialized ATN.
            </param>
            <param name="actualUuid">
            The
            <see cref="T:System.Guid"/>
            of the actual serialized ATN which is
            currently being deserialized.
            </param>
            <returns>

            <see langword="true"/>
            if the
            <paramref name="actualUuid"/>
            value represents a
            serialized ATN at or after the feature identified by
            <paramref name="feature"/>
            was
            introduced; otherwise,
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNDeserializer.MarkPrecedenceDecisions(Antlr4.Runtime.Atn.ATN)">
            <summary>
            Analyze the
            <see cref="T:Antlr4.Runtime.Atn.StarLoopEntryState"/>
            states in the specified ATN to set
            the
            <see cref="F:Antlr4.Runtime.Atn.StarLoopEntryState.precedenceRuleDecision"/>
            field to the
            correct value.
            </summary>
            <param name="atn">The ATN.</param>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNSimulator.SerializedUuid">
            <summary>This is the current serialized UUID.</summary>
            <remarks>This is the current serialized UUID.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNSimulator.Error">
            <summary>Must distinguish between missing edge and edge we know leads nowhere</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNSimulator.ClearDFA">
            <summary>Clear the DFA cache used by the current instance.</summary>
            <remarks>
            Clear the DFA cache used by the current instance. Since the DFA cache may
            be shared by multiple ATN simulators, this method may affect the
            performance (but not accuracy) of other parsers which are being used
            concurrently.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            if the current instance does not
            support clearing the DFA.
            </exception>
            <since>4.3</since>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNState">
            <summary>
            The following images show the relation of states and
            <see cref="F:Antlr4.Runtime.Atn.ATNState.transitions"/>
            for various grammar constructs.
            <ul>
            <li>Solid edges marked with an &#0949; indicate a required
            <see cref="T:Antlr4.Runtime.Atn.EpsilonTransition"/>
            .</li>
            <li>Dashed edges indicate locations where any transition derived from
            <see cref="M:Antlr4.Runtime.Atn.ATNState.Transition(System.Int32)"/>
            might appear.</li>
            <li>Dashed nodes are place holders for either a sequence of linked
            <see cref="T:Antlr4.Runtime.Atn.BasicState"/>
            states or the inclusion of a block representing a nested
            construct in one of the forms below.</li>
            <li>Nodes showing multiple outgoing alternatives with a
            <c>...</c>
            support
            any number of alternatives (one or more). Nodes without the
            <c>...</c>
            only
            support the exact number of alternatives shown in the diagram.</li>
            </ul>
            <h2>Basic Blocks</h2>
            <h3>Rule</h3>
            <embed src="images/Rule.svg" type="image/svg+xml"/>
            <h3>Block of 1 or more alternatives</h3>
            <embed src="images/Block.svg" type="image/svg+xml"/>
            <h2>Greedy Loops</h2>
            <h3>Greedy Closure:
            <c>(...)*</c>
            </h3>
            <embed src="images/ClosureGreedy.svg" type="image/svg+xml"/>
            <h3>Greedy Positive Closure:
            <c>(...)+</c>
            </h3>
            <embed src="images/PositiveClosureGreedy.svg" type="image/svg+xml"/>
            <h3>Greedy Optional:
            <c>(...)?</c>
            </h3>
            <embed src="images/OptionalGreedy.svg" type="image/svg+xml"/>
            <h2>Non-Greedy Loops</h2>
            <h3>Non-Greedy Closure:
            <c>(...)*?</c>
            </h3>
            <embed src="images/ClosureNonGreedy.svg" type="image/svg+xml"/>
            <h3>Non-Greedy Positive Closure:
            <c>(...)+?</c>
            </h3>
            <embed src="images/PositiveClosureNonGreedy.svg" type="image/svg+xml"/>
            <h3>Non-Greedy Optional:
            <c>(...)??</c>
            </h3>
            <embed src="images/OptionalNonGreedy.svg" type="image/svg+xml"/>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNState.atn">
            <summary>Which ATN are we in?</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNState.transitions">
            <summary>Track the transitions emanating from this ATN state.</summary>
            <remarks>Track the transitions emanating from this ATN state.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNState.nextTokenWithinRule">
            <summary>Used to cache lookahead during parsing, not used during construction</summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNState.NonStopStateNumber">
            <summary>
            For all states except
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            , this returns the state
            number. Returns -1 for stop states.
            </summary>
            <returns>
            -1 for
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            , otherwise the state number
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNType">
            <summary>Represents the type of recognizer an ATN applies to.</summary>
            <remarks>Represents the type of recognizer an ATN applies to.</remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AtomTransition">
            <summary>TODO: make all transitions sets? no, should remove set edges</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.AtomTransition.token">
            <summary>The token type or character value; or, signifies special label.</summary>
            <remarks>The token type or character value; or, signifies special label.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BasicBlockStartState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BasicState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BlockEndState">
            <summary>
            Terminal node of a simple
            <c>(a|b|c)</c>
            block.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BlockStartState">
            <summary>
            The start of a regular
            <c>(...)</c>
            block.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ConflictInfo">
            <summary>This class stores information about a configuration conflict.</summary>
            <remarks>This class stores information about a configuration conflict.</remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ConflictInfo.ConflictedAlts">
            <summary>Gets the set of conflicting alternatives for the configuration set.</summary>
            <remarks>Gets the set of conflicting alternatives for the configuration set.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ConflictInfo.IsExact">
            <summary>Gets whether or not the configuration conflict is an exact conflict.</summary>
            <remarks>
            Gets whether or not the configuration conflict is an exact conflict.
            An exact conflict occurs when the prediction algorithm determines that
            the represented alternatives for a particular configuration set cannot be
            further reduced by consuming additional input. After reaching an exact
            conflict during an SLL prediction, only switch to full-context prediction
            could reduce the set of viable alternatives. In LL prediction, an exact
            conflict indicates a true ambiguity in the input.
            <p>
            For the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection"/>
            prediction mode,
            accept states are conflicting but not exact are treated as non-accept
            states.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ContextSensitivityInfo">
            <summary>This class represents profiling event information for a context sensitivity.</summary>
            <remarks>
            This class represents profiling event information for a context sensitivity.
            Context sensitivities are decisions where a particular input resulted in an
            SLL conflict, but LL prediction produced a single unique alternative.
            <p>
            In some cases, the unique alternative identified by LL prediction is not
            equal to the minimum represented alternative in the conflicting SLL
            configuration set. Grammars and inputs which result in this scenario are
            unable to use
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Sll"/>
            , which in turn means they cannot use
            the two-stage parsing strategy to improve parsing performance for that
            input.</p>
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportContextSensitivity(Antlr4.Runtime.Dfa.DFA,System.Int32,Antlr4.Runtime.Atn.SimulatorState,System.Int32,System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ContextSensitivityInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.ContextSensitivityInfo"/>
            class
            with the specified detailed context sensitivity information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state containing the unique
            alternative identified by full-context prediction
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">
            The index at which the context sensitivity was
            identified during full-context prediction
            </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.DecisionEventInfo">
            <summary>
            This is the base class for gathering detailed information about prediction
            events which occur during parsing.
            </summary>
            <remarks>
            This is the base class for gathering detailed information about prediction
            events which occur during parsing.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.decision">
            <summary>The invoked decision number which this event is related to.</summary>
            <remarks>The invoked decision number which this event is related to.</remarks>
            <seealso cref="F:Antlr4.Runtime.Atn.ATN.decisionToState"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.state">
            <summary>
            The simulator state containing additional information relevant to the
            prediction state when the current event occurred, or
            <see langword="null"/>
            if no
            additional information is relevant or available.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.input">
            <summary>The input token stream which is being parsed.</summary>
            <remarks>The input token stream which is being parsed.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.startIndex">
            <summary>
            The token index in the input stream at which the current prediction was
            originally invoked.
            </summary>
            <remarks>
            The token index in the input stream at which the current prediction was
            originally invoked.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.stopIndex">
            <summary>The token index in the input stream at which the current event occurred.</summary>
            <remarks>The token index in the input stream at which the current event occurred.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.fullCtx">
            <summary>
            <see langword="true"/>
            if the current event occurred during LL prediction;
            otherwise,
            <see langword="false"/>
            if the input occurred during SLL prediction.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.DecisionInfo">
            <summary>This class contains profiling gathered for a particular decision.</summary>
            <remarks>
            This class contains profiling gathered for a particular decision.
            <p>
            Parsing performance in ANTLR 4 is heavily influenced by both static factors
            (e.g. the form of the rules in the grammar) and dynamic factors (e.g. the
            choice of input and the state of the DFA cache at the time profiling
            operations are started). For best results, gather and use aggregate
            statistics from a large sample of inputs representing the inputs expected in
            production before using the results to make changes in the grammar.</p>
            </remarks>
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.decision">
            <summary>
            The decision number, which is an index into
            <see cref="F:Antlr4.Runtime.Atn.ATN.decisionToState"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.invocations">
            <summary>
            The total number of times
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AdaptivePredict(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)"/>
            was
            invoked for this decision.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_TotalLook">
            <summary>The sum of the lookahead required for SLL prediction for this decision.</summary>
            <remarks>
            The sum of the lookahead required for SLL prediction for this decision.
            Note that SLL prediction is used before LL prediction for performance
            reasons even when
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            or
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection"/>
            is used.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MinLook">
            <summary>
            Gets the minimum lookahead required for any single SLL prediction to
            complete for this decision, by reaching a unique prediction, reaching an
            SLL conflict state, or encountering a syntax error.
            </summary>
            <remarks>
            Gets the minimum lookahead required for any single SLL prediction to
            complete for this decision, by reaching a unique prediction, reaching an
            SLL conflict state, or encountering a syntax error.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MaxLook">
            <summary>
            Gets the maximum lookahead required for any single SLL prediction to
            complete for this decision, by reaching a unique prediction, reaching an
            SLL conflict state, or encountering a syntax error.
            </summary>
            <remarks>
            Gets the maximum lookahead required for any single SLL prediction to
            complete for this decision, by reaching a unique prediction, reaching an
            SLL conflict state, or encountering a syntax error.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MaxLookEvent">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.Atn.LookaheadEventInfo"/>
            associated with the event where the
            <see cref="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MaxLook"/>
            value was set.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_TotalLook">
            <summary>The sum of the lookahead required for LL prediction for this decision.</summary>
            <remarks>
            The sum of the lookahead required for LL prediction for this decision.
            Note that LL prediction is only used when SLL prediction reaches a
            conflict state.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MinLook">
            <summary>
            Gets the minimum lookahead required for any single LL prediction to
            complete for this decision.
            </summary>
            <remarks>
            Gets the minimum lookahead required for any single LL prediction to
            complete for this decision. An LL prediction completes when the algorithm
            reaches a unique prediction, a conflict state (for
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            , an ambiguity state (for
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection"/>
            , or a syntax error.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MaxLook">
            <summary>
            Gets the maximum lookahead required for any single LL prediction to
            complete for this decision.
            </summary>
            <remarks>
            Gets the maximum lookahead required for any single LL prediction to
            complete for this decision. An LL prediction completes when the algorithm
            reaches a unique prediction, a conflict state (for
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            , an ambiguity state (for
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection"/>
            , or a syntax error.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MaxLookEvent">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.Atn.LookaheadEventInfo"/>
            associated with the event where the
            <see cref="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MaxLook"/>
            value was set.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.contextSensitivities">
            <summary>
            A collection of
            <see cref="T:Antlr4.Runtime.Atn.ContextSensitivityInfo"/>
            instances describing the
            context sensitivities encountered during LL prediction for this decision.
            </summary>
            <seealso cref="T:Antlr4.Runtime.Atn.ContextSensitivityInfo"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.errors">
            <summary>
            A collection of
            <see cref="T:Antlr4.Runtime.Atn.ErrorInfo"/>
            instances describing the parse errors
            identified during calls to
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AdaptivePredict(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)"/>
            for
            this decision.
            </summary>
            <seealso cref="T:Antlr4.Runtime.Atn.ErrorInfo"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.ambiguities">
            <summary>
            A collection of
            <see cref="T:Antlr4.Runtime.Atn.AmbiguityInfo"/>
            instances describing the
            ambiguities encountered during LL prediction for this decision.
            </summary>
            <seealso cref="T:Antlr4.Runtime.Atn.AmbiguityInfo"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.predicateEvals">
            <summary>
            A collection of
            <see cref="T:Antlr4.Runtime.Atn.PredicateEvalInfo"/>
            instances describing the
            results of evaluating individual predicates during prediction for this
            decision.
            </summary>
            <seealso cref="T:Antlr4.Runtime.Atn.PredicateEvalInfo"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_ATNTransitions">
            <summary>
            The total number of ATN transitions required during SLL prediction for
            this decision.
            </summary>
            <remarks>
            The total number of ATN transitions required during SLL prediction for
            this decision. An ATN transition is determined by the number of times the
            DFA does not contain an edge that is required for prediction, resulting
            in on-the-fly computation of that edge.
            <p>
            If DFA caching of SLL transitions is employed by the implementation, ATN
            computation may cache the computed edge for efficient lookup during
            future parsing of this decision. Otherwise, the SLL parsing algorithm
            will use ATN transitions exclusively.</p>
            </remarks>
            <seealso cref="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_ATNTransitions"/>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeTargetState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.ParserRuleContext,System.Int32,System.Boolean,Antlr4.Runtime.Atn.PredictionContextCache)"/>
            <seealso cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.ComputeTargetState(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Dfa.DFAState,System.Int32)"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_DFATransitions">
            <summary>
            The total number of DFA transitions required during SLL prediction for
            this decision.
            </summary>
            <remarks>
            The total number of DFA transitions required during SLL prediction for
            this decision.
            <p>If the ATN simulator implementation does not use DFA caching for SLL
            transitions, this value will be 0.</p>
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_Fallback">
            <summary>
            Gets the total number of times SLL prediction completed in a conflict
            state, resulting in fallback to LL prediction.
            </summary>
            <remarks>
            Gets the total number of times SLL prediction completed in a conflict
            state, resulting in fallback to LL prediction.
            <p>Note that this value is not related to whether or not
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Sll"/>
            may be used successfully with a particular
            grammar. If the ambiguity resolution algorithm applied to the SLL
            conflicts for this decision produce the same result as LL prediction for
            this decision,
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Sll"/>
            would produce the same overall
            parsing result as
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            .</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_ATNTransitions">
            <summary>
            The total number of ATN transitions required during LL prediction for
            this decision.
            </summary>
            <remarks>
            The total number of ATN transitions required during LL prediction for
            this decision. An ATN transition is determined by the number of times the
            DFA does not contain an edge that is required for prediction, resulting
            in on-the-fly computation of that edge.
            <p>
            If DFA caching of LL transitions is employed by the implementation, ATN
            computation may cache the computed edge for efficient lookup during
            future parsing of this decision. Otherwise, the LL parsing algorithm will
            use ATN transitions exclusively.</p>
            </remarks>
            <seealso cref="F:Antlr4.Runtime.Atn.DecisionInfo.LL_DFATransitions"/>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeTargetState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.ParserRuleContext,System.Int32,System.Boolean,Antlr4.Runtime.Atn.PredictionContextCache)"/>
            <seealso cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.ComputeTargetState(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Dfa.DFAState,System.Int32)"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_DFATransitions">
            <summary>
            The total number of DFA transitions required during LL prediction for
            this decision.
            </summary>
            <remarks>
            The total number of DFA transitions required during LL prediction for
            this decision.
            <p>If the ATN simulator implementation does not use DFA caching for LL
            transitions, this value will be 0.</p>
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.Atn.DecisionInfo.#ctor(System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.DecisionInfo"/>
            class to contain
            statistics for a particular decision.
            </summary>
            <param name="decision">The decision number</param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.EpsilonTransition.OutermostPrecedenceReturn">
            <returns>
            the rule index of a precedence rule for which this transition is
            returning from, where the precedence value is 0; otherwise, -1.
            </returns>
            <seealso cref="P:Antlr4.Runtime.Atn.ATNConfig.PrecedenceFilterSuppressed"/>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ApplyPrecedenceFilter(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.ParserRuleContext,Antlr4.Runtime.Atn.PredictionContextCache)"/>
            <since>4.4.1</since>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ErrorInfo">
            <summary>
            This class represents profiling event information for a syntax error
            identified during prediction.
            </summary>
            <remarks>
            This class represents profiling event information for a syntax error
            identified during prediction. Syntax errors occur when the prediction
            algorithm is unable to identify an alternative which would lead to a
            successful parse.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(Antlr4.Runtime.IToken,System.String,Antlr4.Runtime.RecognitionException)"/>
            <seealso cref="M:Antlr4.Runtime.IAntlrErrorListener`1.SyntaxError(Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)"/>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ErrorInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.ErrorInfo"/>
            class with the
            specified detailed syntax error information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state reached during prediction
            prior to reaching the
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.Error"/>
            state
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">The index at which the syntax error was identified</param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ILexerAction">
            <summary>
            Represents a single action which can be executed following the successful
            match of a lexer rule.
            </summary>
            <remarks>
            Represents a single action which can be executed following the successful
            match of a lexer rule. Lexer actions are used for both embedded action syntax
            and ANTLR 4's new lexer command syntax.
            </remarks>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ILexerAction.ActionType">
            <summary>Gets the serialization type of the lexer action.</summary>
            <remarks>Gets the serialization type of the lexer action.</remarks>
            <returns>The serialization type of the lexer action.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ILexerAction.IsPositionDependent">
            <summary>Gets whether the lexer action is position-dependent.</summary>
            <remarks>
            Gets whether the lexer action is position-dependent. Position-dependent
            actions may have different semantics depending on the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            index at the time the action is executed.
            <p>Many lexer commands, including
            <c>type</c>
            ,
            <c>skip</c>
            , and
            <c>more</c>
            , do not check the input index during their execution.
            Actions like this are position-independent, and may be stored more
            efficiently as part of the
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.ActionExecutor"/>
            .</p>
            </remarks>
            <returns>

            <see langword="true"/>
            if the lexer action semantics can be affected by the
            position of the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            at the time it is executed;
            otherwise,
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ILexerAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            Execute the lexer action in the context of the specified
            <see cref="T:Antlr4.Runtime.Lexer"/>
            .
            <p>For position-dependent actions, the input stream must already be
            positioned correctly prior to calling this method.</p>
            </summary>
            <param name="lexer">The lexer instance.</param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerActionExecutor">
            <summary>
            Represents an executor for a sequence of lexer actions which traversed during
            the matching operation of a lexer rule (token).
            </summary>
            <remarks>
            Represents an executor for a sequence of lexer actions which traversed during
            the matching operation of a lexer rule (token).
            <p>The executor tracks position information for position-dependent lexer actions
            efficiently, ensuring that actions appearing only at the end of the rule do
            not cause bloating of the
            <see cref="T:Antlr4.Runtime.Dfa.DFA"/>
            created for the lexer.</p>
            </remarks>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerActionExecutor.hashCode">
            <summary>
            Caches the result of
            <see cref="F:Antlr4.Runtime.Atn.LexerActionExecutor.hashCode"/>
            since the hash code is an element
            of the performance-critical
            <see cref="M:Antlr4.Runtime.Atn.ATNConfig.GetHashCode"/>
            operation.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.#ctor(Antlr4.Runtime.Atn.ILexerAction[])">
            <summary>
            Constructs an executor for a sequence of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            actions.
            </summary>
            <param name="lexerActions">The lexer actions to execute.</param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.Append(Antlr4.Runtime.Atn.LexerActionExecutor,Antlr4.Runtime.Atn.ILexerAction)">
            <summary>
            Creates a
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which executes the actions for
            the input
            <paramref name="lexerActionExecutor"/>
            followed by a specified
            <paramref name="lexerAction"/>
            .
            </summary>
            <param name="lexerActionExecutor">
            The executor for actions already traversed by
            the lexer while matching a token within a particular
            <see cref="T:Antlr4.Runtime.Atn.ATNConfig"/>
            . If this is
            <see langword="null"/>
            , the method behaves as though
            it were an empty executor.
            </param>
            <param name="lexerAction">
            The lexer action to execute after the actions
            specified in
            <paramref name="lexerActionExecutor"/>
            .
            </param>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            for executing the combine actions
            of
            <paramref name="lexerActionExecutor"/>
            and
            <paramref name="lexerAction"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.FixOffsetBeforeMatch(System.Int32)">
            <summary>
            Creates a
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which encodes the current offset
            for position-dependent lexer actions.
            <p>Normally, when the executor encounters lexer actions where
            <see cref="P:Antlr4.Runtime.Atn.ILexerAction.IsPositionDependent"/>
            returns
            <see langword="true"/>
            , it calls
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
            on the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            to set the input
            position to the <em>end</em> of the current token. This behavior provides
            for efficient DFA representation of lexer actions which appear at the end
            of a lexer rule, even when the lexer rule matches a variable number of
            characters.</p>
            <p>Prior to traversing a match transition in the ATN, the current offset
            from the token start index is assigned to all position-dependent lexer
            actions which have not already been assigned a fixed offset. By storing
            the offsets relative to the token start index, the DFA representation of
            lexer actions which appear in the middle of tokens remains efficient due
            to sharing among tokens of the same length, regardless of their absolute
            position in the input stream.</p>
            <p>If the current executor already has offsets assigned to all
            position-dependent lexer actions, the method returns
            <c>this</c>
            .</p>
            </summary>
            <param name="offset">
            The current offset to assign to all position-dependent
            lexer actions which do not already have offsets assigned.
            </param>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which stores input stream offsets
            for all position-dependent lexer actions.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerActionExecutor.LexerActions">
            <summary>Gets the lexer actions to be executed by this executor.</summary>
            <remarks>Gets the lexer actions to be executed by this executor.</remarks>
            <returns>The lexer actions to be executed by this executor.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.Execute(Antlr4.Runtime.Lexer,Antlr4.Runtime.ICharStream,System.Int32)">
            <summary>
            Execute the actions encapsulated by this executor within the context of a
            particular
            <see cref="T:Antlr4.Runtime.Lexer"/>
            .
            <p>This method calls
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
            to set the position of the
            <paramref name="input"/>

            <see cref="T:Antlr4.Runtime.ICharStream"/>
            prior to calling
            <see cref="M:Antlr4.Runtime.Atn.ILexerAction.Execute(Antlr4.Runtime.Lexer)"/>
            on a position-dependent action. Before the
            method returns, the input position will be restored to the same position
            it was in when the method was invoked.</p>
            </summary>
            <param name="lexer">The lexer instance.</param>
            <param name="input">
            The input stream which is the source for the current token.
            When this method is called, the current
            <see cref="P:Antlr4.Runtime.IIntStream.Index"/>
            for
            <paramref name="input"/>
            should be the start of the following token, i.e. 1
            character past the end of the current token.
            </param>
            <param name="startIndex">
            The token start index. This value may be passed to
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
            to set the
            <paramref name="input"/>
            position to the beginning
            of the token.
            </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerActionType">
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerATNSimulator">
            <summary>"dup" of ParserInterpreter</summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerATNSimulator.SimState">
            <summary>
            When we hit an accept state in either the DFA or the ATN, we
            have to notify the character stream to start buffering characters
            via
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            and record the current state. The current sim state
            includes the current index into the input, the current line,
            and current character position in that line. Note that the Lexer is
            tracking the starting line and characterization of the token. These
            variables track the "state" of the simulator when it hits an accept state.
            <p>We track these variables separately for the DFA and ATN simulation
            because the DFA simulation often has to fail over to the ATN
            simulation. If the ATN simulation fails, we need the DFA to fall
            back to its previously accepted state, if any. If the ATN succeeds,
            then the ATN does the accept and the DFA simulator that invoked it
            can simply return the predicted token type.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.startIndex">
            <summary>The current token's starting index into the character stream.</summary>
            <remarks>
            The current token's starting index into the character stream.
            Shared across DFA to ATN simulation in case the ATN fails and the
            DFA did not have a previous accept state. In this case, we use the
            ATN-generated exception object.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator._line">
            <summary>line number 1..n within the input</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.charPositionInLine">
            <summary>The index of the character relative to the beginning of the line 0..n-1</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.prevAccept">
            <summary>Used during DFA/ATN exec to record the most recent accept configuration info</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)">
            <summary>Get an existing target state for an edge in the DFA.</summary>
            <remarks>
            Get an existing target state for an edge in the DFA. If the target state
            for the edge has not yet been computed or is otherwise not available,
            this method returns
            <see langword="null"/>
            .
            </remarks>
            <param name="s">The current DFA state</param>
            <param name="t">The next input symbol</param>
            <returns>
            The existing target DFA state for the given input symbol
            <paramref name="t"/>
            , or
            <see langword="null"/>
            if the target state for this edge is not
            already cached
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.ComputeTargetState(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Dfa.DFAState,System.Int32)">
            <summary>
            Compute a target state for an edge in the DFA, and attempt to add the
            computed state and corresponding edge to the DFA.
            </summary>
            <remarks>
            Compute a target state for an edge in the DFA, and attempt to add the
            computed state and corresponding edge to the DFA.
            </remarks>
            <param name="input">The input stream</param>
            <param name="s">The current DFA state</param>
            <param name="t">The next input symbol</param>
            <returns>
            The computed target DFA state for the given input symbol
            <paramref name="t"/>
            . If
            <paramref name="t"/>
            does not lead to a valid DFA state, this method
            returns
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.Error"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetReachableConfigSet(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)">
            <summary>
            Given a starting configuration set, figure out all ATN configurations
            we can reach upon input
            <paramref name="t"/>
            . Parameter
            <paramref name="reach"/>
            is a return
            parameter.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.Closure(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Atn.ATNConfig,Antlr4.Runtime.Atn.ATNConfigSet,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Since the alternatives within any lexer decision are ordered by
            preference, this method stops pursuing the closure as soon as an accept
            state is reached.
            </summary>
            <remarks>
            Since the alternatives within any lexer decision are ordered by
            preference, this method stops pursuing the closure as soon as an accept
            state is reached. After the first accept state is reached by depth-first
            search from
            <paramref name="config"/>
            , all other (potentially reachable) states for
            this rule would have a lower priority.
            </remarks>
            <returns>

            <see langword="true"/>
            if an accept state is reached, otherwise
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.EvaluatePredicate(Antlr4.Runtime.ICharStream,System.Int32,System.Int32,System.Boolean)">
            <summary>Evaluate a predicate specified in the lexer.</summary>
            <remarks>
            Evaluate a predicate specified in the lexer.
            <p>If
            <paramref name="speculative"/>
            is
            <see langword="true"/>
            , this method was called before
            <see cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.Consume(Antlr4.Runtime.ICharStream)"/>
            for the matched character. This method should call
            <see cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.Consume(Antlr4.Runtime.ICharStream)"/>
            before evaluating the predicate to ensure position
            sensitive values, including
            <see cref="P:Antlr4.Runtime.Lexer.Text"/>
            ,
            <see cref="P:Antlr4.Runtime.Lexer.Line"/>
            ,
            and
            <see cref="P:Antlr4.Runtime.Lexer.Column"/>
            , properly reflect the current
            lexer state. This method should restore
            <paramref name="input"/>
            and the simulator
            to the original state before returning (i.e. undo the actions made by the
            call to
            <see cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.Consume(Antlr4.Runtime.ICharStream)"/>
            .</p>
            </remarks>
            <param name="input">The input stream.</param>
            <param name="ruleIndex">The rule containing the predicate.</param>
            <param name="predIndex">The index of the predicate within the rule.</param>
            <param name="speculative">

            <see langword="true"/>
            if the current index in
            <paramref name="input"/>
            is
            one character before the predicate's location.
            </param>
            <returns>

            <see langword="true"/>
            if the specified predicate evaluates to
            <see langword="true"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.AddDFAState(Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>
            Add a new DFA state if there isn't one with this set of
            configurations already.
            </summary>
            <remarks>
            Add a new DFA state if there isn't one with this set of
            configurations already. This method also detects the first
            configuration containing an ATN rule stop state. Later, when
            traversing the DFA, we will know which rule to accept.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetText(Antlr4.Runtime.ICharStream)">
            <summary>Get the text matched so far for the current token.</summary>
            <remarks>Get the text matched so far for the current token.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerChannelAction">
            <summary>
            Implements the
            <c>channel</c>
            lexer action by calling
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            with the assigned channel.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerChannelAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <paramref name="channel"/>
            action with the specified channel value.
            </summary>
            <param name="channel">
            The channel value to pass to
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerChannelAction.Channel">
            <summary>
            Gets the channel to use for the
            <see cref="T:Antlr4.Runtime.IToken"/>
            created by the lexer.
            </summary>
            <returns>
            The channel to use for the
            <see cref="T:Antlr4.Runtime.IToken"/>
            created by the lexer.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerChannelAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Channel"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerChannelAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerChannelAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerChannelAction.Channel"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerCustomAction">
            <summary>
            Executes a custom lexer action by calling
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            with the
            rule and action indexes assigned to the custom action. The implementation of
            a custom action is added to the generated code for the lexer in an override
            of
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            when the grammar is compiled.
            <p>This class may represent embedded actions created with the <code>{...}</code>
            syntax in ANTLR 4, as well as actions created for lexer commands where the
            command argument could not be evaluated when the grammar was compiled.</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerCustomAction.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a custom lexer action with the specified rule and action
            indexes.
            </summary>
            <remarks>
            Constructs a custom lexer action with the specified rule and action
            indexes.
            </remarks>
            <param name="ruleIndex">
            The rule index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </param>
            <param name="actionIndex">
            The action index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.RuleIndex">
            <summary>
            Gets the rule index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </summary>
            <returns>The rule index for the custom action.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.ActionIndex">
            <summary>
            Gets the action index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </summary>
            <returns>The action index for the custom action.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Custom"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.IsPositionDependent">
            <summary>Gets whether the lexer action is position-dependent.</summary>
            <remarks>
            Gets whether the lexer action is position-dependent. Position-dependent
            actions may have different semantics depending on the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            index at the time the action is executed.
            <p>Custom actions are position-dependent since they may represent a
            user-defined embedded action which makes calls to methods like
            <see cref="P:Antlr4.Runtime.Lexer.Text"/>
            .</p>
            </remarks>
            <returns>
            This method returns
            <see langword="true"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerCustomAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>Custom actions are implemented by calling
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            with the
            appropriate rule and action indexes.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerIndexedCustomAction">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            is used for tracking input offsets
            for position-dependent actions within a
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            .
            <p>This action is not serialized as part of the ATN, and is only required for
            position-dependent lexer actions which appear at a location other than the
            end of a rule. For more information about DFA optimizations employed for
            lexer actions, see
            <see cref="M:Antlr4.Runtime.Atn.LexerActionExecutor.Append(Antlr4.Runtime.Atn.LexerActionExecutor,Antlr4.Runtime.Atn.ILexerAction)"/>
            and
            <see cref="M:Antlr4.Runtime.Atn.LexerActionExecutor.FixOffsetBeforeMatch(System.Int32)"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerIndexedCustomAction.#ctor(System.Int32,Antlr4.Runtime.Atn.ILexerAction)">
            <summary>
            Constructs a new indexed custom action by associating a character offset
            with a
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            .
            <p>Note: This class is only required for lexer actions for which
            <see cref="P:Antlr4.Runtime.Atn.ILexerAction.IsPositionDependent"/>
            returns
            <see langword="true"/>
            .</p>
            </summary>
            <param name="offset">
            The offset into the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            , relative to
            the token start index, at which the specified lexer action should be
            executed.
            </param>
            <param name="action">
            The lexer action to execute at a particular offset in the
            input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Offset">
            <summary>
            Gets the location in the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            at which the lexer
            action should be executed. The value is interpreted as an offset relative
            to the token start index.
            </summary>
            <returns>
            The location in the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            at which the lexer
            action should be executed.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Action">
            <summary>Gets the lexer action to execute.</summary>
            <remarks>Gets the lexer action to execute.</remarks>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            object which executes the lexer action.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns the result of calling
            <see cref="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.ActionType"/>
            on the
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            returned by
            <see cref="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Action"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="true"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This method calls
            <see cref="M:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Execute(Antlr4.Runtime.Lexer)"/>
            on the result of
            <see cref="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Action"/>
            using the provided
            <paramref name="lexer"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerModeAction">
            <summary>
            Implements the
            <c>mode</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.Mode(System.Int32)"/>
            with
            the assigned mode.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerModeAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <paramref name="mode"/>
            action with the specified mode value.
            </summary>
            <param name="mode">
            The mode value to pass to
            <see cref="M:Antlr4.Runtime.Lexer.Mode(System.Int32)"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerModeAction.Mode">
            <summary>Get the lexer mode this action should transition the lexer to.</summary>
            <remarks>Get the lexer mode this action should transition the lexer to.</remarks>
            <returns>
            The lexer mode for this
            <c>mode</c>
            command.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerModeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Mode"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerModeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerModeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.Mode(System.Int32)"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerModeAction.Mode"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerMoreAction">
            <summary>
            Implements the
            <c>more</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.More"/>
            .
            <p>The
            <c>more</c>
            command does not have any parameters, so this action is
            implemented as a singleton instance exposed by
            <see cref="F:Antlr4.Runtime.Atn.LexerMoreAction.Instance"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerMoreAction.Instance">
            <summary>Provides a singleton instance of this parameterless lexer action.</summary>
            <remarks>Provides a singleton instance of this parameterless lexer action.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerMoreAction.#ctor">
            <summary>
            Constructs the singleton instance of the lexer
            <c>more</c>
            command.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerMoreAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.More"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerMoreAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerMoreAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.More"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerPopModeAction">
            <summary>
            Implements the
            <c>popMode</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.PopMode"/>
            .
            <p>The
            <c>popMode</c>
            command does not have any parameters, so this action is
            implemented as a singleton instance exposed by
            <see cref="F:Antlr4.Runtime.Atn.LexerPopModeAction.Instance"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerPopModeAction.Instance">
            <summary>Provides a singleton instance of this parameterless lexer action.</summary>
            <remarks>Provides a singleton instance of this parameterless lexer action.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPopModeAction.#ctor">
            <summary>
            Constructs the singleton instance of the lexer
            <c>popMode</c>
            command.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPopModeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.PopMode"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPopModeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPopModeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.PopMode"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerPushModeAction">
            <summary>
            Implements the
            <c>pushMode</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.PushMode(System.Int32)"/>
            with the assigned mode.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPushModeAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <c>pushMode</c>
            action with the specified mode value.
            </summary>
            <param name="mode">
            The mode value to pass to
            <see cref="M:Antlr4.Runtime.Lexer.PushMode(System.Int32)"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPushModeAction.Mode">
            <summary>Get the lexer mode this action should transition the lexer to.</summary>
            <remarks>Get the lexer mode this action should transition the lexer to.</remarks>
            <returns>
            The lexer mode for this
            <c>pushMode</c>
            command.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPushModeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.PushMode"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPushModeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPushModeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.PushMode(System.Int32)"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerPushModeAction.Mode"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerSkipAction">
            <summary>
            Implements the
            <c>skip</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.Skip"/>
            .
            <p>The
            <c>skip</c>
            command does not have any parameters, so this action is
            implemented as a singleton instance exposed by
            <see cref="F:Antlr4.Runtime.Atn.LexerSkipAction.Instance"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerSkipAction.Instance">
            <summary>Provides a singleton instance of this parameterless lexer action.</summary>
            <remarks>Provides a singleton instance of this parameterless lexer action.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerSkipAction.#ctor">
            <summary>
            Constructs the singleton instance of the lexer
            <c>skip</c>
            command.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerSkipAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Skip"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerSkipAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerSkipAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.Skip"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerTypeAction">
            <summary>
            Implements the
            <c>type</c>
            lexer action by calling
            <see cref="P:Antlr4.Runtime.Lexer.Type"/>
            with the assigned type.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerTypeAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <paramref name="type"/>
            action with the specified token type value.
            </summary>
            <param name="type">
            The type to assign to the token using
            <see cref="P:Antlr4.Runtime.Lexer.Type"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerTypeAction.Type">
            <summary>Gets the type to assign to a token created by the lexer.</summary>
            <remarks>Gets the type to assign to a token created by the lexer.</remarks>
            <returns>The type to assign to a token created by the lexer.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerTypeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Type"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerTypeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerTypeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="P:Antlr4.Runtime.Lexer.Type"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerTypeAction.Type"/>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LL1Analyzer.HitPred">
            <summary>
            Special value added to the lookahead sets to indicate that we hit
            a predicate during analysis if
            <c>seeThruPreds==false</c>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.GetDecisionLookahead(Antlr4.Runtime.Atn.ATNState)">
            <summary>
            Calculates the SLL(1) expected lookahead set for each outgoing transition
            of an
            <see cref="T:Antlr4.Runtime.Atn.ATNState"/>
            . The returned array has one element for each
            outgoing transition in
            <paramref name="s"/>
            . If the closure from transition
            <em>i</em> leads to a semantic predicate before matching a symbol, the
            element at index <em>i</em> of the result will be
            <see langword="null"/>
            .
            </summary>
            <param name="s">the ATN state</param>
            <returns>
            the expected symbols for each outgoing transition of
            <paramref name="s"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext)">
            <summary>
            Compute set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            <p>If
            <paramref name="ctx"/>
            is
            <see langword="null"/>
            and the end of the rule containing
            <paramref name="s"/>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Epsilon"/>
            is added to the result set.
            If
            <paramref name="ctx"/>
            is not
            <see langword="null"/>
            and the end of the outermost rule is
            reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            is added to the result set.</p>
            </summary>
            <param name="s">the ATN state</param>
            <param name="ctx">
            the complete parser context, or
            <see langword="null"/>
            if the context
            should be ignored
            </param>
            <returns>
            The set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext)">
            <summary>
            Compute set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            <p>If
            <paramref name="ctx"/>
            is
            <see langword="null"/>
            and the end of the rule containing
            <paramref name="s"/>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Epsilon"/>
            is added to the result set.
            If
            <paramref name="ctx"/>
            is not
            <c>PredictionContext#EMPTY_LOCAL</c>
            and the end of the outermost rule is
            reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            is added to the result set.</p>
            </summary>
            <param name="s">the ATN state</param>
            <param name="stopState">
            the ATN state to stop at. This can be a
            <see cref="T:Antlr4.Runtime.Atn.BlockEndState"/>
            to detect epsilon paths through a closure.
            </param>
            <param name="ctx">
            the complete parser context, or
            <see langword="null"/>
            if the context
            should be ignored
            </param>
            <returns>
            The set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext,Antlr4.Runtime.Misc.IntervalSet,System.Collections.Generic.HashSet{Antlr4.Runtime.Atn.ATNConfig},Antlr4.Runtime.Sharpen.BitSet,System.Boolean,System.Boolean)">
            <summary>
            Compute set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            <p/>
            If
            <paramref name="ctx"/>
            is
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal"/>
            and
            <paramref name="stopState"/>
            or the end of the rule containing
            <paramref name="s"/>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Epsilon"/>
            is added to the result set. If
            <paramref name="ctx"/>
            is not
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal"/>
            and
            <paramref name="addEOF"/>
            is
            <see langword="true"/>
            and
            <paramref name="stopState"/>
            or the end of the outermost rule is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            is added to the result set.
            </summary>
            <param name="s">the ATN state.</param>
            <param name="stopState">
            the ATN state to stop at. This can be a
            <see cref="T:Antlr4.Runtime.Atn.BlockEndState"/>
            to detect epsilon paths through a closure.
            </param>
            <param name="ctx">
            The outer context, or
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal"/>
            if
            the outer context should not be used.
            </param>
            <param name="look">The result lookahead set.</param>
            <param name="lookBusy">
            A set used for preventing epsilon closures in the ATN
            from causing a stack overflow. Outside code should pass
            <c>new HashSet&lt;ATNConfig&gt;</c>
            for this argument.
            </param>
            <param name="calledRuleStack">
            A set used for preventing left recursion in the
            ATN from causing a stack overflow. Outside code should pass
            <c>new BitSet()</c>
            for this argument.
            </param>
            <param name="seeThruPreds">

            <see langword="true"/>
            to true semantic predicates as
            implicitly
            <see langword="true"/>
            and "see through them", otherwise
            <see langword="false"/>
            to treat semantic predicates as opaque and add
            <see cref="F:Antlr4.Runtime.Atn.LL1Analyzer.HitPred"/>
            to the
            result if one is encountered.
            </param>
            <param name="addEOF">
            Add
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            to the result if the end of the
            outermost context is reached. This parameter has no effect if
            <paramref name="ctx"/>
            is
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal"/>
            .
            </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LookaheadEventInfo">
            <summary>
            This class represents profiling event information for tracking the lookahead
            depth required in order to make a prediction.
            </summary>
            <remarks>
            This class represents profiling event information for tracking the lookahead
            depth required in order to make a prediction.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LookaheadEventInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.LookaheadEventInfo"/>
            class with
            the specified detailed lookahead information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state containing the necessary
            information to determine the result of a prediction, or
            <see langword="null"/>
            if
            the final state is not available
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">The index at which the prediction was finally made</param>
            <param name="fullCtx">

            <see langword="true"/>
            if the current lookahead is part of an LL
            prediction; otherwise,
            <see langword="false"/>
            if the current lookahead is part of
            an SLL prediction
            </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LoopEndState">
            <summary>Mark the end of a * or + loop.</summary>
            <remarks>Mark the end of a * or + loop.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.OrderedATNConfigSet">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ParseInfo">
            <summary>
            This class provides access to specific and aggregate statistics gathered
            during profiling of a parser.
            </summary>
            <remarks>
            This class provides access to specific and aggregate statistics gathered
            during profiling of a parser.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ParseInfo.DecisionInfo">
            <summary>
            Gets an array of
            <see cref="P:Antlr4.Runtime.Atn.ParseInfo.DecisionInfo"/>
            instances containing the profiling
            information gathered for each decision in the ATN.
            </summary>
            <returns>
            An array of
            <see cref="P:Antlr4.Runtime.Atn.ParseInfo.DecisionInfo"/>
            instances, indexed by decision
            number.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetLLDecisions">
            <summary>
            Gets the decision numbers for decisions that required one or more
            full-context predictions during parsing.
            </summary>
            <remarks>
            Gets the decision numbers for decisions that required one or more
            full-context predictions during parsing. These are decisions for which
            <see cref="F:Antlr4.Runtime.Atn.DecisionInfo.LL_Fallback"/>
            is non-zero.
            </remarks>
            <returns>
            A list of decision numbers which required one or more
            full-context predictions during parsing.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalSLLLookaheadOps">
            <summary>
            Gets the total number of SLL lookahead operations across all decisions
            made during parsing.
            </summary>
            <remarks>
            Gets the total number of SLL lookahead operations across all decisions
            made during parsing. This value is the sum of
            <see cref="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_TotalLook"/>
            for all decisions.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalLLLookaheadOps">
            <summary>
            Gets the total number of LL lookahead operations across all decisions
            made during parsing.
            </summary>
            <remarks>
            Gets the total number of LL lookahead operations across all decisions
            made during parsing. This value is the sum of
            <see cref="F:Antlr4.Runtime.Atn.DecisionInfo.LL_TotalLook"/>
            for all decisions.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalSLLATNLookaheadOps">
            <summary>
            Gets the total number of ATN lookahead operations for SLL prediction
            across all decisions made during parsing.
            </summary>
            <remarks>
            Gets the total number of ATN lookahead operations for SLL prediction
            across all decisions made during parsing.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalLLATNLookaheadOps">
            <summary>
            Gets the total number of ATN lookahead operations for LL prediction
            across all decisions made during parsing.
            </summary>
            <remarks>
            Gets the total number of ATN lookahead operations for LL prediction
            across all decisions made during parsing.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalATNLookaheadOps">
            <summary>
            Gets the total number of ATN lookahead operations for SLL and LL
            prediction across all decisions made during parsing.
            </summary>
            <remarks>
            Gets the total number of ATN lookahead operations for SLL and LL
            prediction across all decisions made during parsing.
            <p>
            This value is the sum of
            <see cref="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalSLLATNLookaheadOps"/>
            and
            <see cref="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalLLATNLookaheadOps"/>
            .</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetDFASize">
            <summary>
            Gets the total number of DFA states stored in the DFA cache for all
            decisions in the ATN.
            </summary>
            <remarks>
            Gets the total number of DFA states stored in the DFA cache for all
            decisions in the ATN.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetDFASize(System.Int32)">
            <summary>
            Gets the total number of DFA states stored in the DFA cache for a
            particular decision.
            </summary>
            <remarks>
            Gets the total number of DFA states stored in the DFA cache for a
            particular decision.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ParserATNSimulator">
            <summary>The embodiment of the adaptive LL(*), ALL(*), parsing strategy.</summary>
            <remarks>
            The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
            <p>
            The basic complexity of the adaptive strategy makes it harder to understand.
            We begin with ATN simulation to build paths in a DFA. Subsequent prediction
            requests go through the DFA first. If they reach a state without an edge for
            the current symbol, the algorithm fails over to the ATN simulation to
            complete the DFA path for the current input (until it finds a conflict state
            or uniquely predicting state).</p>
            <p>
            All of that is done without using the outer context because we want to create
            a DFA that is not dependent upon the rule invocation stack when we do a
            prediction. One DFA works in all contexts. We avoid using context not
            necessarily because it's slower, although it can be, but because of the DFA
            caching problem. The closure routine only considers the rule invocation stack
            created during prediction beginning in the decision rule. For example, if
            prediction occurs without invoking another rule's ATN, there are no context
            stacks in the configurations. When lack of context leads to a conflict, we
            don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
            strategy (versus full LL(*)).</p>
            <p>
            When SLL yields a configuration set with conflict, we rewind the input and
            retry the ATN simulation, this time using full outer context without adding
            to the DFA. Configuration context stacks will be the full invocation stacks
            from the start rule. If we get a conflict using full context, then we can
            definitively say we have a true ambiguity for that input sequence. If we
            don't get a conflict, it implies that the decision is sensitive to the outer
            context. (It is not context-sensitive in the sense of context-sensitive
            grammars.)</p>
            <p>
            The next time we reach this DFA state with an SLL conflict, through DFA
            simulation, we will again retry the ATN simulation using full context mode.
            This is slow because we can't save the results and have to "interpret" the
            ATN each time we get that input.</p>
            <p>
            <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>
            <p>
            We could cache results from full context to predicted alternative easily and
            that saves a lot of time but doesn't work in presence of predicates. The set
            of visible predicates from the ATN start state changes depending on the
            context, because closure can fall off the end of a rule. I tried to cache
            tuples (stack context, semantic context, predicted alt) but it was slower
            than interpreting and much more complicated. Also required a huge amount of
            memory. The goal is not to create the world's fastest parser anyway. I'd like
            to keep this algorithm simple. By launching multiple threads, we can improve
            the speed of parsing across a large number of files.</p>
            <p>
            There is no strict ordering between the amount of input used by SLL vs LL,
            which makes it really hard to build a cache for full context. Let's say that
            we have input A B C that leads to an SLL conflict with full context X. That
            implies that using X we might only use A B but we could also use A B C D to
            resolve conflict. Input A B C D could predict alternative 1 in one position
            in the input and A B C E could predict alternative 2 in another position in
            input. The conflicting SLL configurations could still be non-unique in the
            full context prediction, which would lead us to requiring more input than the
            original A B C.	To make a	prediction cache work, we have to track	the exact
            input	used during the previous prediction. That amounts to a cache that maps
            X to a specific DFA for that context.</p>
            <p>
            Something should be done for left-recursive expression predictions. They are
            likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
            with full LL thing Sam does.</p>
            <p>
            <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>
            <p>
            We avoid doing full context retry when the outer context is empty, we did not
            dip into the outer context by falling off the end of the decision state rule,
            or when we force SLL mode.</p>
            <p>
            As an example of the not dip into outer context case, consider as super
            constructor calls versus function calls. One grammar might look like
            this:</p>
            <pre>
            ctorBody
            : '{' superCall? stat* '}'
            ;
            </pre>
            <p>
            Or, you might see something like</p>
            <pre>
            stat
            : superCall ';'
            | expression ';'
            | ...
            ;
            </pre>
            <p>
            In both cases I believe that no closure operations will dip into the outer
            context. In the first case ctorBody in the worst case will stop at the '}'.
            In the 2nd case it should stop at the ';'. Both cases should stay within the
            entry rule and not dip into the outer context.</p>
            <p>
            <strong>PREDICATES</strong></p>
            <p>
            Predicates are always evaluated if present in either SLL or LL both. SLL and
            LL simulation deals with predicates differently. SLL collects predicates as
            it performs closure operations like ANTLR v3 did. It delays predicate
            evaluation until it reaches and accept state. This allows us to cache the SLL
            ATN simulation whereas, if we had evaluated predicates on-the-fly during
            closure, the DFA state configuration sets would be different and we couldn't
            build up a suitable DFA.</p>
            <p>
            When building a DFA accept state during ATN simulation, we evaluate any
            predicates and return the sole semantically valid alternative. If there is
            more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
            we throw an exception. Alternatives without predicates act like they have
            true predicates. The simple way to think about it is to strip away all
            alternatives with false predicates and choose the minimum alternative that
            remains.</p>
            <p>
            When we start in the DFA and reach an accept state that's predicated, we test
            those and return the minimum semantically viable alternative. If no
            alternatives are viable, we throw an exception.</p>
            <p>
            During full LL ATN simulation, closure always evaluates predicates and
            on-the-fly. This is crucial to reducing the configuration set size during
            closure. It hits a landmine when parsing with the Java grammar, for example,
            without this on-the-fly evaluation.</p>
            <p>
            <strong>SHARING DFA</strong></p>
            <p>
            All instances of the same parser share the same decision DFAs through a
            static field. Each instance gets its own ATN simulator but they share the
            same
            <see cref="F:Antlr4.Runtime.Atn.ATN.decisionToDFA"/>
            field. They also share a
            <see cref="T:Antlr4.Runtime.Atn.PredictionContextCache"/>
            object that makes sure that all
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext"/>
            objects are shared among the DFA states. This makes
            a big size difference.</p>
            <p>
            <strong>THREAD SAFETY</strong></p>
            <p>
            The
            <see cref="T:Antlr4.Runtime.Atn.ParserATNSimulator"/>
            locks on the
            <see cref="F:Antlr4.Runtime.Atn.ATN.decisionToDFA"/>
            field when
            it adds a new DFA object to that array.
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAEdge(Antlr4.Runtime.Dfa.DFAState,System.Int32,Antlr4.Runtime.Dfa.DFAState)"/>
            locks on the DFA for the current decision when setting the
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.edges"/>
            field.
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)"/>
            locks on
            the DFA for the current decision when looking up a DFA state to see if it
            already exists. We must make sure that all requests to add DFA states that
            are equivalent result in the same shared DFA object. This is because lots of
            threads will be trying to update the DFA at once. The
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)"/>
            method also locks inside the DFA lock
            but this time on the shared context cache when it rebuilds the
            configurations'
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext"/>
            objects using cached
            subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
            safe as long as we can guarantee that all threads referencing
            <c>s.edge[t]</c>
            get the same physical target
            <see cref="T:Antlr4.Runtime.Dfa.DFAState"/>
            , or
            <see langword="null"/>
            . Once into the DFA, the DFA simulation does not reference the
            <see cref="F:Antlr4.Runtime.Dfa.DFA.states"/>
            map. It follows the
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.edges"/>
            field to new
            targets. The DFA simulator will either find
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.edges"/>
            to be
            <see langword="null"/>
            , to be non-
            <see langword="null"/>
            and
            <c>dfa.edges[t]</c>
            null, or
            <c>dfa.edges[t]</c>
            to be non-null. The
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAEdge(Antlr4.Runtime.Dfa.DFAState,System.Int32,Antlr4.Runtime.Dfa.DFAState)"/>
            method could be racing to set the field
            but in either case the DFA simulator works; if
            <see langword="null"/>
            , and requests ATN
            simulation. It could also race trying to get
            <c>dfa.edges[t]</c>
            , but either
            way it will work because it's not doing a test and set operation.</p>
            <p>
            <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
            Parsing)</strong></p>
            <p>
            Sam pointed out that if SLL does not give a syntax error, then there is no
            point in doing full LL, which is slower. We only have to try LL if we get a
            syntax error. For maximum speed, Sam starts the parser set to pure SLL
            mode with the
            <see cref="T:Antlr4.Runtime.BailErrorStrategy"/>
            :</p>
            <pre>
            parser.
            <see cref="P:Antlr4.Runtime.Recognizer`2.Interpreter">getInterpreter()</see>
            .
            <see cref="P:Antlr4.Runtime.Atn.ParserATNSimulator.PredictionMode"/>
            <c>(</c>
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Sll"/>
            <c>)</c>
            ;
            parser.
            (new
            <see cref="T:Antlr4.Runtime.BailErrorStrategy"/>
            ());
            </pre>
            <p>
            If it does not get a syntax error, then we're done. If it does get a syntax
            error, we need to retry with the combined SLL/LL strategy.</p>
            <p>
            The reason this works is as follows. If there are no SLL conflicts, then the
            grammar is SLL (at least for that input set). If there is an SLL conflict,
            the full LL analysis must yield a set of viable alternatives which is a
            subset of the alternatives reported by SLL. If the LL set is a singleton,
            then the grammar is LL but not SLL. If the LL set is the same size as the SLL
            set, the decision is SLL. If the LL set has size &gt; 1, then that decision
            is truly ambiguous on the current input. If the LL set is smaller, then the
            SLL conflict resolution might choose an alternative that the full LL would
            rule out as a possibility based upon better context information. If that's
            the case, then the SLL parse will definitely get an error because the full LL
            analysis says it's not viable. If SLL conflict resolution chooses an
            alternative within the LL set, them both SLL and LL would choose the same
            alternative because they both choose the minimum of multiple conflicting
            alternatives.</p>
            <p>
            Let's say we have a set of SLL conflicting alternatives
            <c/>

            1, 2, 3}} and
            a smaller LL set called <em>s</em>. If <em>s</em> is
            <c/>

            2, 3}}, then SLL
            parsing will get an error because SLL will pursue alternative 1. If
            <em>s</em> is
            <c/>

            1, 2}} or
            <c/>

            1, 3}} then both SLL and LL will
            choose the same alternative because alternative one is the minimum of either
            set. If <em>s</em> is
            <c/>

            2}} or
            <c/>

            3}} then SLL will get a syntax
            error. If <em>s</em> is
            <c/>

            1}} then SLL will succeed.</p>
            <p>
            Of course, if the input is invalid, then we will get an error for sure in
            both SLL and LL parsing. Erroneous input will therefore require 2 passes over
            the input.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ParserATNSimulator.enable_global_context_dfa">
            <summary>Determines whether the DFA is used for full-context predictions.</summary>
            <remarks>
            Determines whether the DFA is used for full-context predictions. When
            <see langword="true"/>
            , the DFA stores transition information for both full-context
            and SLL parsing; otherwise, the DFA only stores SLL transition
            information.
            <p>
            For some grammars, enabling the full-context DFA can result in a
            substantial performance improvement. However, this improvement typically
            comes at the expense of memory used for storing the cached DFA states,
            configuration sets, and prediction contexts.</p>
            <p>
            The default value is
            <see langword="false"/>
            .</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ParserATNSimulator.reportAmbiguities">
            <summary>
            When
            <see langword="true"/>
            , ambiguous alternatives are reported when they are
            encountered within
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ExecATN(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
            . When
            <see langword="false"/>
            , these messages
            are suppressed. The default is
            <see langword="false"/>
            .
            <p/>
            When messages about ambiguous alternatives are not required, setting this
            to
            <see langword="false"/>
            enables additional internal optimizations which may lose
            this information.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ParserATNSimulator.userWantsCtxSensitive">
            <summary>
            By default we do full context-sensitive LL(*) parsing not
            Strong LL(*) parsing.
            </summary>
            <remarks>
            By default we do full context-sensitive LL(*) parsing not
            Strong LL(*) parsing. If we fail with Strong LL(*) we
            try full LL(*). That means we rewind and use context information
            when closure operations fall off the end of the rule that
            holds the decision were evaluating.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.#ctor(Antlr4.Runtime.Atn.ATN)">
            <summary>Testing only!</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.IsAcceptState(Antlr4.Runtime.Dfa.DFAState,System.Boolean)">
            <summary>
            Determines if a particular DFA state should be treated as an accept state
            for the current prediction mode.
            </summary>
            <remarks>
            Determines if a particular DFA state should be treated as an accept state
            for the current prediction mode. In addition to the
            <paramref name="useContext"/>
            parameter, the
            <see cref="P:Antlr4.Runtime.Atn.ParserATNSimulator.PredictionMode"/>
            method provides the
            prediction mode controlling the prediction algorithm as a whole.
            <p>
            The default implementation simply returns the value of
            <see cref="P:Antlr4.Runtime.Dfa.DFAState.IsAcceptState"/>
            except for conflict states when
            <paramref name="useContext"/>
            is
            <see langword="true"/>
            and
            <see cref="P:Antlr4.Runtime.Atn.ParserATNSimulator.PredictionMode"/>
            is
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection"/>
            . In that case, only
            conflict states where
            <see cref="P:Antlr4.Runtime.Atn.ATNConfigSet.IsExactConflict"/>
            is
            <see langword="true"/>
            are considered accept states.
            </p>
            </remarks>
            <param name="state">The DFA state to check.</param>
            <param name="useContext">

            <see langword="true"/>
            if the prediction algorithm is currently
            considering the full parser context; otherwise,
            <see langword="false"/>
            if the
            algorithm is currently performing a local context prediction.
            </param>
            <returns>

            <see langword="true"/>
            if the specified
            <paramref name="state"/>
            is an accept state;
            otherwise,
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ExecATN(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            Performs ATN simulation to compute a predicted alternative based
            upon the remaining input, but also updates the DFA cache to avoid
            having to traverse the ATN again for the same input sequence.
            </summary>
            <remarks>
            Performs ATN simulation to compute a predicted alternative based
            upon the remaining input, but also updates the DFA cache to avoid
            having to traverse the ATN again for the same input sequence.
            There are some key conditions we're looking for after computing a new
            set of ATN configs (proposed DFA state):
            if the set is empty, there is no viable alternative for current symbol
            does the state uniquely predict an alternative?
            does the state have a conflict that would prevent us from
            putting it on the work list?
            if in non-greedy decision is there a config at a rule stop state?
            We also have some key operations to do:
            add an edge from previous DFA state to potentially new DFA state, D,
            upon current symbol but only if adding to work list, which means in all
            cases except no viable alternative (and possibly non-greedy decisions?)
            collecting predicates and adding semantic context to DFA accept states
            adding rule context to context-sensitive DFA accept states
            consuming an input symbol
            reporting a conflict
            reporting an ambiguity
            reporting a context sensitivity
            reporting insufficient predicates
            We should isolate those operations, which are side-effecting, to the
            main work loop. We can isolate lots of code into other functions, but
            they should be side effect free. They can return package that
            indicates whether we should report something, whether we need to add a
            DFA edge, whether we need to augment accept state with semantic
            context or rule invocation context. Actually, it seems like we always
            add predicates if they exist, so that can simply be done in the main
            loop for any accept state creation or modification request.
            cover these cases:
            dead end
            single alt
            single alt + preds
            conflict
            conflict + preds
            TODO: greedy + those
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.HandleNoViableAlt(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            This method is used to improve the localization of error messages by
            choosing an alternative rather than throwing a
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            in particular prediction scenarios where the
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.Error"/>
            state was reached during ATN simulation.
            <p>
            The default implementation of this method uses the following
            algorithm to identify an ATN configuration which successfully parsed the
            decision entry rule. Choosing such an alternative ensures that the
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            returned by the calling rule will be complete
            and valid, and the syntax error will be reported later at a more
            localized location.</p>
            <ul>
            <li>If no configuration in
            <c>configs</c>
            reached the end of the
            decision rule, return
            <see cref="F:Antlr4.Runtime.Atn.ATN.InvalidAltNumber"/>
            .</li>
            <li>If all configurations in
            <c>configs</c>
            which reached the end of the
            decision rule predict the same alternative, return that alternative.</li>
            <li>If the configurations in
            <c>configs</c>
            which reached the end of the
            decision rule predict multiple alternatives (call this <em>S</em>),
            choose an alternative in the following order.
            <ol>
            <li>Filter the configurations in
            <c>configs</c>
            to only those
            configurations which remain viable after evaluating semantic predicates.
            If the set of these filtered configurations which also reached the end of
            the decision rule is not empty, return the minimum alternative
            represented in this set.</li>
            <li>Otherwise, choose the minimum alternative in <em>S</em>.</li>
            </ol>
            </li>
            </ul>
            <p>
            In some scenarios, the algorithm described above could predict an
            alternative which will result in a
            <see cref="T:Antlr4.Runtime.FailedPredicateException"/>
            in
            parser. Specifically, this could occur if the <em>only</em> configuration
            capable of successfully parsing to the end of the decision rule is
            blocked by a semantic predicate. By choosing this alternative within
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AdaptivePredict(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)"/>
            instead of throwing a
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            , the resulting
            <see cref="T:Antlr4.Runtime.FailedPredicateException"/>
            in the parser will identify the specific
            predicate which is preventing the parser from successfully parsing the
            decision rule, which helps developers identify and correct logic errors
            in semantic predicates.
            </p>
            </summary>
            <param name="input">
            The input
            <see cref="T:Antlr4.Runtime.ITokenStream"/>
            </param>
            <param name="startIndex">
            The start index for the current prediction, which is
            the input index where any semantic context in
            <c>configs</c>
            should be
            evaluated
            </param>
            <param name="previous">
            The ATN simulation state immediately before the
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.Error"/>
            state was reached
            </param>
            <returns>
            The value to return from
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AdaptivePredict(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)"/>
            , or
            <see cref="F:Antlr4.Runtime.Atn.ATN.InvalidAltNumber"/>
            if a suitable alternative was not
            identified and
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AdaptivePredict(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)"/>
            should report an error instead.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)">
            <summary>Get an existing target state for an edge in the DFA.</summary>
            <remarks>
            Get an existing target state for an edge in the DFA. If the target state
            for the edge has not yet been computed or is otherwise not available,
            this method returns
            <see langword="null"/>
            .
            </remarks>
            <param name="s">The current DFA state</param>
            <param name="t">The next input symbol</param>
            <returns>
            The existing target DFA state for the given input symbol
            <paramref name="t"/>
            , or
            <see langword="null"/>
            if the target state for this edge is not
            already cached
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeTargetState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.ParserRuleContext,System.Int32,System.Boolean,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>
            Compute a target state for an edge in the DFA, and attempt to add the
            computed state and corresponding edge to the DFA.
            </summary>
            <remarks>
            Compute a target state for an edge in the DFA, and attempt to add the
            computed state and corresponding edge to the DFA.
            </remarks>
            <param name="dfa"/>
            <param name="s">The current DFA state</param>
            <param name="remainingGlobalContext"/>
            <param name="t">The next input symbol</param>
            <param name="useContext"/>
            <param name="contextCache"/>
            <returns>
            The computed target DFA state for the given input symbol
            <paramref name="t"/>
            . If
            <paramref name="t"/>
            does not lead to a valid DFA state, this method
            returns
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.Error"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.RemoveAllConfigsNotInRuleStopState(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>
            Return a configuration set containing only the configurations from
            <paramref name="configs"/>
            which are in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            . If all
            configurations in
            <paramref name="configs"/>
            are already in a rule stop state, this
            method simply returns
            <paramref name="configs"/>
            .
            </summary>
            <param name="configs">the configuration set to update</param>
            <param name="contextCache">
            the
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext"/>
            cache
            </param>
            <returns>

            <paramref name="configs"/>
            if all configurations in
            <paramref name="configs"/>
            are in a
            rule stop state, otherwise return a new configuration set containing only
            the configurations from
            <paramref name="configs"/>
            which are in a rule stop state
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ApplyPrecedenceFilter(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.ParserRuleContext,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>
            This method transforms the start state computed by
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeStartState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.ParserRuleContext,System.Boolean)"/>
            to the special start state used by a
            precedence DFA for a particular precedence value. The transformation
            process applies the following changes to the start state's configuration
            set.
            <ol>
            <li>Evaluate the precedence predicates for each configuration using
            <see cref="M:Antlr4.Runtime.Atn.SemanticContext.EvalPrecedence``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)"/>
            .</li>
            <li>When
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.PrecedenceFilterSuppressed"/>
            is
            <see langword="false"/>
            ,
            remove all configurations which predict an alternative greater than 1,
            for which another configuration that predicts alternative 1 is in the
            same ATN state with the same prediction context. This transformation is
            valid for the following reasons:
            <ul>
            <li>The closure block cannot contain any epsilon transitions which bypass
            the body of the closure, so all states reachable via alternative 1 are
            part of the precedence alternatives of the transformed left-recursive
            rule.</li>
            <li>The "primary" portion of a left recursive rule cannot contain an
            epsilon transition, so the only way an alternative other than 1 can exist
            in a state that is also reachable via alternative 1 is by nesting calls
            to the left-recursive rule, with the outer calls not being at the
            preferred precedence level. The
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.PrecedenceFilterSuppressed"/>
            property marks ATN
            configurations which do not meet this condition, and therefore are not
            eligible for elimination during the filtering process.</li>
            </ul>
            </li>
            </ol>
            <p>
            The prediction context must be considered by this filter to address
            situations like the following.
            </p>
            <code>
            <pre>
            grammar TA;
            prog: statement* EOF;
            statement: letterA | statement letterA 'b' ;
            letterA: 'a';
            </pre>
            </code>
            <p>
            If the above grammar, the ATN state immediately before the token
            reference
            <c>'a'</c>
            in
            <c>letterA</c>
            is reachable from the left edge
            of both the primary and closure blocks of the left-recursive rule
            <c>statement</c>
            . The prediction context associated with each of these
            configurations distinguishes between them, and prevents the alternative
            which stepped out to
            <c>prog</c>
            (and then back in to
            <c>statement</c>
            from being eliminated by the filter.
            </p>
            </summary>
            <param name="configs">
            The configuration set computed by
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeStartState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.ParserRuleContext,System.Boolean)"/>
            as the start state for the DFA.
            </param>
            <param name="globalContext">
            </param>
            <param name="contextCache">
            </param>
            <returns>
            The transformed configuration set representing the start state
            for a precedence DFA at a particular precedence level (determined by
            calling
            <see cref="P:Antlr4.Runtime.Parser.Precedence"/>
            ).
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.PredicateDFAState(Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)">
            <summary>collect and set D's semantic context</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Dfa.DFAState.PredPrediction[],Antlr4.Runtime.ParserRuleContext,System.Boolean)">
            <summary>
            Look through a list of predicate/alt pairs, returning alts for the
            pairs that win.
            </summary>
            <remarks>
            Look through a list of predicate/alt pairs, returning alts for the
            pairs that win. A
            <see langword="null"/>
            predicate indicates an alt containing an
            unpredicated config which behaves as "always true."
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Atn.SemanticContext,Antlr4.Runtime.ParserRuleContext,System.Int32)">
            <summary>Evaluate a semantic context within a specific parser context.</summary>
            <remarks>
            Evaluate a semantic context within a specific parser context.
            <p>
            This method might not be called for every semantic context evaluated
            during the prediction process. In particular, we currently do not
            evaluate the following but it may change in the future:</p>
            <ul>
            <li>Precedence predicates (represented by
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.PrecedencePredicate"/>
            ) are not currently evaluated
            through this method.</li>
            <li>Operator predicates (represented by
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.AND"/>
            and
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.OR"/>
            ) are evaluated as a single semantic
            context, rather than evaluating the operands individually.
            Implementations which require evaluation results from individual
            predicates should override this method to explicitly handle evaluation of
            the operands within operator predicates.</li>
            </ul>
            </remarks>
            <param name="pred">The semantic context to evaluate</param>
            <param name="parserCallStack">
            The parser context in which to evaluate the
            semantic context
            </param>
            <param name="alt">
            The alternative which is guarded by
            <paramref name="pred"/>
            </param>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAContextState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>See comment on LexerInterpreter.addDFAState.</summary>
            <remarks>See comment on LexerInterpreter.addDFAState.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>See comment on LexerInterpreter.addDFAState.</summary>
            <remarks>See comment on LexerInterpreter.addDFAState.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportAmbiguity(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>If context sensitive parsing, we know it's ambiguity not conflict</summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ParserATNSimulator.Parser">
            <since>4.3</since>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PlusBlockStartState">
            <summary>
            Start of
            <c>(A|B|...)+</c>
            loop. Technically a decision state, but
            we don't use for code generation; somebody might need it, so I'm defining
            it for completeness. In reality, the
            <see cref="T:Antlr4.Runtime.Atn.PlusLoopbackState"/>
            node is the
            real decision-making note for
            <c>A+</c>
            .
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PlusLoopbackState">
            <summary>
            Decision state for
            <c>A+</c>
            and
            <c>(A|B)+</c>
            .  It has two transitions:
            one to the loop back to start of the block and one to exit.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PrecedencePredicateTransition">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredicateEvalInfo">
            <summary>
            This class represents profiling event information for semantic predicate
            evaluations which occur during prediction.
            </summary>
            <remarks>
            This class represents profiling event information for semantic predicate
            evaluations which occur during prediction.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Dfa.DFAState.PredPrediction[],Antlr4.Runtime.ParserRuleContext,System.Boolean)"/>
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredicateEvalInfo.semctx">
            <summary>The semantic context which was evaluated.</summary>
            <remarks>The semantic context which was evaluated.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredicateEvalInfo.predictedAlt">
            <summary>
            The alternative number for the decision which is guarded by the semantic
            context
            <see cref="F:Antlr4.Runtime.Atn.PredicateEvalInfo.semctx"/>
            . Note that other ATN
            configurations may predict the same alternative which are guarded by
            other semantic contexts and/or
            <see cref="F:Antlr4.Runtime.Atn.SemanticContext.None"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredicateEvalInfo.evalResult">
            <summary>
            The result of evaluating the semantic context
            <see cref="F:Antlr4.Runtime.Atn.PredicateEvalInfo.semctx"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredicateEvalInfo.#ctor(Antlr4.Runtime.Atn.SimulatorState,System.Int32,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32,Antlr4.Runtime.Atn.SemanticContext,System.Boolean,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.PredicateEvalInfo"/>
            class with the
            specified detailed predicate evaluation information.
            </summary>
            <param name="state">The simulator state</param>
            <param name="decision">The decision number</param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">
            The index at which the predicate evaluation was
            triggered. Note that the input stream may be reset to other positions for
            the actual evaluation of individual predicates.
            </param>
            <param name="semctx">The semantic context which was evaluated</param>
            <param name="evalResult">The results of evaluating the semantic context</param>
            <param name="predictedAlt">
            The alternative number for the decision which is
            guarded by the semantic context
            <paramref name="semctx"/>
            . See
            <see cref="F:Antlr4.Runtime.Atn.PredicateEvalInfo.predictedAlt"/>
            for more information.
            </param>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Atn.SemanticContext,Antlr4.Runtime.ParserRuleContext,System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Atn.SemanticContext.Eval``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)"/>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredicateTransition">
            <summary>
            TODO: this is old comment:
            A tree of semantic predicates from the grammar AST if label==SEMPRED.
            </summary>
            <remarks>
            TODO: this is old comment:
            A tree of semantic predicates from the grammar AST if label==SEMPRED.
            In the ATN, labels will always be exactly one predicate, but the DFA
            may have to combine a bunch of them as it collects predicates from
            multiple ATN configurations into a single DFA state.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionContext.cachedHashCode">
            <summary>
            Stores the computed hash code of this
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext"/>
            . The hash
            code is computed in parts to match the following reference algorithm.
            <pre>
            private int referenceHashCode() {
            int hash =
            <see cref="M:Antlr4.Runtime.Misc.MurmurHash.Initialize">MurmurHash.initialize</see>
            (
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.InitialHash"/>
            );
            for (int i = 0; i &lt;
            <see cref="P:Antlr4.Runtime.Atn.PredictionContext.Size"/>
            ; i++) {
            hash =
            <see cref="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Int32)">MurmurHash.update</see>
            (hash,
            <see cref="M:Antlr4.Runtime.Atn.PredictionContext.GetParent(System.Int32)">getParent</see>
            (i));
            }
            for (int i = 0; i &lt;
            <see cref="P:Antlr4.Runtime.Atn.PredictionContext.Size"/>
            ; i++) {
            hash =
            <see cref="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Int32)">MurmurHash.update</see>
            (hash,
            <see cref="M:Antlr4.Runtime.Atn.PredictionContext.GetReturnState(System.Int32)">getReturnState</see>
            (i));
            }
            hash =
            <see cref="M:Antlr4.Runtime.Misc.MurmurHash.Finish(System.Int32,System.Int32)">MurmurHash.finish</see>
            (hash, 2 *
            <see cref="P:Antlr4.Runtime.Atn.PredictionContext.Size"/>
            );
            return hash;
            }
            </pre>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredictionContextCache">
            <summary>
            Used to cache
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext"/>
            objects. Its used for the shared
            context cash associated with contexts in DFA states. This cache
            can be used for both lexers and parsers.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredictionMode">
            <summary>
            This enumeration defines the prediction modes available in ANTLR 4 along with
            utility methods for analyzing configuration sets for conflicts and/or
            ambiguities.
            </summary>
            <remarks>
            This enumeration defines the prediction modes available in ANTLR 4 along with
            utility methods for analyzing configuration sets for conflicts and/or
            ambiguities.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.Sll">
            <summary>The SLL(*) prediction mode.</summary>
            <remarks>
            The SLL(*) prediction mode. This prediction mode ignores the current
            parser context when making predictions. This is the fastest prediction
            mode, and provides correct results for many grammars. This prediction
            mode is more powerful than the prediction mode provided by ANTLR 3, but
            may result in syntax errors for grammar and input combinations which are
            not SLL.
            <p>
            When using this prediction mode, the parser will either return a correct
            parse tree (i.e. the same parse tree that would be returned with the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            prediction mode), or it will report a syntax error. If a
            syntax error is encountered when using the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Sll"/>
            prediction mode,
            it may be due to either an actual syntax error in the input or indicate
            that the particular combination of grammar and input requires the more
            powerful
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            prediction abilities to complete successfully.</p>
            <p>
            This prediction mode does not provide any guarantees for prediction
            behavior for syntactically-incorrect inputs.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.Ll">
            <summary>The LL(*) prediction mode.</summary>
            <remarks>
            The LL(*) prediction mode. This prediction mode allows the current parser
            context to be used for resolving SLL conflicts that occur during
            prediction. This is the fastest prediction mode that guarantees correct
            parse results for all combinations of grammars with syntactically correct
            inputs.
            <p>
            When using this prediction mode, the parser will make correct decisions
            for all syntactically-correct grammar and input combinations. However, in
            cases where the grammar is truly ambiguous this prediction mode might not
            report a precise answer for <em>exactly which</em> alternatives are
            ambiguous.</p>
            <p>
            This prediction mode does not provide any guarantees for prediction
            behavior for syntactically-incorrect inputs.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection">
            <summary>The LL(*) prediction mode with exact ambiguity detection.</summary>
            <remarks>
            The LL(*) prediction mode with exact ambiguity detection. In addition to
            the correctness guarantees provided by the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            prediction mode,
            this prediction mode instructs the prediction algorithm to determine the
            complete and exact set of ambiguous alternatives for every ambiguous
            decision encountered while parsing.
            <p>
            This prediction mode may be used for diagnosing ambiguities during
            grammar development. Due to the performance overhead of calculating sets
            of ambiguous alternatives, this prediction mode should be avoided when
            the exact results are not necessary.</p>
            <p>
            This prediction mode does not provide any guarantees for prediction
            behavior for syntactically-incorrect inputs.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredictionMode.AltAndContextMap">
            <summary>A Map that uses just the state and the stack context as the key.</summary>
            <remarks>A Map that uses just the state and the stack context as the key.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AltAndContextConfigEqualityComparator.GetHashCode(Antlr4.Runtime.Atn.ATNConfig)">
            <summary>
            The hash code is only a function of the
            <see cref="F:Antlr4.Runtime.Atn.ATNState.stateNumber"/>
            and
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Context"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasSLLConflictTerminatingPrediction(Antlr4.Runtime.Atn.PredictionMode,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>Computes the SLL prediction termination condition.</summary>
            <remarks>
            Computes the SLL prediction termination condition.
            <p>
            This method computes the SLL prediction termination condition for both of
            the following cases.</p>
            <ul>
            <li>The usual SLL+LL fallback upon SLL conflict</li>
            <li>Pure SLL without LL fallback</li>
            </ul>
            <p><strong>COMBINED SLL+LL PARSING</strong></p>
            <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
            ensured regardless of how the termination condition is computed by this
            method. Due to the substantially higher cost of LL prediction, the
            prediction should only fall back to LL when the additional lookahead
            cannot lead to a unique SLL prediction.</p>
            <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
            conflicting subsets should fall back to full LL, even if the
            configuration sets don't resolve to the same alternative (e.g.
            <c/>

            1,2}} and
            <c/>

            3,4}}. If there is at least one non-conflicting
            configuration, SLL could continue with the hopes that more lookahead will
            resolve via one of those non-conflicting configurations.</p>
            <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
            stops when it sees only conflicting configuration subsets. In contrast,
            full LL keeps going when there is uncertainty.</p>
            <p><strong>HEURISTIC</strong></p>
            <p>As a heuristic, we stop prediction when we see any conflicting subset
            unless we see a state that only has one alternative associated with it.
            The single-alt-state thing lets prediction continue upon rules like
            (otherwise, it would admit defeat too soon):</p>
            <p>
            <c>[12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;</c>
            </p>
            <p>When the ATN simulation reaches the state before
            <c>';'</c>
            , it has a
            DFA state that looks like:
            <c>[12|1|[], 6|2|[], 12|2|[]]</c>
            . Naturally
            <c>12|1|[]</c>
            and
            <c>12|2|[]</c>
            conflict, but we cannot stop
            processing this node because alternative to has another way to continue,
            via
            <c>[6|2|[]]</c>
            .</p>
            <p>It also let's us continue for this rule:</p>
            <p>
            <c>[1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;</c>
            </p>
            <p>After matching input A, we reach the stop state for rule A, state 1.
            State 8 is the state right before B. Clearly alternatives 1 and 2
            conflict and no amount of further lookahead will separate the two.
            However, alternative 3 will be able to continue and so we do not stop
            working on this state. In the previous example, we're concerned with
            states associated with the conflicting alternatives. Here alt 3 is not
            associated with the conflicting configs, but since we can continue
            looking for input reasonably, don't declare the state done.</p>
            <p><strong>PURE SLL PARSING</strong></p>
            <p>To handle pure SLL parsing, all we have to do is make sure that we
            combine stack contexts for configurations that differ only by semantic
            predicate. From there, we can do the usual SLL termination heuristic.</p>
            <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
            <p>SLL decisions don't evaluate predicates until after they reach DFA stop
            states because they need to create the DFA cache that works in all
            semantic situations. In contrast, full LL evaluates predicates collected
            during start state computation so it can ignore predicates thereafter.
            This means that SLL termination detection can totally ignore semantic
            predicates.</p>
            <p>Implementation-wise,
            <see cref="T:Antlr4.Runtime.Atn.ATNConfigSet"/>
            combines stack contexts but not
            semantic predicate contexts so we might see two configurations like the
            following.</p>
            <p>
            <c/>
            (s, 1, x,
            ), (s, 1, x', {p})}</p>
            <p>Before testing these configurations against others, we have to merge
            <c>x</c>
            and
            <c>x'</c>
            (without modifying the existing configurations).
            For example, we test
            <c>(x+x')==x''</c>
            when looking for conflicts in
            the following configurations.</p>
            <p>
            <c/>
            (s, 1, x,
            ), (s, 1, x', {p}), (s, 2, x'', {})}</p>
            <p>If the configuration set has predicates (as indicated by
            <see cref="P:Antlr4.Runtime.Atn.ATNConfigSet.HasSemanticContext"/>
            ), this algorithm makes a copy of
            the configurations to strip out all of the predicates so that a standard
            <see cref="T:Antlr4.Runtime.Atn.ATNConfigSet"/>
            will merge everything ignoring predicates.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasConfigInRuleStopState(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>
            Checks if any configuration in
            <paramref name="configs"/>
            is in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            . Configurations meeting this condition have reached
            the end of the decision rule (local context) or end of start rule (full
            context).
            </summary>
            <param name="configs">the configuration set to test</param>
            <returns>

            <see langword="true"/>
            if any configuration in
            <paramref name="configs"/>
            is in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            , otherwise
            <see langword="false"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllConfigsInRuleStopStates(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>
            Checks if all configurations in
            <paramref name="configs"/>
            are in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            . Configurations meeting this condition have reached
            the end of the decision rule (local context) or end of start rule (full
            context).
            </summary>
            <param name="configs">the configuration set to test</param>
            <returns>

            <see langword="true"/>
            if all configurations in
            <paramref name="configs"/>
            are in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            , otherwise
            <see langword="false"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.ResolvesToJustOneViableAlt(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>Full LL prediction termination.</summary>
            <remarks>
            Full LL prediction termination.
            <p>Can we stop looking ahead during ATN simulation or is there some
            uncertainty as to which alternative we will ultimately pick, after
            consuming more input? Even if there are partial conflicts, we might know
            that everything is going to resolve to the same minimum alternative. That
            means we can stop since no more lookahead will change that fact. On the
            other hand, there might be multiple conflicts that resolve to different
            minimums. That means we need more look ahead to decide which of those
            alternatives we should predict.</p>
            <p>The basic idea is to split the set of configurations
            <c>C</c>
            , into
            conflicting subsets
            <c>(s, _, ctx, _)</c>
            and singleton subsets with
            non-conflicting configurations. Two configurations conflict if they have
            identical
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.State"/>
            and
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Context"/>
            values
            but different
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Alt"/>
            value, e.g.
            <c>(s, i, ctx, _)</c>
            and
            <c>(s, j, ctx, _)</c>
            for
            <c>i!=j</c>
            .</p>
            <p/>
            Reduce these configuration subsets to the set of possible alternatives.
            You can compute the alternative subsets in one pass as follows:
            <p/>
            <c/>
            A_s,ctx =
            i | (s, i, ctx, _)}} for each configuration in
            <c>C</c>
            holding
            <c>s</c>
            and
            <c>ctx</c>
            fixed.
            <p/>
            Or in pseudo-code, for each configuration
            <c>c</c>
            in
            <c>C</c>
            :
            <pre>
            map[c] U= c.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Alt">getAlt()</see>
            # map hash/equals uses s and x, not
            alt and not pred
            </pre>
            <p>The values in
            <c>map</c>
            are the set of
            <c>A_s,ctx</c>
            sets.</p>
            <p>If
            <c>|A_s,ctx|=1</c>
            then there is no conflict associated with
            <c>s</c>
            and
            <c>ctx</c>
            .</p>
            <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
            the union of these alternative subsets is a singleton, then no amount of
            more lookahead will help us. We will always pick that alternative. If,
            however, there is more than one alternative, then we are uncertain which
            alternative to predict and must continue looking for resolution. We may
            or may not discover an ambiguity in the future, even if there are no
            conflicting subsets this round.</p>
            <p>The biggest sin is to terminate early because it means we've made a
            decision but were uncertain as to the eventual outcome. We haven't used
            enough lookahead. On the other hand, announcing a conflict too late is no
            big deal; you will still have the conflict. It's just inefficient. It
            might even look until the end of file.</p>
            <p>No special consideration for semantic predicates is required because
            predicates are evaluated on-the-fly for full LL prediction, ensuring that
            no configuration contains a semantic context during the termination
            check.</p>
            <p><strong>CONFLICTING CONFIGS</strong></p>
            <p>Two configurations
            <c>(s, i, x)</c>
            and
            <c>(s, j, x')</c>
            , conflict
            when
            <c>i!=j</c>
            but
            <c>x=x'</c>
            . Because we merge all
            <c>(s, i, _)</c>
            configurations together, that means that there are at
            most
            <c>n</c>
            configurations associated with state
            <c>s</c>
            for
            <c>n</c>
            possible alternatives in the decision. The merged stacks
            complicate the comparison of configuration contexts
            <c>x</c>
            and
            <c>x'</c>
            . Sam checks to see if one is a subset of the other by calling
            merge and checking to see if the merged result is either
            <c>x</c>
            or
            <c>x'</c>
            . If the
            <c>x</c>
            associated with lowest alternative
            <c>i</c>
            is the superset, then
            <c>i</c>
            is the only possible prediction since the
            others resolve to
            <c>min(i)</c>
            as well. However, if
            <c>x</c>
            is
            associated with
            <c>j&gt;i</c>
            then at least one stack configuration for
            <c>j</c>
            is not in conflict with alternative
            <c>i</c>
            . The algorithm
            should keep going, looking for more lookahead due to the uncertainty.</p>
            <p>For simplicity, I'm doing a equality check between
            <c>x</c>
            and
            <c>x'</c>
            that lets the algorithm continue to consume lookahead longer
            than necessary. The reason I like the equality is of course the
            simplicity but also because that is the test you need to detect the
            alternatives that are actually in conflict.</p>
            <p><strong>CONTINUE/STOP RULE</strong></p>
            <p>Continue if union of resolved alternative sets from non-conflicting and
            conflicting alternative subsets has more than one alternative. We are
            uncertain about which alternative to predict.</p>
            <p>The complete set of alternatives,
            <c>[i for (_,i,_)]</c>
            , tells us which
            alternatives are still in the running for the amount of input we've
            consumed at this point. The conflicting sets let us to strip away
            configurations that won't lead to more states because we resolve
            conflicts to the configuration with a minimum alternate for the
            conflicting set.</p>
            <p><strong>CASES</strong></p>
            <ul>
            <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
            <li>
            <c>(s, 1, x)</c>
            ,
            <c>(s, 2, x)</c>
            ,
            <c>(s, 3, z)</c>
            ,
            <c>(s', 1, y)</c>
            ,
            <c>(s', 2, y)</c>
            yields non-conflicting set
            <c/>

            3}} U conflicting sets
            <c/>
            min(
            1,2})} U
            <c/>
            min(
            1,2})} =
            <c/>

            1,3}} =&gt; continue
            </li>
            <li>
            <c>(s, 1, x)</c>
            ,
            <c>(s, 2, x)</c>
            ,
            <c>(s', 1, y)</c>
            ,
            <c>(s', 2, y)</c>
            ,
            <c>(s'', 1, z)</c>
            yields non-conflicting set
            <c/>

            1}} U conflicting sets
            <c/>
            min(
            1,2})} U
            <c/>
            min(
            1,2})} =
            <c/>

            1}} =&gt; stop and predict 1</li>
            <li>
            <c>(s, 1, x)</c>
            ,
            <c>(s, 2, x)</c>
            ,
            <c>(s', 1, y)</c>
            ,
            <c>(s', 2, y)</c>
            yields conflicting, reduced sets
            <c/>

            1}} U
            <c/>

            1}} =
            <c/>

            1}} =&gt; stop and predict 1, can announce
            ambiguity
            <c/>

            1,2}}</li>
            <li>
            <c>(s, 1, x)</c>
            ,
            <c>(s, 2, x)</c>
            ,
            <c>(s', 2, y)</c>
            ,
            <c>(s', 3, y)</c>
            yields conflicting, reduced sets
            <c/>

            1}} U
            <c/>

            2}} =
            <c/>

            1,2}} =&gt; continue</li>
            <li>
            <c>(s, 1, x)</c>
            ,
            <c>(s, 2, x)</c>
            ,
            <c>(s', 3, y)</c>
            ,
            <c>(s', 4, y)</c>
            yields conflicting, reduced sets
            <c/>

            1}} U
            <c/>

            3}} =
            <c/>

            1,3}} =&gt; continue</li>
            </ul>
            <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
            <p>If all states report the same conflicting set of alternatives, then we
            know we have the exact ambiguity set.</p>
            <p><code>|A_<em>i</em>|&gt;1</code> and
            <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
            <p>In other words, we continue examining lookahead until all
            <c>A_i</c>
            have more than one alternative and all
            <c>A_i</c>
            are the same. If
            <c/>
            A=
            {1,2}, {1,3}}}, then regular LL prediction would terminate
            because the resolved set is
            <c/>

            1}}. To determine what the real
            ambiguity is, we have to know whether the ambiguity is between one and
            two or one and three so we keep going. We can only stop prediction when
            we need exact ambiguity detection when the sets look like
            <c/>
            A=
            {1,2}}} or
            <c/>

            {1,2},{1,2}}}, etc...</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllSubsetsConflict(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Determines if every alternative subset in
            <paramref name="altsets"/>
            contains more
            than one alternative.
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>

            <see langword="true"/>
            if every
            <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
            in
            <paramref name="altsets"/>
            has
            <see cref="M:Antlr4.Runtime.Sharpen.BitSet.Cardinality">cardinality</see>
            &gt; 1, otherwise
            <see langword="false"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasNonConflictingAltSet(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Determines if any single alternative subset in
            <paramref name="altsets"/>
            contains
            exactly one alternative.
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>

            <see langword="true"/>
            if
            <paramref name="altsets"/>
            contains a
            <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
            with
            <see cref="M:Antlr4.Runtime.Sharpen.BitSet.Cardinality">cardinality</see>
            1, otherwise
            <see langword="false"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasConflictingAltSet(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Determines if any single alternative subset in
            <paramref name="altsets"/>
            contains
            more than one alternative.
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>

            <see langword="true"/>
            if
            <paramref name="altsets"/>
            contains a
            <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
            with
            <see cref="M:Antlr4.Runtime.Sharpen.BitSet.Cardinality">cardinality</see>
            &gt; 1, otherwise
            <see langword="false"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllSubsetsEqual(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Determines if every alternative subset in
            <paramref name="altsets"/>
            is equivalent.
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>

            <see langword="true"/>
            if every member of
            <paramref name="altsets"/>
            is equal to the
            others, otherwise
            <see langword="false"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetUniqueAlt(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Returns the unique alternative predicted by all alternative subsets in
            <paramref name="altsets"/>
            . If no such alternative exists, this method returns
            <see cref="F:Antlr4.Runtime.Atn.ATN.InvalidAltNumber"/>
            .
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetAlts(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Gets the complete set of represented alternatives for a collection of
            alternative subsets.
            </summary>
            <remarks>
            Gets the complete set of represented alternatives for a collection of
            alternative subsets. This method returns the union of each
            <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
            in
            <paramref name="altsets"/>
            .
            </remarks>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            the set of represented alternatives in
            <paramref name="altsets"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetConflictingAltSubsets(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>This function gets the conflicting alt subsets from a configuration set.</summary>
            <remarks>
            This function gets the conflicting alt subsets from a configuration set.
            For each configuration
            <c>c</c>
            in
            <paramref name="configs"/>
            :
            <pre>
            map[c] U= c.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Alt">getAlt()</see>
            # map hash/equals uses s and x, not
            alt and not pred
            </pre>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetStateToAltMap(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>Get a map from state to alt subset from a configuration set.</summary>
            <remarks>
            Get a map from state to alt subset from a configuration set. For each
            configuration
            <c>c</c>
            in
            <paramref name="configs"/>
            :
            <pre>
            map[c.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.State"/>
            ] U= c.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Alt"/>
            </pre>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ProfilingATNSimulator">
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ProfilingATNSimulator.conflictingAltResolvedBySLL">
            <summary>
            At the point of LL failover, we record how SLL would resolve the conflict so that
            we can determine whether or not a decision / input pair is context-sensitive.
            </summary>
            <remarks>
            At the point of LL failover, we record how SLL would resolve the conflict so that
            we can determine whether or not a decision / input pair is context-sensitive.
            If LL gives a different result than SLL's predicted alternative, we have a
            context sensitivity for sure. The converse is not necessarily true, however.
            It's possible that after conflict resolution chooses minimum alternatives,
            SLL could get the same answer as LL. Regardless of whether or not the result indicates
            an ambiguity, it is not treated as a context sensitivity because LL prediction
            was not required in order to produce a correct prediction for this decision and input sequence.
            It may in fact still be a context sensitivity but we don't know by looking at the
            minimum alternatives for the current input.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.RuleStopState">
            <summary>The last node in the ATN for a rule, unless that rule is the start symbol.</summary>
            <remarks>
            The last node in the ATN for a rule, unless that rule is the start symbol.
            In that case, there is one transition to EOF. Later, we might encode
            references to all calls to this rule to compute FOLLOW sets for
            error handling.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.RuleTransition.ruleIndex">
            <summary>Ptr to the rule definition object for this rule ref</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.RuleTransition.followState">
            <summary>What node to begin computations following ref to rule</summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SemanticContext">
            <summary>
            A tree structure used to record the semantic context in which
            an ATN configuration is valid.
            </summary>
            <remarks>
            A tree structure used to record the semantic context in which
            an ATN configuration is valid.  It's either a single predicate,
            a conjunction
            <c>p1&amp;&amp;p2</c>
            , or a sum of products
            <c>p1||p2</c>
            .
            <p>I have scoped the
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.AND"/>
            ,
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.OR"/>
            , and
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.Predicate"/>
            subclasses of
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext"/>
            within the scope of this outer class.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.SemanticContext.None">
            <summary>
            The default
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext"/>
            , which is semantically equivalent to
            a predicate of the form
            <c/>

            true}?}.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.SemanticContext.Eval``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)">
            <summary>
            For context independent predicates, we evaluate them without a local
            context (i.e., null context).
            </summary>
            <remarks>
            For context independent predicates, we evaluate them without a local
            context (i.e., null context). That way, we can evaluate them without
            having to create proper rule-specific context during prediction (as
            opposed to the parser, which creates them naturally). In a practical
            sense, this avoids a cast exception from RuleContext to myruleContext.
            <p>For context dependent predicates, we must pass in a local context so that
            references such as $arg evaluate properly as _localctx.arg. We only
            capture context dependent predicates in the context in which we begin
            prediction, so we passed in the outer context here in case of context
            dependent predicate evaluation.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.SemanticContext.EvalPrecedence``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)">
            <summary>Evaluate the precedence predicates for the context and reduce the result.</summary>
            <remarks>Evaluate the precedence predicates for the context and reduce the result.</remarks>
            <param name="parser">The parser instance.</param>
            <param name="parserCallStack"/>
            <returns>
            The simplified semantic context after precedence predicates are
            evaluated, which will be one of the following values.
            <ul>
            <li>
            <see cref="F:Antlr4.Runtime.Atn.SemanticContext.None"/>
            : if the predicate simplifies to
            <see langword="true"/>
            after
            precedence predicates are evaluated.</li>
            <li>
            <see langword="null"/>
            : if the predicate simplifies to
            <see langword="false"/>
            after
            precedence predicates are evaluated.</li>
            <li>
            <c>this</c>
            : if the semantic context is not changed as a result of
            precedence predicate evaluation.</li>
            <li>A non-
            <see langword="null"/>

            <see cref="T:Antlr4.Runtime.Atn.SemanticContext"/>
            : the new simplified
            semantic context after precedence predicates are evaluated.</li>
            </ul>
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SemanticContext.Operator">
            <summary>
            This is the base class for semantic context "operators", which operate on
            a collection of semantic context "operands".
            </summary>
            <remarks>
            This is the base class for semantic context "operators", which operate on
            a collection of semantic context "operands".
            </remarks>
            <since>4.3</since>
        </member>
        <member name="P:Antlr4.Runtime.Atn.SemanticContext.Operator.Operands">
            <summary>Gets the operands for the semantic context operator.</summary>
            <remarks>Gets the operands for the semantic context operator.</remarks>
            <returns>
            a collection of
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext"/>
            operands for the
            operator.
            </returns>
            <since>4.3</since>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SemanticContext.AND">
            <summary>
            A semantic context which is true whenever none of the contained contexts
            is false.
            </summary>
            <remarks>
            A semantic context which is true whenever none of the contained contexts
            is false.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.SemanticContext.AND.Eval``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)">
            <summary>
            <inheritDoc/>
            <p>
            The evaluation of predicates by this context is short-circuiting, but
            unordered.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SemanticContext.OR">
            <summary>
            A semantic context which is true whenever at least one of the contained
            contexts is true.
            </summary>
            <remarks>
            A semantic context which is true whenever at least one of the contained
            contexts is true.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.SemanticContext.OR.Eval``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)">
            <summary>
            <inheritDoc/>
            <p>
            The evaluation of predicates by this context is short-circuiting, but
            unordered.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.SemanticContext.OrOp(Antlr4.Runtime.Atn.SemanticContext,Antlr4.Runtime.Atn.SemanticContext)">
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetPredsForAmbigAlts(Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)"/>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SetTransition">
            <summary>A transition containing a set of values.</summary>
            <remarks>A transition containing a set of values.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SimulatorState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.StarBlockStartState">
            <summary>The block that begins a closure loop.</summary>
            <remarks>The block that begins a closure loop.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.StarLoopEntryState.precedenceRuleDecision">
            <summary>
            Indicates whether this state can benefit from a precedence DFA during SLL
            decision making.
            </summary>
            <remarks>
            Indicates whether this state can benefit from a precedence DFA during SLL
            decision making.
            <p>This is a computed property that is calculated during ATN deserialization
            and stored for use in
            <see cref="T:Antlr4.Runtime.Atn.ParserATNSimulator"/>
            and
            <see cref="T:Antlr4.Runtime.ParserInterpreter"/>
            .</p>
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa"/>
        </member>
        <member name="T:Antlr4.Runtime.Atn.TokensStartState">
            <summary>The Tokens rule start state linking to each lexer rule start state</summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.Transition">
            <summary>An ATN transition between any two ATN states.</summary>
            <remarks>
            An ATN transition between any two ATN states.  Subclasses define
            atom, set, epsilon, action, predicate, rule transitions.
            <p>This is a one way link.  It emanates from a state (usually via a list of
            transitions) and has a target state.</p>
            <p>Since we never have to change the ATN transitions once we construct it,
            we can fix these transitions as specific classes. The DFA transitions
            on the other hand need to update the labels as it adds transitions to
            the states. We'll use the term Edge for the DFA to distinguish them from
            ATN transitions.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.Transition.target">
            <summary>The target of this transition.</summary>
            <remarks>The target of this transition.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.Transition.IsEpsilon">
            <summary>Determines if the transition is an "epsilon" transition.</summary>
            <remarks>
            Determines if the transition is an "epsilon" transition.
            <p>The default implementation returns
            <see langword="false"/>
            .</p>
            </remarks>
            <returns>

            <see langword="true"/>
            if traversing this transition in the ATN does not
            consume an input symbol; otherwise,
            <see langword="false"/>
            if traversing this
            transition consumes (matches) an input symbol.
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.BailErrorStrategy">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy"/>
            responds to syntax errors
            by immediately canceling the parse operation with a
            <see cref="T:Antlr4.Runtime.Misc.ParseCanceledException"/>
            . The implementation ensures that the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.exception"/>
            field is set for all parse tree nodes
            that were not completed prior to encountering the error.
            <p>
            This error strategy is useful in the following scenarios.</p>
            <ul>
            <li><strong>Two-stage parsing:</strong> This error strategy allows the first
            stage of two-stage parsing to immediately terminate if an error is
            encountered, and immediately fall back to the second stage. In addition to
            avoiding wasted work by attempting to recover from errors here, the empty
            implementation of
            <see cref="M:Antlr4.Runtime.BailErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            improves the performance of
            the first stage.</li>
            <li><strong>Silent validation:</strong> When syntax errors are not being
            reported or logged, and the parse result is simply ignored if errors occur,
            the
            <see cref="T:Antlr4.Runtime.BailErrorStrategy"/>
            avoids wasting work on recovering from errors
            when the result will be ignored either way.</li>
            </ul>
            <p>
            <c>myparser.setErrorHandler(new BailErrorStrategy());</c>
            </p>
            </summary>
            <seealso cref="P:Antlr4.Runtime.Parser.ErrorHandler"/>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            Instead of recovering from exception
            <paramref name="e"/>
            , re-throw it wrapped
            in a
            <see cref="T:Antlr4.Runtime.Misc.ParseCanceledException"/>
            so it is not caught by the
            rule function catches.  Use
            <see cref="P:System.Exception.InnerException"/>
            to get the
            original
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            Make sure we don't attempt to recover inline; if the parser
            successfully recovers, it won't throw an exception.
            </summary>
            <remarks>
            Make sure we don't attempt to recover inline; if the parser
            successfully recovers, it won't throw an exception.
            </remarks>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>Make sure we don't attempt to recover from problems in subrules.</summary>
            <remarks>Make sure we don't attempt to recover from problems in subrules.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.BaseErrorListener">
            <summary>
            Provides an empty default implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            . The
            default implementation of each method does nothing, but can be overridden as
            necessary.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.BufferedTokenStream">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.ITokenStream"/>
            loads tokens from a
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            on-demand, and places the tokens in a buffer to provide
            access to any previous token by index.
            <p>
            This token stream ignores the value of
            <see cref="P:Antlr4.Runtime.IToken.Channel"/>
            . If your
            parser requires the token stream filter tokens to only those on a particular
            channel, such as
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            or
            <see cref="F:Antlr4.Runtime.TokenConstants.HiddenChannel"/>
            , use a filtering token stream such a
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream._tokenSource">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            from which tokens for this stream are fetched.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.tokens">
            <summary>A collection of all tokens fetched from the token source.</summary>
            <remarks>
            A collection of all tokens fetched from the token source. The list is
            considered a complete view of the input once
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF"/>
            is set
            to
            <see langword="true"/>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.p">
            <summary>
            The index into
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            of the current token (next token to
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Consume"/>
            ).
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            <c>[</c>
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.p"/>
            <c>]</c>
            should be
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Lt(System.Int32)">LT(1)</see>
            .
            <p>This field is set to -1 when the stream is first constructed or when
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.SetTokenSource(Antlr4.Runtime.ITokenSource)"/>
            is called, indicating that the first token has
            not yet been fetched from the token source. For additional information,
            see the documentation of
            <see cref="T:Antlr4.Runtime.IIntStream"/>
            for a description of
            Initializing Methods.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF">
            <summary>
            Indicates whether the
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            token has been fetched from
            <see cref="F:Antlr4.Runtime.BufferedTokenStream._tokenSource"/>
            and added to
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            . This field improves
            performance for the following cases:
            <ul>
            <li>
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Consume"/>
            : The lookahead check in
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Consume"/>
            to prevent
            consuming the EOF symbol is optimized by checking the values of
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF"/>
            and
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.p"/>
            instead of calling
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.La(System.Int32)"/>
            .</li>
            <li>
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Fetch(System.Int32)"/>
            : The check to prevent adding multiple EOF symbols into
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            is trivial with this field.</li>
            </ul>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Sync(System.Int32)">
            <summary>
            Make sure index
            <paramref name="i"/>
            in tokens has a token.
            </summary>
            <returns>

            <see langword="true"/>
            if a token is located at index
            <paramref name="i"/>
            , otherwise
            <see langword="false"/>
            .
            </returns>
            <seealso cref="M:Antlr4.Runtime.BufferedTokenStream.Get(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Fetch(System.Int32)">
            <summary>
            Add
            <paramref name="n"/>
            elements to buffer.
            </summary>
            <returns>The actual number of elements added to the buffer.</returns>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Get(System.Int32,System.Int32)">
            <summary>Get all tokens from start..stop inclusively.</summary>
            <remarks>Get all tokens from start..stop inclusively.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.AdjustSeekIndex(System.Int32)">
            <summary>
            Allowed derived classes to modify the behavior of operations which change
            the current stream position by adjusting the target token index of a seek
            operation.
            </summary>
            <remarks>
            Allowed derived classes to modify the behavior of operations which change
            the current stream position by adjusting the target token index of a seek
            operation. The default implementation simply returns
            <paramref name="i"/>
            . If an
            exception is thrown in this method, the current stream index should not be
            changed.
            <p>For example,
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            overrides this method to ensure that
            the seek target is always an on-channel token.</p>
            </remarks>
            <param name="i">The target token index.</param>
            <returns>The adjusted target token index.</returns>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.SetTokenSource(Antlr4.Runtime.ITokenSource)">
            <summary>Reset this token stream by setting its token source.</summary>
            <remarks>Reset this token stream by setting its token source.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetTokens(System.Int32,System.Int32,Antlr4.Runtime.Sharpen.BitSet)">
            <summary>
            Given a start and stop index, return a
            <c>List</c>
            of all tokens in
            the token type
            <c>BitSet</c>
            .  Return
            <see langword="null"/>
            if no tokens were found.  This
            method looks at both on and off channel tokens.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.NextTokenOnChannel(System.Int32,System.Int32)">
            <summary>Given a starting index, return the index of the next token on channel.</summary>
            <remarks>
            Given a starting index, return the index of the next token on channel.
            Return
            <paramref name="i"/>
            if
            <c>tokens[i]</c>
            is on channel. Return the index of
            the EOF token if there are no tokens on channel between
            <paramref name="i"/>
            and
            EOF.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.PreviousTokenOnChannel(System.Int32,System.Int32)">
            <summary>
            Given a starting index, return the index of the previous token on
            channel.
            </summary>
            <remarks>
            Given a starting index, return the index of the previous token on
            channel. Return
            <paramref name="i"/>
            if
            <c>tokens[i]</c>
            is on channel. Return -1
            if there are no tokens on channel between
            <paramref name="i"/>
            and 0.
            <p>
            If
            <paramref name="i"/>
            specifies an index at or after the EOF token, the EOF token
            index is returned. This is due to the fact that the EOF token is treated
            as though it were on every channel.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToRight(System.Int32,System.Int32)">
            <summary>
            Collect all tokens on specified channel to the right of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            or
            EOF. If
            <paramref name="channel"/>
            is
            <c>-1</c>
            , find any non default channel token.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToRight(System.Int32)">
            <summary>
            Collect all hidden tokens (any off-default channel) to the right of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            or EOF.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToLeft(System.Int32,System.Int32)">
            <summary>
            Collect all tokens on specified channel to the left of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            .
            If
            <paramref name="channel"/>
            is
            <c>-1</c>
            , find any non default channel token.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToLeft(System.Int32)">
            <summary>
            Collect all hidden tokens (any off-default channel) to the left of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetText">
            <summary>Get the text of all tokens in this buffer.</summary>
            <remarks>Get the text of all tokens in this buffer.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Fill">
            <summary>Get all tokens from lexer until EOF.</summary>
            <remarks>Get all tokens from lexer until EOF.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.EmptySource">
            <summary>
            An empty
            <see cref="T:System.Tuple`2"/>
            which is used as the default value of
            <see cref="F:Antlr4.Runtime.CommonToken.source"/>
            for tokens that do not have a source.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken._type">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Type"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken._line">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Line"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.charPositionInLine">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Column"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken._channel">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Channel"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.source">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.CommonToken.TokenSource"/>
            and
            <see cref="P:Antlr4.Runtime.CommonToken.InputStream"/>
            .
            <p>
            These properties share a field to reduce the memory footprint of
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            . Tokens created by a
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            from
            the same source and input stream share a reference to the same
            <see cref="T:System.Tuple`2"/>
            containing these values.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken._text">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Text"/> property.
            </summary>
            <seealso cref="P:Antlr4.Runtime.CommonToken.Text"/>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.index">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.TokenIndex"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.start">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.StartIndex"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.stop">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.StopIndex"/> property.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.CommonToken.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            with the specified token type.
            </summary>
            <param name="type">The token type.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonToken.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            with the specified token type and
            text.
            </summary>
            <param name="type">The token type.</param>
            <param name="text">The text of the token.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonToken.#ctor(Antlr4.Runtime.IToken)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            as a copy of another
            <see cref="T:Antlr4.Runtime.IToken"/>
            .
            <p>
            If
            <paramref name="oldToken"/>
            is also a
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            instance, the newly
            constructed token will share a reference to the
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            field and
            the
            <see cref="T:System.Tuple`2"/>
            stored in
            <see cref="F:Antlr4.Runtime.CommonToken.source"/>
            . Otherwise,
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            will
            be assigned the result of calling
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            , and
            <see cref="F:Antlr4.Runtime.CommonToken.source"/>
            will be constructed from the result of
            <see cref="P:Antlr4.Runtime.IToken.TokenSource"/>
            and
            <see cref="P:Antlr4.Runtime.IToken.InputStream"/>
            .</p>
            </summary>
            <param name="oldToken">The token to copy.</param>
        </member>
        <member name="P:Antlr4.Runtime.CommonToken.Text">
            <summary>Explicitly set the text for this token.</summary>
            <remarks>
            Explicitly set the text for this token. If {code text} is not
            <see langword="null"/>
            , then
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            will return this value rather than
            extracting the text from the input.
            </remarks>
            <value>
            The explicit text of the token, or
            <see langword="null"/>
            if the text
            should be obtained from the input along with the start and stop indexes
            of the token.
            </value>
        </member>
        <member name="T:Antlr4.Runtime.CommonTokenFactory">
            <summary>
            This default implementation of
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            creates
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            objects.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenFactory.Default">
            <summary>
            The default
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            instance.
            <p>
            This token factory does not explicitly copy token text when constructing
            tokens.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenFactory.copyText">
            <summary>
            Indicates whether
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            should be called after
            constructing tokens to explicitly set the text. This is useful for cases
            where the input stream might not be able to provide arbitrary substrings
            of text from the input after the lexer creates a token (e.g. the
            implementation of
            <see cref="M:Antlr4.Runtime.ICharStream.GetText(Antlr4.Runtime.Misc.Interval)"/>
            in
            <see cref="T:Antlr4.Runtime.UnbufferedCharStream"/>
            throws an
            <see cref="T:System.NotSupportedException"/>
            ). Explicitly setting the token text
            allows
            <see cref="P:Antlr4.Runtime.IToken.Text"/>
            to be called at any time regardless of the
            input stream implementation.
            <p>
            The default value is
            <see langword="false"/>
            to avoid the performance and memory
            overhead of copying text for every token unless explicitly requested.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenFactory.#ctor(System.Boolean)">
            <summary>
            Constructs a
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            with the specified value for
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.copyText"/>
            .
            <p>
            When
            <paramref name="copyText"/>
            is
            <see langword="false"/>
            , the
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.Default"/>
            instance
            should be used instead of constructing a new instance.</p>
            </summary>
            <param name="copyText">
            The value for
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.copyText"/>
            .
            </param>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenFactory.#ctor">
            <summary>
            Constructs a
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            with
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.copyText"/>
            set to
            <see langword="false"/>
            .
            <p>
            The
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.Default"/>
            instance should be used instead of calling this
            directly.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.CommonTokenStream">
            <summary>
            This class extends
            <see cref="T:Antlr4.Runtime.BufferedTokenStream"/>
            with functionality to filter
            token streams to tokens on a particular channel (tokens where
            <see cref="P:Antlr4.Runtime.IToken.Channel"/>
            returns a particular value).
            <p>
            This token stream provides access to all tokens by index or when calling
            methods like
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.GetText"/>
            . The channel filtering is only used for code
            accessing tokens via the lookahead methods
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.La(System.Int32)"/>
            ,
            <see cref="M:Antlr4.Runtime.CommonTokenStream.Lt(System.Int32)"/>
            , and
            <see cref="M:Antlr4.Runtime.CommonTokenStream.Lb(System.Int32)"/>
            .</p>
            <p>
            By default, tokens are placed on the default channel
            (
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            ), but may be reassigned by using the
            <c>-&gt;channel(HIDDEN)</c>
            lexer command, or by using an embedded action to
            call
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            .
            </p>
            <p>
            Note: lexer rules which use the
            <c>-&gt;skip</c>
            lexer command or call
            <see cref="M:Antlr4.Runtime.Lexer.Skip"/>
            do not produce tokens at all, so input text matched by
            such a rule will not be available as part of the token stream, regardless of
            channel.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenStream.channel">
            <summary>Specifies the channel to use for filtering tokens.</summary>
            <remarks>
            Specifies the channel to use for filtering tokens.
            <p>
            The default value is
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            , which matches the
            default channel assigned to tokens created by the lexer.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.#ctor(Antlr4.Runtime.ITokenSource)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            using the specified token
            source and the default token channel (
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            ).
            </summary>
            <param name="tokenSource">The token source.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.#ctor(Antlr4.Runtime.ITokenSource,System.Int32)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            using the specified token
            source and filtering tokens to the specified channel. Only tokens whose
            <see cref="P:Antlr4.Runtime.IToken.Channel"/>
            matches
            <paramref name="channel"/>
            or have the
            <see cref="P:Antlr4.Runtime.IToken.Type"/>
            equal to
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            will be returned by the
            token stream lookahead methods.
            </summary>
            <param name="tokenSource">The token source.</param>
            <param name="channel">The channel to use for filtering tokens.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.GetNumberOfOnChannelTokens">
            <summary>Count EOF just once.</summary>
            <remarks>Count EOF just once.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.ConsoleErrorListener`1">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.ConsoleErrorListener`1.Instance">
            <summary>
            Provides a default instance of
            <see cref="T:Antlr4.Runtime.ConsoleErrorListener`1"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ConsoleErrorListener`1.SyntaxError(Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc/>
            <p>
            This implementation prints messages to
            <see cref="P:System.Console.Error"/>
            containing the
            values of
            <paramref name="line"/>
            ,
            <paramref name="charPositionInLine"/>
            , and
            <paramref name="msg"/>
            using
            the following format.</p>
            <pre>
            line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>
            </pre>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.DefaultErrorStrategy">
            <summary>
            This is the default implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy"/>
            used for
            error reporting and recovery in ANTLR parsers.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.DefaultErrorStrategy.errorRecoveryMode">
            <summary>
            Indicates whether the error strategy is currently "recovering from an
            error".
            </summary>
            <remarks>
            Indicates whether the error strategy is currently "recovering from an
            error". This is used to suppress reporting multiple error messages while
            attempting to recover from a detected syntax error.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)"/>
        </member>
        <member name="F:Antlr4.Runtime.DefaultErrorStrategy.lastErrorIndex">
            <summary>The index into the input stream where the last error occurred.</summary>
            <remarks>
            The index into the input stream where the last error occurred.
            This is used to prevent infinite loops where an error is found
            but no token is consumed during recovery...another error is found,
            ad nauseum.  This is a failsafe mechanism to guarantee that at least
            one token/tree node is consumed for two errors.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Reset(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc/>
            <p>The default implementation simply calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)"/>
            to
            ensure that the handler is not in error recovery mode.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to enter error recovery mode when a recognition
            exception is reported.
            </summary>
            <remarks>
            This method is called to enter error recovery mode when a recognition
            exception is reported.
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to leave error recovery mode after recovering from
            a recognition exception.
            </summary>
            <remarks>
            This method is called to leave error recovery mode after recovering from
            a recognition exception.
            </remarks>
            <param name="recognizer"/>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc/>
            <p>The default implementation simply calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)"/>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc/>
            <p>The default implementation returns immediately if the handler is already
            in error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)"/>
            and dispatches the reporting task based on the runtime type of
            <paramref name="e"/>
            according to the following table.</p>
            <ul>
            <li>
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportNoViableAlternative(Antlr4.Runtime.Parser,Antlr4.Runtime.NoViableAltException)"/>
            </li>
            <li>
            <see cref="T:Antlr4.Runtime.InputMismatchException"/>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportInputMismatch(Antlr4.Runtime.Parser,Antlr4.Runtime.InputMismatchException)"/>
            </li>
            <li>
            <see cref="T:Antlr4.Runtime.FailedPredicateException"/>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportFailedPredicate(Antlr4.Runtime.Parser,Antlr4.Runtime.FailedPredicateException)"/>
            </li>
            <li>All other types: calls
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            to report
            the exception</li>
            </ul>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc/>
            <p>The default implementation resynchronizes the parser by consuming tokens
            until we find one in the resynchronization set--loosely the set of tokens
            that can follow the current rule.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>
            The default implementation of
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            makes sure
            that the current lookahead symbol is consistent with what were expecting
            at this point in the ATN. You can call this anytime but ANTLR only
            generates code to check before subrules/loops and each iteration.
            <p>Implements Jim Idle's magic sync mechanism in closures and optional
            subrules. E.g.,</p>
            <pre>
            a : sync ( stuff sync )* ;
            sync : {consume to what can follow sync} ;
            </pre>
            At the start of a sub rule upon error,
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            performs single
            token deletion, if possible. If it can't do that, it bails on the current
            rule and uses the default error recovery, which consumes until the
            resynchronization set of the current rule.
            <p>If the sub rule is optional (
            <c>(...)?</c>
            ,
            <c>(...)*</c>
            , or block
            with an empty alternative), then the expected set includes what follows
            the subrule.</p>
            <p>During loop iteration, it consumes until it sees a token that can start a
            sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
            stay in the loop as long as possible.</p>
            <p><strong>ORIGINS</strong></p>
            <p>Previous versions of ANTLR did a poor job of their recovery within loops.
            A single mismatch token or missing token would force the parser to bail
            out of the entire rules surrounding the loop. So, for rule</p>
            <pre>
            classDef : 'class' ID '{' member* '}'
            </pre>
            input with an extra token between members would force the parser to
            consume until it found the next class definition rather than the next
            member definition of the current class.
            <p>This functionality cost a little bit of effort because the parser has to
            compare token set at the start of the loop and at each iteration. If for
            some reason speed is suffering for you, you can turn off this
            functionality by simply overriding this method as a blank { }.</p>
            </summary>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportNoViableAlternative(Antlr4.Runtime.Parser,Antlr4.Runtime.NoViableAltException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            when the exception is a
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportInputMismatch(Antlr4.Runtime.Parser,Antlr4.Runtime.InputMismatchException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            when the exception is an
            <see cref="T:Antlr4.Runtime.InputMismatchException"/>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportFailedPredicate(Antlr4.Runtime.Parser,Antlr4.Runtime.FailedPredicateException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            when the exception is a
            <see cref="T:Antlr4.Runtime.FailedPredicateException"/>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportUnwantedToken(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to report a syntax error which requires the removal
            of a token from the input stream.
            </summary>
            <remarks>
            This method is called to report a syntax error which requires the removal
            of a token from the input stream. At the time this method is called, the
            erroneous symbol is current
            <c>LT(1)</c>
            symbol and has not yet been
            removed from the input stream. When this method returns,
            <paramref name="recognizer"/>
            is in error recovery mode.
            <p>This method is called when
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)"/>
            identifies
            single-token deletion as a viable recovery strategy for a mismatched
            input error.</p>
            <p>The default implementation simply returns if the handler is already in
            error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)"/>
            to
            enter error recovery mode, followed by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMissingToken(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to report a syntax error which requires the
            insertion of a missing token into the input stream.
            </summary>
            <remarks>
            This method is called to report a syntax error which requires the
            insertion of a missing token into the input stream. At the time this
            method is called, the missing token has not yet been inserted. When this
            method returns,
            <paramref name="recognizer"/>
            is in error recovery mode.
            <p>This method is called when
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)"/>
            identifies
            single-token insertion as a viable recovery strategy for a mismatched
            input error.</p>
            <p>The default implementation simply returns if the handler is already in
            error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)"/>
            to
            enter error recovery mode, followed by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc/>
            <p>The default implementation attempts to recover from the mismatched input
            by using single token insertion and deletion as described below. If the
            recovery attempt fails, this method throws an
            <see cref="T:Antlr4.Runtime.InputMismatchException"/>
            .</p>
            <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
            <p>
            <c>LA(1)</c>
            is not what we are looking for. If
            <c>LA(2)</c>
            has the
            right token, however, then assume
            <c>LA(1)</c>
            is some extra spurious
            token and delete it. Then consume and return the next token (which was
            the
            <c>LA(2)</c>
            token) as the successful result of the match operation.</p>
            <p>This recovery strategy is implemented by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)"/>
            .</p>
            <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
            <p>If current token (at
            <c>LA(1)</c>
            ) is consistent with what could come
            after the expected
            <c>LA(1)</c>
            token, then assume the token is missing
            and use the parser's
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            to create it on the fly. The
            "insertion" is performed by returning the created token as the successful
            result of the match operation.</p>
            <p>This recovery strategy is implemented by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)"/>
            .</p>
            <p><strong>EXAMPLE</strong></p>
            <p>For example, Input
            <c>i=(3;</c>
            is clearly missing the
            <c>')'</c>
            . When
            the parser returns from the nested call to
            <c>expr</c>
            , it will have
            call chain:</p>
            <pre>
            stat &#x2192; expr &#x2192; atom
            </pre>
            and it will be trying to match the
            <c>')'</c>
            at this point in the
            derivation:
            <pre>
            =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
            ^
            </pre>
            The attempt to match
            <c>')'</c>
            will fail when it sees
            <c>';'</c>
            and
            call
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            . To recover, it sees that
            <c>LA(1)==';'</c>
            is in the set of tokens that can follow the
            <c>')'</c>
            token reference
            in rule
            <c>atom</c>
            . It can assume that you forgot the
            <c>')'</c>
            .
            </summary>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)">
            <summary>
            This method implements the single-token insertion inline error recovery
            strategy.
            </summary>
            <remarks>
            This method implements the single-token insertion inline error recovery
            strategy. It is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            if the single-token
            deletion strategy fails to recover from the mismatched input. If this
            method returns
            <see langword="true"/>
            ,
            <paramref name="recognizer"/>
            will be in error recovery
            mode.
            <p>This method determines whether or not single-token insertion is viable by
            checking if the
            <c>LA(1)</c>
            input symbol could be successfully matched
            if it were instead the
            <c>LA(2)</c>
            symbol. If this method returns
            <see langword="true"/>
            , the caller is responsible for creating and inserting a
            token with the correct type to produce this behavior.</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <returns>

            <see langword="true"/>
            if single-token insertion is a viable recovery
            strategy for the current mismatched input, otherwise
            <see langword="false"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)">
            <summary>
            This method implements the single-token deletion inline error recovery
            strategy.
            </summary>
            <remarks>
            This method implements the single-token deletion inline error recovery
            strategy. It is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            to attempt to recover
            from mismatched input. If this method returns null, the parser and error
            handler state will not have changed. If this method returns non-null,
            <paramref name="recognizer"/>
            will <em>not</em> be in error recovery mode since the
            returned token was a successful match.
            <p>If the single-token deletion is successful, this method calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportUnwantedToken(Antlr4.Runtime.Parser)"/>
            to report the error, followed by
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            to actually "delete" the extraneous token. Then,
            before returning
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)"/>
            is called to signal a successful
            match.</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <returns>
            the successfully matched
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance if single-token
            deletion successfully recovers from the mismatched input, otherwise
            <see langword="null"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.GetMissingSymbol(Antlr4.Runtime.Parser)">
            <summary>Conjure up a missing token during error recovery.</summary>
            <remarks>
            Conjure up a missing token during error recovery.
            The recognizer attempts to recover from single missing
            symbols. But, actions might refer to that missing symbol.
            For example, x=ID {f($x);}. The action clearly assumes
            that there has been an identifier matched previously and that
            $x points at that token. If that token is missing, but
            the next token in the stream is what we want we assume that
            this token is missing and we keep going. Because we
            have to return some token to replace the missing token,
            we have to conjure one up. This method gives the user control
            over the tokens returned for missing tokens. Mostly,
            you will want to create something special for identifier
            tokens. For literals such as '{' and ',', the default
            action in the parser or tree parser works. It simply creates
            a CommonToken of the appropriate type. The text will be the token.
            If you change what tokens must be created by the lexer,
            override this method to create the appropriate tokens.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.GetTokenErrorDisplay(Antlr4.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.
            </summary>
            <remarks>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.toString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ConsumeUntil(Antlr4.Runtime.Parser,Antlr4.Runtime.Misc.IntervalSet)">
            <summary>Consume tokens until one matches the given token set.</summary>
            <remarks>Consume tokens until one matches the given token set.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Dependents">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.AbstractEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.AcceptStateInfo">
            <summary>
            Stores information about a
            <see cref="T:Antlr4.Runtime.Dfa.DFAState"/>
            which is an accept state under
            some condition. Certain settings, such as
            <see cref="P:Antlr4.Runtime.Atn.ParserATNSimulator.PredictionMode"/>
            , may be used in addition to
            this information to determine whether or not a particular state is an accept
            state.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="P:Antlr4.Runtime.Dfa.AcceptStateInfo.Prediction">
            <summary>Gets the prediction made by this accept state.</summary>
            <remarks>
            Gets the prediction made by this accept state. Note that this value
            assumes the predicates, if any, in the
            <see cref="T:Antlr4.Runtime.Dfa.DFAState"/>
            evaluate to
            <see langword="true"/>
            . If predicate evaluation is enabled, the final prediction of
            the accept state will be determined by the result of predicate
            evaluation.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Dfa.AcceptStateInfo.LexerActionExecutor">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which can be used to execute actions
            and/or commands after the lexer matches a token.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.ArrayEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.states">
            <summary>A set of all DFA states.</summary>
            <remarks>
            A set of all DFA states. Use
            <see cref="T:System.Collections.Generic.IDictionary`2"/>
            so we can get old state back
            (
            <see cref="T:System.Collections.Generic.HashSet`1"/>
            only allows you to see if it's there).
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.atnStartState">
            <summary>From which ATN state did we create this DFA?</summary>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.precedenceDfa">
            <summary>
            <see langword="true"/>
            if this DFA is for a precedence decision; otherwise,
            <see langword="false"/>
            . This is the backing field for <see cref="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa"/>.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa">
            <summary>Gets whether this DFA is a precedence DFA.</summary>
            <remarks>
            Gets whether this DFA is a precedence DFA. Precedence DFAs use a special
            start state
            <see cref="F:Antlr4.Runtime.Dfa.DFA.s0"/>
            which is not stored in
            <see cref="F:Antlr4.Runtime.Dfa.DFA.states"/>
            . The
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.edges"/>
            array for this start state contains outgoing edges
            supplying individual start states corresponding to specific precedence
            values.
            </remarks>
            <returns>

            <see langword="true"/>
            if this is a precedence DFA; otherwise,
            <see langword="false"/>
            .
            </returns>
            <seealso cref="P:Antlr4.Runtime.Parser.Precedence"/>
            <summary>Sets whether this is a precedence DFA.</summary>
            <remarks>
            Sets whether this is a precedence DFA. If the specified value differs
            from the current DFA configuration, the following actions are taken;
            otherwise no changes are made to the current DFA.
            <ul>
            <li>The
            <see cref="F:Antlr4.Runtime.Dfa.DFA.states"/>
            map is cleared</li>
            <li>If
            <c>precedenceDfa</c>
            is
            <see langword="false"/>
            , the initial state
            <see cref="F:Antlr4.Runtime.Dfa.DFA.s0"/>
            is set to
            <see langword="null"/>
            ; otherwise, it is initialized to a new
            <see cref="T:Antlr4.Runtime.Dfa.DFAState"/>
            with an empty outgoing
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.edges"/>
            array to
            store the start states for individual precedence values.</li>
            <li>The
            <see cref="F:Antlr4.Runtime.Dfa.DFA.precedenceDfa"/>
            field is updated</li>
            </ul>
            </remarks>
            <value>

            <see langword="true"/>
            if this is a precedence DFA; otherwise,
            <see langword="false"/>
            </value>
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFA.GetPrecedenceStartState(System.Int32,System.Boolean)">
            <summary>Get the start state for a specific precedence value.</summary>
            <remarks>Get the start state for a specific precedence value.</remarks>
            <param name="precedence">The current precedence.</param>
            <param name="fullContext">Whether to get from local of full context.</param>
            <returns>
            The start state corresponding to the specified precedence, or
            <see langword="null"/>
            if no start state exists for the specified precedence.
            </returns>
            <exception cref="T:System.InvalidOperationException">if this is not a precedence DFA.</exception>
            <seealso cref="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa"/>
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFA.SetPrecedenceStartState(System.Int32,System.Boolean,Antlr4.Runtime.Dfa.DFAState)">
            <summary>Set the start state for a specific precedence value.</summary>
            <remarks>Set the start state for a specific precedence value.</remarks>
            <param name="precedence">The current precedence.</param>
            <param name="fullContext">Whether to set local of full context.</param>
            <param name="startState">
            The start state corresponding to the specified
            precedence.
            </param>
            <exception cref="T:System.InvalidOperationException">if this is not a precedence DFA.</exception>
            <seealso cref="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa"/>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFASerializer">
            <summary>A DFA walker that knows how to dump them to serialized strings.</summary>
            <remarks>A DFA walker that knows how to dump them to serialized strings.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFAState">
            <summary>A DFA state represents a set of possible ATN configurations.</summary>
            <remarks>
            A DFA state represents a set of possible ATN configurations.
            As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
            to keep track of all possible states the ATN can be in after
            reading each input symbol.  That is to say, after reading
            input a1a2..an, the DFA is in a state that represents the
            subset T of the states of the ATN that are reachable from the
            ATN's start state along some path labeled a1a2..an."
            In conventional NFA&#x2192;DFA conversion, therefore, the subset T
            would be a bitset representing the set of states the
            ATN could be in.  We need to track the alt predicted by each
            state as well, however.  More importantly, we need to maintain
            a stack of states, tracking the closure operations as they
            jump from rule to rule, emulating rule invocations (method calls).
            I have to add a stack to simulate the proper lookahead sequences for
            the underlying LL grammar from which the ATN was derived.
            <p>I use a set of ATNConfig objects not simple states.  An ATNConfig
            is both a state (ala normal conversion) and a RuleContext describing
            the chain of rules (if any) followed to arrive at that state.</p>
            <p>A DFA state may have multiple references to a particular state,
            but with different ATN contexts (with same or different alts)
            meaning that state was reached via a different set of rule invocations.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.edges">
            <summary>
            <c>edges.get(symbol)</c>
            points to target of symbol.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.contextEdges">
            <summary>These keys for these edges are the top level element of the global context.</summary>
            <remarks>These keys for these edges are the top level element of the global context.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.contextSymbols">
            <summary>Symbols in this set require a global context transition before matching an input symbol.</summary>
            <remarks>Symbols in this set require a global context transition before matching an input symbol.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.predicates">
            <summary>
            This list is computed by
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.PredicateDFAState(Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)"/>
            .
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFAState.PredPrediction">
            <summary>Map a predicate to a predicted alternative.</summary>
            <remarks>Map a predicate to a predicted alternative.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFAState.Equals(System.Object)">
            <summary>
            Two
            <see cref="T:Antlr4.Runtime.Dfa.DFAState"/>
            instances are equal if their ATN configuration sets
            are the same. This method is used to see if a state already exists.
            <p>Because the number of alternatives and number of ATN configurations are
            finite, there is a finite number of DFA states that can be processed.
            This is necessary to show that the algorithm terminates.</p>
            <p>Cannot test the DFA state numbers here because in
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)"/>
            we need to know if any other state
            exists that has this exact set of ATN configurations. The
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.stateNumber"/>
            is irrelevant.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.EmptyEdgeMap`1">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.Dfa.AbstractEdgeMap`1"/>
            represents an empty edge map.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.IEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.SingletonEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.SparseEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.DiagnosticErrorListener">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            can be used to identify
            certain potential correctness and performance problems in grammars. "Reports"
            are made by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            with the appropriate
            message.
            <ul>
            <li><b>Ambiguities</b>: These are cases where more than one path through the
            grammar can match the input.</li>
            <li><b>Weak context sensitivity</b>: These are cases where full-context
            prediction resolved an SLL conflict to a unique alternative which equaled the
            minimum alternative of the SLL conflict.</li>
            <li><b>Strong (forced) context sensitivity</b>: These are cases where the
            full-context prediction resolved an SLL conflict to a unique alternative,
            <em>and</em> the minimum alternative of the SLL conflict was found to not be
            a truly viable alternative. Two-stage parsing cannot be used for inputs where
            this situation occurs.</li>
            </ul>
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.DiagnosticErrorListener.exactOnly">
            <summary>
            When
            <see langword="true"/>
            , only exactly known ambiguities are reported.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.#ctor">
            <summary>
            Initializes a new instance of
            <see cref="T:Antlr4.Runtime.DiagnosticErrorListener"/>
            which only
            reports exact ambiguities.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of
            <see cref="T:Antlr4.Runtime.DiagnosticErrorListener"/>
            , specifying
            whether all ambiguities or only exact ambiguities are reported.
            </summary>
            <param name="exactOnly">

            <see langword="true"/>
            to report only exact ambiguities, otherwise
            <see langword="false"/>
            to report all ambiguities.
            </param>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.GetConflictingAlts(Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>
            Computes the set of conflicting or ambiguous alternatives from a
            configuration set, if that information was not already provided by the
            parser.
            </summary>
            <remarks>
            Computes the set of conflicting or ambiguous alternatives from a
            configuration set, if that information was not already provided by the
            parser.
            </remarks>
            <param name="reportedAlts">
            The set of conflicting or ambiguous alternatives, as
            reported by the parser.
            </param>
            <param name="configs">The conflicting or ambiguous configuration set.</param>
            <returns>
            Returns
            <paramref name="reportedAlts"/>
            if it is not
            <see langword="null"/>
            , otherwise
            returns the set of alternatives represented in
            <paramref name="configs"/>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.FailedPredicateException">
            <summary>A semantic predicate failed during validation.</summary>
            <remarks>
            A semantic predicate failed during validation.  Validation of predicates
            occurs when normally parsing the alternative just like matching a token.
            Disambiguating predicate evaluation occurs when we test a predicate during
            prediction.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.IAntlrErrorListener`1">
            <summary>How to emit recognition errors.</summary>
            <remarks>How to emit recognition errors.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorListener`1.SyntaxError(Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)">
            <summary>Upon syntax error, notify any interested parties.</summary>
            <remarks>
            Upon syntax error, notify any interested parties. This is not how to
            recover from errors or compute error messages.
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy"/>
            specifies how to recover from syntax errors and how to compute error
            messages. This listener's job is simply to emit a computed message,
            though it has enough information to create its own message in many cases.
            <p>The
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            is non-null for all syntax errors except
            when we discover mismatched token errors that we can recover from
            in-line, without returning from the surrounding rule (via the single
            token insertion and deletion mechanism).</p>
            </remarks>
            <param name="recognizer">
            What parser got the error. From this
            object, you can access the context as well
            as the input stream.
            </param>
            <param name="offendingSymbol">
            The offending token in the input token
            stream, unless recognizer is a lexer (then it's null). If
            no viable alternative error,
            <paramref name="e"/>
            has token at which we
            started production for the decision.
            </param>
            <param name="line">The line number in the input where the error occurred.</param>
            <param name="charPositionInLine">The character position within that line where the error occurred.</param>
            <param name="msg">The message to emit.</param>
            <param name="e">
            The exception generated by the parser that led to
            the reporting of an error. It is null in the case where
            the parser was able to recover in line without exiting the
            surrounding rule.
            </param>
        </member>
        <member name="T:Antlr4.Runtime.IAntlrErrorStrategy">
            <summary>
            The interface for defining strategies to deal with syntax errors encountered
            during a parse by ANTLR-generated parsers.
            </summary>
            <remarks>
            The interface for defining strategies to deal with syntax errors encountered
            during a parse by ANTLR-generated parsers. We distinguish between three
            different kinds of errors:
            <ul>
            <li>The parser could not figure out which path to take in the ATN (none of
            the available alternatives could possibly match)</li>
            <li>The current input does not match what we were looking for</li>
            <li>A predicate evaluated to false</li>
            </ul>
            Implementations of this interface report syntax errors by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            .
            <p>TODO: what to do about lexers</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Reset(Antlr4.Runtime.Parser)">
            <summary>
            Reset the error handler state for the specified
            <paramref name="recognizer"/>
            .
            </summary>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            This method is called when an unexpected symbol is encountered during an
            inline match operation, such as
            <see cref="M:Antlr4.Runtime.Parser.Match(System.Int32)"/>
            . If the error
            strategy successfully recovers from the match failure, this method
            returns the
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance which should be treated as the
            successful result of the match.
            <p>Note that the calling code will not report an error if this method
            returns successfully. The error strategy implementation is responsible
            for calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            as appropriate.</p>
            </summary>
            <param name="recognizer">the parser instance</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the error strategy was not able to
            recover from the unexpected input symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            This method is called to recover from exception
            <paramref name="e"/>
            . This method is
            called after
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            by the default exception handler
            generated for a rule method.
            </summary>
            <seealso cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception to recover from</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the error strategy could not recover from
            the recognition exception
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>
            This method provides the error handler with an opportunity to handle
            syntactic or semantic errors in the input stream before they result in a
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            .
            <p>The generated code currently contains calls to
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            after
            entering the decision state of a closure block (
            <c>(...)*</c>
            or
            <c>(...)+</c>
            ).</p>
            <p>For an implementation based on Jim Idle's "magic sync" mechanism, see
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            .</p>
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            <param name="recognizer">the parser instance</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if an error is detected by the error
            strategy but cannot be automatically recovered at the current state in
            the parsing process
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)">
            <summary>
            Tests whether or not
            <paramref name="recognizer"/>
            is in the process of recovering
            from an error. In error recovery mode,
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            adds
            symbols to the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            instead of
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.IToken)"/>
            .
            </summary>
            <param name="recognizer">the parser instance</param>
            <returns>

            <see langword="true"/>
            if the parser is currently recovering from a parse
            error, otherwise
            <see langword="false"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">
            <summary>
            This method is called by when the parser successfully matches an input
            symbol.
            </summary>
            <remarks>
            This method is called by when the parser successfully matches an input
            symbol.
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            Report any kind of
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            . This method is called by
            the default exception handler generated for a rule method.
            </summary>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception to report</param>
        </member>
        <member name="T:Antlr4.Runtime.ICharStream">
            <summary>A source of characters for an ANTLR lexer.</summary>
            <remarks>A source of characters for an ANTLR lexer.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.ICharStream.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            This method returns the text for a range of characters within this input
            stream.
            </summary>
            <remarks>
            This method returns the text for a range of characters within this input
            stream. This method is guaranteed to not throw an exception if the
            specified
            <paramref name="interval"/>
            lies entirely within a marked range. For more
            information about marked ranges, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            .
            </remarks>
            <param name="interval">an interval within the stream</param>
            <returns>the text of the specified interval</returns>
            <exception cref="T:System.ArgumentNullException">
            if
            <paramref name="interval"/>
            is
            <see langword="null"/>
            </exception>
            <exception cref="T:System.ArgumentException">
            if
            <c>interval.a &lt; 0</c>
            , or if
            <c>interval.b &lt; interval.a - 1</c>
            , or if
            <c>interval.b</c>
            lies at or
            past the end of the stream
            </exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            getting the text of the specified interval
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.IIntStream">
            <summary>A simple stream of symbols whose values are represented as integers.</summary>
            <remarks>
            A simple stream of symbols whose values are represented as integers. This
            interface provides <em>marked ranges</em> with support for a minimum level
            of buffering necessary to implement arbitrary lookahead during prediction.
            For more information on marked ranges, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            .
            <p><strong>Initializing Methods:</strong> Some methods in this interface have
            unspecified behavior if no call to an initializing method has occurred after
            the stream was constructed. The following is a list of initializing methods:</p>
            <ul>
            <li>
            <see cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)"/>
            </li>
            <li>
            <see cref="M:Antlr4.Runtime.IIntStream.Consume"/>
            </li>
            <li>
            <see cref="P:Antlr4.Runtime.IIntStream.Size"/>
            </li>
            </ul>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Consume">
            <summary>Consumes the current symbol in the stream.</summary>
            <remarks>
            Consumes the current symbol in the stream. This method has the following
            effects:
            <ul>
            <li><strong>Forward movement:</strong> The value of
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            before calling this method is less than the value of
            <c>index()</c>
            after calling this method.</li>
            <li><strong>Ordered lookahead:</strong> The value of
            <c>LA(1)</c>
            before
            calling this method becomes the value of
            <c>LA(-1)</c>
            after calling
            this method.</li>
            </ul>
            Note that calling this method does not guarantee that
            <c>index()</c>
            is
            incremented by exactly 1, as that would preclude the ability to implement
            filtering streams (e.g.
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            which distinguishes
            between "on-channel" and "off-channel" tokens).
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            if an attempt is made to consume the the
            end of the stream (i.e. if
            <c>LA(1)==</c>
            <see cref="F:Antlr4.Runtime.IntStreamConstants.Eof">EOF</see>
            before calling
            <c>consume</c>
            ).
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.La(System.Int32)">
            <summary>
            Gets the value of the symbol at offset
            <paramref name="i"/>
            from the current
            position. When
            <c>i==1</c>
            , this method returns the value of the current
            symbol in the stream (which is the next symbol to be consumed). When
            <c>i==-1</c>
            , this method returns the value of the previously read
            symbol in the stream. It is not valid to call this method with
            <c>i==0</c>
            , but the specific behavior is unspecified because this
            method is frequently called from performance-critical code.
            <p>This method is guaranteed to succeed if any of the following are true:</p>
            <ul>
            <li>
            <c>i&gt;0</c>
            </li>
            <li>
            <c>i==-1</c>
            and
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            returns a value greater
            than the value of
            <c>index()</c>
            after the stream was constructed
            and
            <c>LA(1)</c>
            was called in that order. Specifying the current
            <c>index()</c>
            relative to the index after the stream was created
            allows for filtering implementations that do not return every symbol
            from the underlying source. Specifying the call to
            <c>LA(1)</c>
            allows for lazily initialized streams.</li>
            <li>
            <c>LA(i)</c>
            refers to a symbol consumed within a marked region
            that has not yet been released.</li>
            </ul>
            <p>If
            <paramref name="i"/>
            represents a position at or beyond the end of the stream,
            this method returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.Eof"/>
            .</p>
            <p>The return value is unspecified if
            <c>i&lt;0</c>
            and fewer than
            <c>-i</c>
            calls to
            <see cref="M:Antlr4.Runtime.IIntStream.Consume">consume()</see>
            have occurred from the beginning of
            the stream before calling this method.</p>
            </summary>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            retrieving the value of the specified symbol
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Mark">
            <summary>
            A mark provides a guarantee that
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">seek()</see>
            operations will be
            valid over a "marked range" extending from the index where
            <c>mark()</c>
            was called to the current
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            . This allows the use of
            streaming input sources by specifying the minimum buffering requirements
            to support arbitrary lookahead during prediction.
            <p>The returned mark is an opaque handle (type
            <c>int</c>
            ) which is passed
            to
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release()</see>
            when the guarantees provided by the marked
            range are no longer necessary. When calls to
            <c>mark()</c>
            /
            <c>release()</c>
            are nested, the marks must be released
            in reverse order of which they were obtained. Since marked regions are
            used during performance-critical sections of prediction, the specific
            behavior of invalid usage is unspecified (i.e. a mark is not released, or
            a mark is released twice, or marks are not released in reverse order from
            which they were created).</p>
            <p>The behavior of this method is unspecified if no call to an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream was
            constructed.</p>
            <p>This method does not change the current position in the input stream.</p>
            <p>The following example shows the use of
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">mark()</see>
            ,
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release(mark)</see>
            ,
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            , and
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">seek(index)</see>
            as part of an operation to safely work within a
            marked region, then restore the stream position to its original value and
            release the mark.</p>
            <pre>
            IntStream stream = ...;
            int index = -1;
            int mark = stream.mark();
            try {
            index = stream.index();
            // perform work here...
            } finally {
            if (index != -1) {
            stream.seek(index);
            }
            stream.release(mark);
            }
            </pre>
            </summary>
            <returns>
            An opaque marker which should be passed to
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release()</see>
            when the marked range is no longer required.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">
            <summary>
            This method releases a marked range created by a call to
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">mark()</see>
            . Calls to
            <c>release()</c>
            must appear in the
            reverse order of the corresponding calls to
            <c>mark()</c>
            . If a mark is
            released twice, or if marks are not released in reverse order of the
            corresponding calls to
            <c>mark()</c>
            , the behavior is unspecified.
            <p>For more information and an example, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            .</p>
            </summary>
            <param name="marker">
            A marker returned by a call to
            <c>mark()</c>
            .
            </param>
            <seealso cref="M:Antlr4.Runtime.IIntStream.Mark"/>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.Index">
            <summary>
            Return the index into the stream of the input symbol referred to by
            <c>LA(1)</c>
            .
            <p>The behavior of this method is unspecified if no call to an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream was
            constructed.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">
            <summary>
            Set the input cursor to the position indicated by
            <paramref name="index"/>
            . If the
            specified index lies past the end of the stream, the operation behaves as
            though
            <paramref name="index"/>
            was the index of the EOF symbol. After this method
            returns without throwing an exception, the at least one of the following
            will be true.
            <ul>
            <li>
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            will return the index of the first symbol
            appearing at or after the specified
            <paramref name="index"/>
            . Specifically,
            implementations which filter their sources should automatically
            adjust
            <paramref name="index"/>
            forward the minimum amount required for the
            operation to target a non-ignored symbol.</li>
            <li>
            <c>LA(1)</c>
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.Eof"/>
            </li>
            </ul>
            This operation is guaranteed to not throw an exception if
            <paramref name="index"/>
            lies within a marked region. For more information on marked regions, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            . The behavior of this method is unspecified if no call to
            an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream
            was constructed.
            </summary>
            <param name="index">The absolute index to seek to.</param>
            <exception cref="T:System.ArgumentException">
            if
            <paramref name="index"/>
            is less than 0
            </exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            seeking to the specified index
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.Size">
            <summary>
            Returns the total number of symbols in the stream, including a single EOF
            symbol.
            </summary>
            <remarks>
            Returns the total number of symbols in the stream, including a single EOF
            symbol.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            if the size of the stream is
            unknown.
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.SourceName">
            <summary>Gets the name of the underlying symbol source.</summary>
            <remarks>
            Gets the name of the underlying symbol source. This method returns a
            non-null, non-empty string. If such a name is not known, this method
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName"/>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.IntStreamConstants.Eof">
            <summary>
            The value returned by
            <see cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)">LA()</see>
            when the end of the stream is
            reached.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName">
            <summary>
            The value returned by
            <see cref="P:Antlr4.Runtime.IIntStream.SourceName"/>
            when the actual name of the
            underlying source is not known.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.InputMismatchException">
            <summary>
            This signifies any kind of mismatched input exceptions such as
            when the current input does not match the expected token.
            </summary>
            <remarks>
            This signifies any kind of mismatched input exceptions such as
            when the current input does not match the expected token.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.InterpreterRuleContext">
            <summary>
            This class extends
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            by allowing the value of
            <see cref="P:Antlr4.Runtime.InterpreterRuleContext.RuleIndex"/>
            to be explicitly set for the context.
            <p>
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            does not include field storage for the rule index
            since the context classes created by the code generator override the
            <see cref="P:Antlr4.Runtime.InterpreterRuleContext.RuleIndex"/>
            method to return the correct value for that context.
            Since the parser interpreter does not use the context classes generated for a
            parser, this class (with slightly more memory overhead per node) is used to
            provide equivalent functionality.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.InterpreterRuleContext.ruleIndex">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.InterpreterRuleContext.RuleIndex"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.InterpreterRuleContext.#ctor(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.InterpreterRuleContext"/>
            with the specified
            parent, invoking state, and rule index.
            </summary>
            <param name="parent">The parent context.</param>
            <param name="invokingStateNumber">The invoking state number.</param>
            <param name="ruleIndex">The rule index for the current context.</param>
        </member>
        <member name="T:Antlr4.Runtime.IParserErrorListener">
            <summary>How to emit recognition errors for parsers.</summary>
            <remarks>How to emit recognition errors for parsers.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>
            This method is called by the parser when a full-context prediction
            results in an ambiguity.
            </summary>
            <remarks>
            This method is called by the parser when a full-context prediction
            results in an ambiguity.
            <p>Each full-context prediction which does not result in a syntax error
            will call either
            <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
            or
            <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            .</p>
            <p>
            When
            <paramref name="ambigAlts"/>
            is not null, it contains the set of potentially
            viable alternatives identified by the prediction algorithm. When
            <paramref name="ambigAlts"/>
            is null, use
            <see cref="P:Antlr4.Runtime.Atn.ATNConfigSet.RepresentedAlternatives"/>
            to obtain the represented
            alternatives from the
            <paramref name="configs"/>
            argument.</p>
            <p>When
            <paramref name="exact"/>
            is
            <see langword="true"/>
            , <em>all</em> of the potentially
            viable alternatives are truly viable, i.e. this is reporting an exact
            ambiguity. When
            <paramref name="exact"/>
            is
            <see langword="false"/>
            , <em>at least two</em> of
            the potentially viable alternatives are viable for the current input, but
            the prediction algorithm terminated as soon as it determined that at
            least the <em>minimum</em> potentially viable alternative is truly
            viable.</p>
            <p>When the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection"/>
            prediction
            mode is used, the parser is required to identify exact ambiguities so
            <paramref name="exact"/>
            will always be
            <see langword="true"/>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">the input input where the ambiguity was identified</param>
            <param name="exact">

            <see langword="true"/>
            if the ambiguity is exactly known, otherwise
            <see langword="false"/>
            . This is always
            <see langword="true"/>
            when
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection"/>
            is used.
            </param>
            <param name="ambigAlts">
            the potentially ambiguous alternatives, or
            <see langword="null"/>
            to indicate that the potentially ambiguous alternatives are the complete
            set of represented alternatives in
            <paramref name="configs"/>
            </param>
            <param name="configs">
            the ATN configuration set where the ambiguity was
            identified
            </param>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportAttemptingFullContext(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            This method is called when an SLL conflict occurs and the parser is about
            to use the full context information to make an LL decision.
            </summary>
            <remarks>
            This method is called when an SLL conflict occurs and the parser is about
            to use the full context information to make an LL decision.
            <p>If one or more configurations in
            <c>configs</c>
            contains a semantic
            predicate, the predicates are evaluated before this method is called. The
            subset of alternatives which are still viable after predicates are
            evaluated is reported in
            <paramref name="conflictingAlts"/>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">the input index where the SLL conflict occurred</param>
            <param name="conflictingAlts">
            The specific conflicting alternatives. If this is
            <see langword="null"/>
            , the conflicting alternatives are all alternatives
            represented in
            <c>configs</c>
            .
            </param>
            <param name="conflictState">
            the simulator state when the SLL conflict was
            detected
            </param>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            This method is called by the parser when a full-context prediction has a
            unique result.
            </summary>
            <remarks>
            This method is called by the parser when a full-context prediction has a
            unique result.
            <p>Each full-context prediction which does not result in a syntax error
            will call either
            <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
            or
            <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            .</p>
            <p>For prediction implementations that only evaluate full-context
            predictions when an SLL conflict is found (including the default
            <see cref="T:Antlr4.Runtime.Atn.ParserATNSimulator"/>
            implementation), this method reports cases
            where SLL conflicts were resolved to unique full-context predictions,
            i.e. the decision was context-sensitive. This report does not necessarily
            indicate a problem, and it may appear even in completely unambiguous
            grammars.</p>
            <p>
            <c>configs</c>
            may have more than one represented alternative if the
            full-context prediction algorithm does not evaluate predicates before
            beginning the full-context prediction. In all cases, the final prediction
            is passed as the
            <paramref name="prediction"/>
            argument.</p>
            <p>Note that the definition of "context sensitivity" in this method
            differs from the concept in
            <see cref="F:Antlr4.Runtime.Atn.DecisionInfo.contextSensitivities"/>
            .
            This method reports all instances where an SLL conflict occurred but LL
            parsing produced a unique result, whether or not that unique result
            matches the minimum alternative in the SLL conflicting set.</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">
            the input index where the context sensitivity was
            finally determined
            </param>
            <param name="prediction">the unambiguous result of the full-context prediction</param>
            <param name="acceptState">
            the simulator state when the unambiguous prediction
            was determined
            </param>
        </member>
        <member name="T:Antlr4.Runtime.IToken">
            <summary>
            A token has properties: text, type, line, character position in the line
            (so we can ignore tabs), token channel, index, and source from which
            we obtained this token.
            </summary>
            <remarks>
            A token has properties: text, type, line, character position in the line
            (so we can ignore tabs), token channel, index, and source from which
            we obtained this token.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Text">
            <summary>Get the text of the token.</summary>
            <remarks>Get the text of the token.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Type">
            <summary>Get the token type of the token.</summary>
            <remarks>Get the token type of the token.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Line">
            <summary>
            The line number on which the 1st character of this token was matched,
            line=1..n
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Column">
            <summary>
            The index of the first character of this token relative to the
            beginning of the line at which it occurs, 0..n-1
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Channel">
            <summary>Return the channel this token.</summary>
            <remarks>
            Return the channel this token. Each token can arrive at the parser
            on a different channel, but the parser only "tunes" to a single channel.
            The parser ignores everything not on DEFAULT_CHANNEL.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.TokenIndex">
            <summary>An index from 0..n-1 of the token object in the input stream.</summary>
            <remarks>
            An index from 0..n-1 of the token object in the input stream.
            This must be valid in order to print token streams and
            use TokenRewriteStream.
            Return -1 to indicate that this token was conjured up since
            it doesn't have a valid index.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.StartIndex">
            <summary>
            The starting character index of the token
            This method is optional; return -1 if not implemented.
            </summary>
            <remarks>
            The starting character index of the token
            This method is optional; return -1 if not implemented.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.StopIndex">
            <summary>The last character index of the token.</summary>
            <remarks>
            The last character index of the token.
            This method is optional; return -1 if not implemented.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.TokenSource">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            which created this token.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.InputStream">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            from which this token was derived.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.Epsilon">
            <summary>
            During lookahead operations, this "token" signifies we hit rule end ATN state
            and did not follow it despite needing to.
            </summary>
            <remarks>
            During lookahead operations, this "token" signifies we hit rule end ATN state
            and did not follow it despite needing to.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.DefaultChannel">
            <summary>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".
            </summary>
            <remarks>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".  The parser tunes to a particular channel
            so that whitespace etc... can go to the parser on a "hidden" channel.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.HiddenChannel">
            <summary>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </summary>
            <remarks>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.MinUserChannelValue">
            <summary>
            This is the minimum constant value which can be assigned to a
            user-defined token channel.
            </summary>
            <remarks>
            This is the minimum constant value which can be assigned to a
            user-defined token channel.
            <p>
            The non-negative numbers less than
            <see cref="F:Antlr4.Runtime.TokenConstants.MinUserChannelValue"/>
            are
            assigned to the predefined channels
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            and
            <see cref="F:Antlr4.Runtime.TokenConstants.HiddenChannel"/>
            .</p>
            </remarks>
            <seealso cref="P:Antlr4.Runtime.IToken.Channel"/>
        </member>
        <member name="T:Antlr4.Runtime.ITokenFactory">
            <summary>The default mechanism for creating tokens.</summary>
            <remarks>
            The default mechanism for creating tokens. It's used by default in Lexer and
            the error handling strategy (to create missing tokens).  Notifying the parser
            of a new factory means that it notifies it's token source and error strategy.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ITokenFactory.Create(System.Tuple{Antlr4.Runtime.ITokenSource,Antlr4.Runtime.ICharStream},System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This is the method used to create tokens in the lexer and in the
            error handling strategy.
            </summary>
            <remarks>
            This is the method used to create tokens in the lexer and in the
            error handling strategy. If text!=null, than the start and stop positions
            are wiped to -1 in the text override is set in the CommonToken.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ITokenFactory.Create(System.Int32,System.String)">
            <summary>Generically useful</summary>
        </member>
        <member name="T:Antlr4.Runtime.ITokenSource">
            <summary>
            A source of tokens must provide a sequence of tokens via
            <see cref="M:Antlr4.Runtime.ITokenSource.NextToken"/>
            and also must reveal it's source of characters;
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            's text is
            computed from a
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            ; it only store indices into the char
            stream.
            <p>Errors from the lexer are never passed to the parser. Either you want to keep
            going or you do not upon token recognition error. If you do not want to
            continue lexing then you do not want to continue parsing. Just throw an
            exception not under
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            and Java will naturally toss
            you all the way out of the recognizers. If you want to continue lexing then
            you should not throw an exception to the parser--it has already requested a
            token. Keep lexing until you get a valid one. Just report errors and keep
            going, looking for a valid token.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ITokenSource.NextToken">
            <summary>
            Return a
            <see cref="T:Antlr4.Runtime.IToken"/>
            object from your input stream (usually a
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            ). Do not fail/return upon lexing error; keep chewing
            on the characters until you get a good one; errors are not passed through
            to the parser.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.Line">
            <summary>Get the line number for the current position in the input stream.</summary>
            <remarks>
            Get the line number for the current position in the input stream. The
            first line in the input is line 1.
            </remarks>
            <returns>
            The line number for the current position in the input stream, or
            0 if the current token source does not track line numbers.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.Column">
            <summary>
            Get the index into the current line for the current position in the input
            stream.
            </summary>
            <remarks>
            Get the index into the current line for the current position in the input
            stream. The first character on a line has position 0.
            </remarks>
            <returns>
            The line number for the current position in the input stream, or
            -1 if the current token source does not track character positions.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.InputStream">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            from which this token source is currently
            providing tokens.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            associated with the current position in
            the input, or
            <see langword="null"/>
            if no input stream is available for the token
            source.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.SourceName">
            <summary>Gets the name of the underlying input source.</summary>
            <remarks>
            Gets the name of the underlying input source. This method returns a
            non-null, non-empty string. If such a name is not known, this method
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName"/>
            .
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.TokenFactory">
            <summary>
            Set the
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            this token source should use for creating
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects from the input.
            </summary>
            <value>
            The
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            to use for creating tokens.
            </value>
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            this token source is currently using for
            creating
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects from the input.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            currently used by this token source.
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.ITokenStream">
            <summary>
            An
            <see cref="T:Antlr4.Runtime.IIntStream"/>
            whose symbols are
            <see cref="T:Antlr4.Runtime.IToken"/>
            instances.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.Lt(System.Int32)">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance associated with the value returned by
            <see cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)">LA(k)</see>
            . This method has the same pre- and post-conditions as
            <see cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)"/>
            . In addition, when the preconditions of this method
            are met, the return value is non-null and the value of
            <c>LT(k).getType()==LA(k)</c>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.Get(System.Int32)">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.IToken"/>
            at the specified
            <c>index</c>
            in the stream. When
            the preconditions of this method are met, the return value is non-null.
            <p>The preconditions for this method are the same as the preconditions of
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
            . If the behavior of
            <c>seek(index)</c>
            is
            unspecified for the current state and given
            <c>index</c>
            , then the
            behavior of this method is also unspecified.</p>
            <p>The symbol referred to by
            <c>index</c>
            differs from
            <c>seek()</c>
            only
            in the case of filtering streams where
            <c>index</c>
            lies before the end
            of the stream. Unlike
            <c>seek()</c>
            , this method does not adjust
            <c>index</c>
            to point to a non-ignored symbol.</p>
            </summary>
            <exception cref="T:System.ArgumentException">if {code index} is less than 0</exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            retrieving the token at the specified index
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.ITokenStream.TokenSource">
            <summary>
            Gets the underlying
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            which provides tokens for this
            stream.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the text of all tokens within the specified
            <paramref name="interval"/>
            . This
            method behaves like the following code (including potential exceptions
            for violating preconditions of
            <see cref="M:Antlr4.Runtime.ITokenStream.Get(System.Int32)"/>
            , but may be optimized by the
            specific implementation.
            <pre>
            TokenStream stream = ...;
            String text = "";
            for (int i = interval.a; i &lt;= interval.b; i++) {
            text += stream.get(i).getText();
            }
            </pre>
            </summary>
            <param name="interval">
            The interval of tokens within this stream to get text
            for.
            </param>
            <returns>
            The text of all tokens within the specified interval in this
            stream.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            if
            <paramref name="interval"/>
            is
            <see langword="null"/>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText">
            <summary>Return the text of all tokens in the stream.</summary>
            <remarks>
            Return the text of all tokens in the stream. This method behaves like the
            following code, including potential exceptions from the calls to
            <see cref="P:Antlr4.Runtime.IIntStream.Size"/>
            and
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)"/>
            , but may be
            optimized by the specific implementation.
            <pre>
            TokenStream stream = ...;
            String text = stream.getText(new Interval(0, stream.size()));
            </pre>
            </remarks>
            <returns>The text of all tokens in the stream.</returns>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.RuleContext)">
            <summary>
            Return the text of all tokens in the source interval of the specified
            context.
            </summary>
            <remarks>
            Return the text of all tokens in the source interval of the specified
            context. This method behaves like the following code, including potential
            exceptions from the call to
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)"/>
            , but may be
            optimized by the specific implementation.
            <p>If
            <c>ctx.getSourceInterval()</c>
            does not return a valid interval of
            tokens provided by this stream, the behavior is unspecified.</p>
            <pre>
            TokenStream stream = ...;
            String text = stream.getText(ctx.getSourceInterval());
            </pre>
            </remarks>
            <param name="ctx">
            The context providing the source interval of tokens to get
            text for.
            </param>
            <returns>
            The text of all tokens within the source interval of
            <paramref name="ctx"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.IToken,Antlr4.Runtime.IToken)">
            <summary>
            Return the text of all tokens in this stream between
            <paramref name="start"/>
            and
            <paramref name="stop"/>
            (inclusive).
            <p>If the specified
            <paramref name="start"/>
            or
            <paramref name="stop"/>
            token was not provided by
            this stream, or if the
            <paramref name="stop"/>
            occurred before the
            <paramref name="start"/>
            token, the behavior is unspecified.</p>
            <p>For streams which ensure that the
            <see cref="P:Antlr4.Runtime.IToken.TokenIndex"/>
            method is
            accurate for all of its provided tokens, this method behaves like the
            following code. Other streams may implement this method in other ways
            provided the behavior is consistent with this at a high level.</p>
            <pre>
            TokenStream stream = ...;
            String text = "";
            for (int i = start.getTokenIndex(); i &lt;= stop.getTokenIndex(); i++) {
            text += stream.get(i).getText();
            }
            </pre>
            </summary>
            <param name="start">The first token in the interval to get text for.</param>
            <param name="stop">The last token in the interval to get text for (inclusive).</param>
            <returns>
            The text of all tokens lying between the specified
            <paramref name="start"/>
            and
            <paramref name="stop"/>
            tokens.
            </returns>
            <exception cref="T:System.NotSupportedException">
            if this stream does not support
            this method for the specified tokens
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.IVocabulary">
            <summary>
            This interface provides information about the vocabulary used by a
            recognizer.
            </summary>
            <remarks>
            This interface provides information about the vocabulary used by a
            recognizer.
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Recognizer`2.Vocabulary"/>
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.IVocabulary.GetLiteralName(System.Int32)">
            <summary>Gets the string literal associated with a token type.</summary>
            <remarks>
            Gets the string literal associated with a token type. The string returned
            by this method, when not
            <see langword="null"/>
            , can be used unaltered in a parser
            grammar to represent this token type.
            <p>The following table shows examples of lexer rules and the literal
            names assigned to the corresponding token types.</p>
            <table>
            <tr>
            <th>Rule</th>
            <th>Literal Name</th>
            <th>Java String Literal</th>
            </tr>
            <tr>
            <td>
            <c>THIS : 'this';</c>
            </td>
            <td>
            <c>'this'</c>
            </td>
            <td>
            <c>"'this'"</c>
            </td>
            </tr>
            <tr>
            <td>
            <c>SQUOTE : '\'';</c>
            </td>
            <td>
            <c>'\''</c>
            </td>
            <td>
            <c>"'\\''"</c>
            </td>
            </tr>
            <tr>
            <td>
            <c>ID : [A-Z]+;</c>
            </td>
            <td>n/a</td>
            <td>
            <see langword="null"/>
            </td>
            </tr>
            </table>
            </remarks>
            <param name="tokenType">The token type.</param>
            <returns>
            The string literal associated with the specified token type, or
            <see langword="null"/>
            if no string literal is associated with the type.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IVocabulary.GetSymbolicName(System.Int32)">
            <summary>Gets the symbolic name associated with a token type.</summary>
            <remarks>
            Gets the symbolic name associated with a token type. The string returned
            by this method, when not
            <see langword="null"/>
            , can be used unaltered in a parser
            grammar to represent this token type.
            <p>This method supports token types defined by any of the following
            methods:</p>
            <ul>
            <li>Tokens created by lexer rules.</li>
            <li>Tokens defined in a
            <c/>
            tokens
            block in a lexer or parser
            grammar.</li>
            <li>The implicitly defined
            <c>EOF</c>
            token, which has the token type
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            .</li>
            </ul>
            <p>The following table shows examples of lexer rules and the literal
            names assigned to the corresponding token types.</p>
            <table>
            <tr>
            <th>Rule</th>
            <th>Symbolic Name</th>
            </tr>
            <tr>
            <td>
            <c>THIS : 'this';</c>
            </td>
            <td>
            <c>THIS</c>
            </td>
            </tr>
            <tr>
            <td>
            <c>SQUOTE : '\'';</c>
            </td>
            <td>
            <c>SQUOTE</c>
            </td>
            </tr>
            <tr>
            <td>
            <c>ID : [A-Z]+;</c>
            </td>
            <td>
            <c>ID</c>
            </td>
            </tr>
            </table>
            </remarks>
            <param name="tokenType">The token type.</param>
            <returns>
            The symbolic name associated with the specified token type, or
            <see langword="null"/>
            if no symbolic name is associated with the type.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IVocabulary.GetDisplayName(System.Int32)">
            <summary>Gets the display name of a token type.</summary>
            <remarks>
            Gets the display name of a token type.
            <p>ANTLR provides a default implementation of this method, but
            applications are free to override the behavior in any manner which makes
            sense for the application. The default implementation returns the first
            result from the following list which produces a non-
            <see langword="null"/>
            result.</p>
            <ol>
            <li>The result of
            <see cref="M:Antlr4.Runtime.IVocabulary.GetLiteralName(System.Int32)"/>
            </li>
            <li>The result of
            <see cref="M:Antlr4.Runtime.IVocabulary.GetSymbolicName(System.Int32)"/>
            </li>
            <li>The result of
            <see cref="M:System.Int32.ToString"/>
            </li>
            </ol>
            </remarks>
            <param name="tokenType">The token type.</param>
            <returns>
            The display name of the token type, for use in error reporting or
            other user-visible messages which reference specific token types.
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Lexer">
            <summary>A lexer is recognizer that draws input symbols from a character stream.</summary>
            <remarks>
            A lexer is recognizer that draws input symbols from a character stream.
            lexer grammars result in a subclass of this object. A Lexer object
            uses simplified match() and error recovery mechanisms in the interest
            of speed.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._factory">
            <summary>How to create token objects</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._token">
            <summary>The goal of all lexer rules/methods is to create a token object.</summary>
            <remarks>
            The goal of all lexer rules/methods is to create a token object.
            This is an instance variable as multiple rules may collaborate to
            create a single token.  nextToken will return this object after
            matching lexer rule(s).  If you subclass to allow multiple token
            emissions, then set this to the last token to be matched or
            something nonnull so that the auto token emit mechanism will not
            emit another token.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartCharIndex">
            <summary>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.
            </summary>
            <remarks>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.  Set at
            the start of nextToken.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartLine">
            <summary>The line on which the first character of the token resides</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartColumn">
            <summary>The character position of first character within the line</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._hitEOF">
            <summary>Once we see EOF on char stream, next token will be EOF.</summary>
            <remarks>
            Once we see EOF on char stream, next token will be EOF.
            If you have DONE : EOF ; then you see DONE EOF.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._channel">
            <summary>The channel number for the current token</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._type">
            <summary>The token type for the current token</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._text">
            <summary>
            You can set the text for the current token to override what is in
            the input char buffer.
            </summary>
            <remarks>
            You can set the text for the current token to override what is in
            the input char buffer.  Use setText() or can set this instance var.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.NextToken">
            <summary>
            Return a token from this source; i.e., match a token on the char
            stream.
            </summary>
            <remarks>
            Return a token from this source; i.e., match a token on the char
            stream.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Skip">
            <summary>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.
            </summary>
            <remarks>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.  nextToken() knows to keep looking when
            a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
            if token==null at end of any token rule, it creates one for you
            and emits it.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.SetInputStream(Antlr4.Runtime.ICharStream)">
            <summary>Set the char stream and reset the lexer</summary>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Emit(Antlr4.Runtime.IToken)">
            <summary>
            By default does not support multiple emits per nextToken invocation
            for efficiency reasons.
            </summary>
            <remarks>
            By default does not support multiple emits per nextToken invocation
            for efficiency reasons.  Subclass and override this method, nextToken,
            and getToken (to push tokens into a list and pull from that list
            rather than a single variable as this implementation does).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Emit">
            <summary>
            The standard method called to automatically emit a token at the
            outermost lexical rule.
            </summary>
            <remarks>
            The standard method called to automatically emit a token at the
            outermost lexical rule.  The token object should point into the
            char buffer start..stop.  If there is a text override in 'text',
            use that to set the token's text.  Override this method to emit
            custom Token objects or provide a new factory.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.CharIndex">
            <summary>What is the index of the current character of lookahead?</summary>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.Text">
            <summary>
            Return the text matched so far for the current token or any text
            override.
            </summary>
            <remarks>
            Return the text matched so far for the current token or any text
            override.
            </remarks>
            <summary>
            Set the complete text of this token; it wipes any previous changes to the
            text.
            </summary>
            <remarks>
            Set the complete text of this token; it wipes any previous changes to the
            text.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.Token">
            <summary>Override if emitting multiple tokens.</summary>
            <remarks>Override if emitting multiple tokens.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.GetAllTokens">
            <summary>Return a list of all Token objects in input char stream.</summary>
            <remarks>
            Return a list of all Token objects in input char stream.
            Forces load of all tokens. Does not include EOF token.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Recover(Antlr4.Runtime.RecognitionException)">
            <summary>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.
            </summary>
            <remarks>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.  You can instead use the rule invocation stack
            to do sophisticated error recovery if you are in a fragment rule.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.LexerNoViableAltException.startIndex">
            <summary>Matching attempted at what input index?</summary>
        </member>
        <member name="F:Antlr4.Runtime.LexerNoViableAltException.deadEndConfigs">
            <summary>Which configurations did we try at input.index() that couldn't match input.LA(1)?</summary>
        </member>
        <member name="T:Antlr4.Runtime.ListTokenSource">
            <summary>
            Provides an implementation of
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            as a wrapper around a list
            of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects.
            <p>If the final token in the list is an
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            token, it will be used
            as the EOF token for every call to
            <see cref="M:Antlr4.Runtime.ListTokenSource.NextToken"/>
            after the end of the
            list is reached. Otherwise, an EOF token will be created.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.tokens">
            <summary>
            The wrapped collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects to return.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.sourceName">
            <summary>The name of the input source.</summary>
            <remarks>
            The name of the input source. If this value is
            <see langword="null"/>
            , a call to
            <see cref="P:Antlr4.Runtime.ListTokenSource.SourceName"/>
            should return the source name used to create the
            the next token in
            <see cref="F:Antlr4.Runtime.ListTokenSource.tokens"/>
            (or the previous token if the end of
            the input has been reached).
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.i">
            <summary>
            The index into
            <see cref="F:Antlr4.Runtime.ListTokenSource.tokens"/>
            of token to return by the next call to
            <see cref="M:Antlr4.Runtime.ListTokenSource.NextToken"/>
            . The end of the input is indicated by this value
            being greater than or equal to the number of items in
            <see cref="F:Antlr4.Runtime.ListTokenSource.tokens"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.eofToken">
            <summary>This field caches the EOF token for the token source.</summary>
            <remarks>This field caches the EOF token for the token source.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource._factory">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.ListTokenSource.TokenFactory"/> property.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ListTokenSource.#ctor(System.Collections.Generic.IList{Antlr4.Runtime.IToken})">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.ListTokenSource"/>
            instance from the specified
            collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects.
            </summary>
            <param name="tokens">
            The collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects to provide as a
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            .
            </param>
            <exception>
            NullPointerException
            if
            <paramref name="tokens"/>
            is
            <see langword="null"/>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.ListTokenSource.#ctor(System.Collections.Generic.IList{Antlr4.Runtime.IToken},System.String)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.ListTokenSource"/>
            instance from the specified
            collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects and source name.
            </summary>
            <param name="tokens">
            The collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects to provide as a
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            .
            </param>
            <param name="sourceName">
            The name of the
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            . If this value is
            <see langword="null"/>
            ,
            <see cref="P:Antlr4.Runtime.ListTokenSource.SourceName"/>
            will attempt to infer the name from
            the next
            <see cref="T:Antlr4.Runtime.IToken"/>
            (or the previous token if the end of the input has
            been reached).
            </param>
            <exception>
            NullPointerException
            if
            <paramref name="tokens"/>
            is
            <see langword="null"/>
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.Column">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:Antlr4.Runtime.ListTokenSource.NextToken">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.Line">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.InputStream">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.SourceName">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.TokenFactory">
            <summary><inheritDoc/></summary>
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:Antlr4.Runtime.Misc.Args">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Args.NotNull(System.String,System.Object)">
            <exception cref="T:System.ArgumentNullException">
            if
            <paramref name="value"/>
            is
            <see langword="null"/>
            .
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.Misc.IIntSet">
            <summary>A generic set of integers.</summary>
            <remarks>A generic set of integers.</remarks>
            <seealso cref="T:Antlr4.Runtime.Misc.IntervalSet"/>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Add(System.Int32)">
            <summary>Adds the specified value to the current set.</summary>
            <remarks>Adds the specified value to the current set.</remarks>
            <param name="el">the value to add</param>
            <exception>
            IllegalStateException
            if the current set is read-only
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.AddAll(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Modify the current
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object to contain all elements that are
            present in itself, the specified
            <paramref name="set"/>
            , or both.
            </summary>
            <param name="set">
            The set to add to the current set. A
            <see langword="null"/>
            argument is
            treated as though it were an empty set.
            </param>
            <returns>

            <c>this</c>
            (to support chained calls)
            </returns>
            <exception>
            IllegalStateException
            if the current set is read-only
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.And(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in both the current set and the specified set
            <paramref name="a"/>
            .
            </summary>
            <param name="a">
            The set to intersect with the current set. A
            <see langword="null"/>
            argument is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the intersection of the
            current set and
            <paramref name="a"/>
            . The value
            <see langword="null"/>
            may be returned in
            place of an empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Complement(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in
            <paramref name="elements"/>
            but not present in the current set. The
            following expressions are equivalent for input non-null
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instances
            <c>x</c>
            and
            <c>y</c>
            .
            <ul>
            <li>
            <c>x.complement(y)</c>
            </li>
            <li>
            <c>y.subtract(x)</c>
            </li>
            </ul>
            </summary>
            <param name="elements">
            The set to compare with the current set. A
            <see langword="null"/>
            argument is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the elements present in
            <paramref name="elements"/>
            but not present in the current set. The value
            <see langword="null"/>
            may be returned in place of an empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Or(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in the current set, the specified set
            <paramref name="a"/>
            , or both.
            <p>
            This method is similar to
            <see cref="M:Antlr4.Runtime.Misc.IIntSet.AddAll(Antlr4.Runtime.Misc.IIntSet)"/>
            , but returns a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance instead of modifying the current set.</p>
            </summary>
            <param name="a">
            The set to union with the current set. A
            <see langword="null"/>
            argument
            is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the union of the current
            set and
            <paramref name="a"/>
            . The value
            <see langword="null"/>
            may be returned in place of an
            empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Subtract(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in the current set but not present in the input set
            <paramref name="a"/>
            .
            The following expressions are equivalent for input non-null
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instances
            <c>x</c>
            and
            <c>y</c>
            .
            <ul>
            <li>
            <c>y.subtract(x)</c>
            </li>
            <li>
            <c>x.complement(y)</c>
            </li>
            </ul>
            </summary>
            <param name="a">
            The set to compare with the current set. A
            <see langword="null"/>
            argument is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the elements present in
            <c>elements</c>
            but not present in the current set. The value
            <see langword="null"/>
            may be returned in place of an empty result set.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IIntSet.Count">
            <summary>Return the total number of elements represented by the current set.</summary>
            <remarks>Return the total number of elements represented by the current set.</remarks>
            <returns>
            the total number of elements represented by the current set,
            regardless of the manner in which the elements are stored.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IIntSet.IsNil">
            <summary>
            Returns
            <see langword="true"/>
            if this set contains no elements.
            </summary>
            <returns>

            <see langword="true"/>
            if the current set contains no elements; otherwise,
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Equals(System.Object)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IIntSet.SingleElement">
            <summary>
            Returns the single value contained in the set, if
            <see cref="P:Antlr4.Runtime.Misc.IIntSet.Count"/>
            is 1;
            otherwise, returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </summary>
            <returns>
            the single value contained in the set, if
            <see cref="P:Antlr4.Runtime.Misc.IIntSet.Count"/>
            is 1;
            otherwise, returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Contains(System.Int32)">
            <summary>
            Returns
            <see langword="true"/>
            if the set contains the specified element.
            </summary>
            <param name="el">The element to check for.</param>
            <returns>

            <see langword="true"/>
            if the set contains
            <paramref name="el"/>
            ; otherwise
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Remove(System.Int32)">
            <summary>Removes the specified value from the current set.</summary>
            <remarks>
            Removes the specified value from the current set. If the current set does
            not contain the element, no changes are made.
            </remarks>
            <param name="el">the value to remove</param>
            <exception>
            IllegalStateException
            if the current set is read-only
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.ToList">
            <summary>Return a list containing the elements represented by the current set.</summary>
            <remarks>
            Return a list containing the elements represented by the current set. The
            list is returned in ascending numerical order.
            </remarks>
            <returns>
            A list containing all element present in the current set, sorted
            in ascending numerical order.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.ToString">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:Antlr4.Runtime.Misc.Interval">
            <summary>An immutable inclusive interval a..b.</summary>
            <remarks>An immutable inclusive interval a..b.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Misc.Interval.a">
            <summary>The start of the interval.</summary>
            <remarks>The start of the interval.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Misc.Interval.b">
            <summary>The end of the interval (inclusive).</summary>
            <remarks>The end of the interval (inclusive).</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Of(System.Int32,System.Int32)">
            <summary>
            Interval objects are used readonly so share all with the
            same single value a==b up to some max size.
            </summary>
            <remarks>
            Interval objects are used readonly so share all with the
            same single value a==b up to some max size.  Use an array as a perfect hash.
            Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
            Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
            have a..a (set with 1 element).
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Misc.Interval.Length">
            <summary>return number of elements between a and b inclusively.</summary>
            <remarks>
            return number of elements between a and b inclusively. x..x is length 1.
            if b &lt; a, then length is 0. 9..10 has length 2.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsBeforeDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start completely before other? Disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsBeforeNonDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start at or before other? Nondisjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfter(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this.a start after other.b? May or may not be disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfterDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start completely after other? Disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfterNonDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start after other? NonDisjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Disjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Are both ranges disjoint? I.e., no overlap?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Adjacent(Antlr4.Runtime.Misc.Interval)">
            <summary>Are two intervals adjacent such as 0..41 and 42..42?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Union(Antlr4.Runtime.Misc.Interval)">
            <summary>Return the interval computed from combining this and other</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Intersection(Antlr4.Runtime.Misc.Interval)">
            <summary>Return the interval in common between this and o</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.DifferenceNotProperlyContained(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the interval with elements from
            <c>this</c>
            not in
            <paramref name="other"/>
            ;
            <paramref name="other"/>
            must not be totally enclosed (properly contained)
            within
            <c>this</c>
            , which would result in two disjoint intervals
            instead of the single one returned by this method.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Misc.IntervalSet">
            <summary>
            This class implements the
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            backed by a sorted array of
            non-overlapping intervals. It is particularly efficient for representing
            large collections of numbers, where the majority of elements appear as part
            of a sequential range of numbers that are all part of the set. For example,
            the set { 1, 2, 3, 4, 7, 8 } may be represented as { [1, 4], [7, 8] }.
            <p>
            This class is able to represent sets containing any combination of values in
            the range
            <see cref="F:System.Int32.MinValue"/>
            to
            <see cref="F:System.Int32.MaxValue"/>
            (inclusive).</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Misc.IntervalSet.intervals">
            <summary>The list of sorted, disjoint intervals.</summary>
            <remarks>The list of sorted, disjoint intervals.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Of(System.Int32)">
            <summary>Create a set with a single element, el.</summary>
            <remarks>Create a set with a single element, el.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Of(System.Int32,System.Int32)">
            <summary>Create a set with all ints within range [a..b] (inclusive)</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Add(System.Int32)">
            <summary>Add a single element to the set.</summary>
            <remarks>
            Add a single element to the set.  An isolated element is stored
            as a range el..el.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Add(System.Int32,System.Int32)">
            <summary>Add interval; i.e., add all integers from a to b to set.</summary>
            <remarks>
            Add interval; i.e., add all integers from a to b to set.
            If b&lt;a, do nothing.
            Keep list in sorted order (by left range value).
            If overlap, combine ranges.  For example,
            If this is {1..5, 10..20}, adding 6..7 yields
            {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Or(Antlr4.Runtime.Misc.IntervalSet[])">
            <summary>combine all sets in the array returned the or'd value</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Complement(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            <inheritDoc/>

            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Subtract(Antlr4.Runtime.Misc.IntervalSet,Antlr4.Runtime.Misc.IntervalSet)">
            <summary>Compute the set difference between two interval sets.</summary>
            <remarks>
            Compute the set difference between two interval sets. The specific
            operation is
            <c>left - right</c>
            . If either of the input sets is
            <see langword="null"/>
            , it is treated as though it was an empty set.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.And(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            <inheritDoc/>

            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Contains(System.Int32)">
            <summary>
            <inheritDoc/>

            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.IsNil">
            <summary>
            <inheritDoc/>

            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.SingleElement">
            <summary>
            <inheritDoc/>

            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.MaxElement">
            <summary>Returns the maximum value contained in the set.</summary>
            <remarks>Returns the maximum value contained in the set.</remarks>
            <returns>
            the maximum value contained in the set. If the set is empty, this
            method returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.MinElement">
            <summary>Returns the minimum value contained in the set.</summary>
            <remarks>Returns the minimum value contained in the set.</remarks>
            <returns>
            the minimum value contained in the set. If the set is empty, this
            method returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.GetIntervals">
            <summary>Return a list of Interval objects.</summary>
            <remarks>Return a list of Interval objects.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Equals(System.Object)">
            <summary>
            Are two IntervalSets equal?  Because all intervals are sorted
            and disjoint, equals is a simple linear walk over both lists
            to make sure they are the same.
            </summary>
            <remarks>
            Are two IntervalSets equal?  Because all intervals are sorted
            and disjoint, equals is a simple linear walk over both lists
            to make sure they are the same.  Interval.equals() is used
            by the List.equals() method to check the ranges.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Misc.MurmurHash">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Initialize">
            <summary>Initialize the hash using the default seed value.</summary>
            <remarks>Initialize the hash using the default seed value.</remarks>
            <returns>the intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Initialize(System.Int32)">
            <summary>
            Initialize the hash using the specified
            <paramref name="seed"/>
            .
            </summary>
            <param name="seed">the seed</param>
            <returns>the intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Int32)">
            <summary>
            Update the intermediate hash value for the next input
            <paramref name="value"/>
            .
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="value">the value to add to the current hash</param>
            <returns>the updated intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Object)">
            <summary>
            Update the intermediate hash value for the next input
            <paramref name="value"/>
            .
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="value">the value to add to the current hash</param>
            <returns>the updated intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Finish(System.Int32,System.Int32)">
            <summary>
            Apply the final computation steps to the intermediate value
            <paramref name="hash"/>
            to form the final result of the MurmurHash 3 hash function.
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="numberOfWords">the number of integer values added to the hash</param>
            <returns>the final hash result</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.HashCode``1(``0[],System.Int32)">
            <summary>
            Utility function to compute the hash code of an array using the
            MurmurHash algorithm.
            </summary>
            <remarks>
            Utility function to compute the hash code of an array using the
            MurmurHash algorithm.
            </remarks>
            <param name="data">the array data</param>
            <param name="seed">the seed for the MurmurHash algorithm</param>
            <returns>the hash code of the data</returns>
        </member>
        <member name="T:Antlr4.Runtime.Misc.ParseCanceledException">
            <summary>This exception is thrown to cancel a parsing operation.</summary>
            <remarks>
            This exception is thrown to cancel a parsing operation. This exception does
            not extend
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            , allowing it to bypass the standard
            error recovery mechanisms.
            <see cref="T:Antlr4.Runtime.BailErrorStrategy"/>
            throws this exception in
            response to a parse error.
            </remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Misc.RuleDependencyChecker">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Utils.ToMap(System.String[])">
            <summary>Convert array of strings to string&#x2192;index map.</summary>
            <remarks>
            Convert array of strings to string&#x2192;index map. Useful for
            converting rulenames to name&#x2192;ruleindex map.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.NoViableAltException">
            <summary>
            Indicates that the parser could not decide which of two or more paths
            to take based upon the remaining input.
            </summary>
            <remarks>
            Indicates that the parser could not decide which of two or more paths
            to take based upon the remaining input. It tracks the starting token
            of the offending input and also knows where the parser was
            in the various paths when the error. Reported by reportNoViableAlternative()
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.NoViableAltException.deadEndConfigs">
            <summary>Which configurations did we try at input.index() that couldn't match input.LT(1)?</summary>
        </member>
        <member name="F:Antlr4.Runtime.NoViableAltException.startToken">
            <summary>
            The token object at the start index; the input stream might
            not be buffering tokens so get a reference to it.
            </summary>
            <remarks>
            The token object at the start index; the input stream might
            not be buffering tokens so get a reference to it. (At the
            time the error occurred, of course the stream needs to keep a
            buffer all of the tokens but later we might not have access to those.)
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Parser">
            <summary>This is all the parsing support code essentially; most of it is error recovery stuff.</summary>
            <remarks>This is all the parsing support code essentially; most of it is error recovery stuff.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Parser.bypassAltsAtnCache">
            <summary>
            This field maps from the serialized ATN string to the deserialized
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            with
            bypass alternatives.
            </summary>
            <seealso cref="P:Antlr4.Runtime.Atn.ATNDeserializationOptions.GenerateRuleBypassTransitions"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._errHandler">
            <summary>The error handling strategy for the parser.</summary>
            <remarks>
            The error handling strategy for the parser. The default value is a new
            instance of
            <see cref="T:Antlr4.Runtime.DefaultErrorStrategy"/>
            .
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.ErrorHandler"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._input">
            <summary>The input stream.</summary>
            <remarks>The input stream.</remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.InputStream"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._ctx">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            object for the currently executing rule.
            This is always non-null during the parsing process.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Parser._buildParseTrees">
            <summary>
            Specifies whether or not the parser should construct a parse tree during
            the parsing process.
            </summary>
            <remarks>
            Specifies whether or not the parser should construct a parse tree during
            the parsing process. The default value is
            <see langword="true"/>
            .
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._tracer">
            <summary>
            When
            <see cref="P:Antlr4.Runtime.Parser.Trace"/>
            <c>(true)</c>
            is called, a reference to the
            <see cref="T:Antlr4.Runtime.Parser.TraceListener"/>
            is stored here so it can be easily removed in a
            later call to
            <see cref="P:Antlr4.Runtime.Parser.Trace"/>
            <c>(false)</c>
            . The listener itself is
            implemented as a parser listener so this field is not directly used by
            other parser methods.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Parser._parseListeners">
            <summary>
            The list of
            <see cref="T:Antlr4.Runtime.Tree.IParseTreeListener"/>
            listeners registered to receive
            events during the parse.
            </summary>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._syntaxErrors">
            <summary>The number of syntax errors reported during parsing.</summary>
            <remarks>
            The number of syntax errors reported during parsing. This value is
            incremented each time
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            is called.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Reset">
            <summary>reset the parser's state</summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Match(System.Int32)">
            <summary>
            Match current input symbol against
            <paramref name="ttype"/>
            . If the symbol type
            matches,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)"/>
            and
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            are
            called to complete the match process.
            <p>If the symbol type does not match,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is called on the current error
            strategy to attempt recovery. If
            <see cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
            is
            <see langword="true"/>
            and the token index of the symbol returned by
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is -1, the symbol is added to
            the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            .</p>
            </summary>
            <param name="ttype">the token type to match</param>
            <returns>the matched symbol</returns>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the current input symbol did not match
            <paramref name="ttype"/>
            and the error strategy could not recover from the
            mismatched symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.MatchWildcard">
            <summary>Match current input symbol as a wildcard.</summary>
            <remarks>
            Match current input symbol as a wildcard. If the symbol type matches
            (i.e. has a value greater than 0),
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)"/>
            and
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            are called to complete the match process.
            <p>If the symbol type does not match,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is called on the current error
            strategy to attempt recovery. If
            <see cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
            is
            <see langword="true"/>
            and the token index of the symbol returned by
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is -1, the symbol is added to
            the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            .</p>
            </remarks>
            <returns>the matched symbol</returns>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the current input symbol did not match
            a wildcard and the error strategy could not recover from the mismatched
            symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="P:Antlr4.Runtime.Parser.BuildParseTree">
            <summary>
            Track the
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            objects during the parse and hook
            them up using the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
            list so that it
            forms a parse tree. The
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            returned from the start
            rule represents the root of the parse tree.
            <p>Note that if we are not building parse trees, rule contexts only point
            upwards. When a rule exits, it returns the context but that gets garbage
            collected if nobody holds a reference. It points upwards but nobody
            points at it.</p>
            <p>When we build parse trees, we are adding all of these contexts to
            <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
            list. Contexts are then not candidates
            for garbage collection.</p>
            </summary>
            <summary>
            Gets whether or not a complete parse tree will be constructed while
            parsing.
            </summary>
            <remarks>
            Gets whether or not a complete parse tree will be constructed while
            parsing. This property is
            <see langword="true"/>
            for a newly constructed parser.
            </remarks>
            <returns>

            <see langword="true"/>
            if a complete parse tree will be constructed while
            parsing, otherwise
            <see langword="false"/>
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Parser.TrimParseTree">
            <summary>Trim the internal lists of the parse tree during parsing to conserve memory.</summary>
            <remarks>
            Trim the internal lists of the parse tree during parsing to conserve memory.
            This property is set to
            <see langword="false"/>
            by default for a newly constructed parser.
            </remarks>
            <value>

            <see langword="true"/>
            to trim the capacity of the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
            list to its size after a rule is parsed.
            </value>
            <returns>

            <see langword="true"/>
            if the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
            list is trimmed
            using the default
            <see cref="T:Antlr4.Runtime.Parser.TrimToSizeListener"/>
            during the parse process.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">
            <summary>
            Registers
            <paramref name="listener"/>
            to receive events during the parsing process.
            <p>To support output-preserving grammar transformations (including but not
            limited to left-recursion removal, automated left-factoring, and
            optimized code generation), calls to listener methods during the parse
            may differ substantially from calls made by
            <see cref="F:Antlr4.Runtime.Tree.ParseTreeWalker.Default"/>
            used after the parse is complete. In
            particular, rule entry and exit events may occur in a different order
            during the parse than after the parser. In addition, calls to certain
            rule entry methods may be omitted.</p>
            <p>With the following specific exceptions, calls to listener events are
            <em>deterministic</em>, i.e. for identical input the calls to listener
            methods will be the same.</p>
            <ul>
            <li>Alterations to the grammar used to generate code may change the
            behavior of the listener calls.</li>
            <li>Alterations to the command line options passed to ANTLR 4 when
            generating the parser may change the behavior of the listener calls.</li>
            <li>Changing the version of the ANTLR Tool used to generate the parser
            may change the behavior of the listener calls.</li>
            </ul>
            </summary>
            <param name="listener">the listener to add</param>
            <exception cref="T:System.ArgumentNullException">
            if
            <c/>
            listener is
            <see langword="null"/>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Parser.RemoveParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">
            <summary>
            Remove
            <paramref name="listener"/>
            from the list of parse listeners.
            <p>If
            <paramref name="listener"/>
            is
            <see langword="null"/>
            or has not been added as a parse
            listener, this method does nothing.</p>
            </summary>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
            <param name="listener">the listener to remove</param>
        </member>
        <member name="M:Antlr4.Runtime.Parser.RemoveParseListeners">
            <summary>Remove all parse listeners.</summary>
            <remarks>Remove all parse listeners.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.TriggerEnterRuleEvent">
            <summary>Notify any parse listeners of an enter rule event.</summary>
            <remarks>Notify any parse listeners of an enter rule event.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.TriggerExitRuleEvent">
            <summary>Notify any parse listeners of an exit rule event.</summary>
            <remarks>Notify any parse listeners of an exit rule event.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="P:Antlr4.Runtime.Parser.NumberOfSyntaxErrors">
            <summary>Gets the number of syntax errors reported during parsing.</summary>
            <remarks>
            Gets the number of syntax errors reported during parsing. This value is
            incremented each time
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            is called.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetATNWithBypassAlts">
            <summary>
            The ATN with bypass alternatives is expensive to create so we create it
            lazily.
            </summary>
            <remarks>
            The ATN with bypass alternatives is expensive to create so we create it
            lazily.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            if the current parser does not
            implement the
            <see cref="P:Antlr4.Runtime.Recognizer`2.SerializedAtn"/>
            method.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Parser.CompileParseTreePattern(System.String,System.Int32)">
            <summary>The preferred method of getting a tree pattern.</summary>
            <remarks>
            The preferred method of getting a tree pattern. For example, here's a
            sample use:
            <pre>
            ParseTree t = parser.expr();
            ParseTreePattern p = parser.compileParseTreePattern("&lt;ID&gt;+0", MyParser.RULE_expr);
            ParseTreeMatch m = p.match(t);
            String id = m.get("ID");
            </pre>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.CompileParseTreePattern(System.String,System.Int32,Antlr4.Runtime.Lexer)">
            <summary>
            The same as
            <see cref="M:Antlr4.Runtime.Parser.CompileParseTreePattern(System.String,System.Int32)"/>
            but specify a
            <see cref="T:Antlr4.Runtime.Lexer"/>
            rather than trying to deduce it from this parser.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Parser.CurrentToken">
            <summary>
            Match needs to return the current input symbol, which gets put
            into the label for the associated token ref; e.g., x=ID.
            </summary>
            <remarks>
            Match needs to return the current input symbol, which gets put
            into the label for the associated token ref; e.g., x=ID.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Consume">
            <summary>
            Consume and return the
            <linkplain>
            #getCurrentToken
            current symbol
            </linkplain>
            .
            <p>E.g., given the following input with
            <c>A</c>
            being the current
            lookahead symbol, this function moves the cursor to
            <c>B</c>
            and returns
            <c>A</c>
            .</p>
            <pre>
            A B
            ^
            </pre>
            If the parser is not in error recovery mode, the consumed symbol is added
            to the parse tree using
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.IToken)"/>
            , and
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)"/>
            is called on any parse listeners.
            If the parser <em>is</em> in error recovery mode, the consumed symbol is
            added to the parse tree using
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            , and
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)"/>
            is called on any parse
            listeners.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.EnterRule(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>Always called by generated parsers upon entry to a rule.</summary>
            <remarks>
            Always called by generated parsers upon entry to a rule. Access field
            <see cref="F:Antlr4.Runtime.Parser._ctx"/>
            get the current context.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Precedence">
            <summary>Get the precedence level for the top-most precedence rule.</summary>
            <remarks>Get the precedence level for the top-most precedence rule.</remarks>
            <returns>
            The precedence level for the top-most precedence rule, or -1 if
            the parser context is not nested within a precedence rule.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Parser.PushNewRecursionContext(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>
            Like
            <see cref="M:Antlr4.Runtime.Parser.EnterRule(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)"/>
            but for recursive rules.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.IsExpectedToken(System.Int32)">
            <summary>
            Checks whether or not
            <paramref name="symbol"/>
            can follow the current state in the
            ATN. The behavior of this method is equivalent to the following, but is
            implemented such that the complete context-sensitive follow set does not
            need to be explicitly constructed.
            <pre>
            return getExpectedTokens().contains(symbol);
            </pre>
            </summary>
            <param name="symbol">the symbol type to check</param>
            <returns>

            <see langword="true"/>
            if
            <paramref name="symbol"/>
            can follow the current state in
            the ATN, otherwise
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetExpectedTokens">
            <summary>
            Computes the set of input symbols which could follow the current parser
            state and context, as given by
            <see cref="P:Antlr4.Runtime.Recognizer`2.State"/>
            and
            <see cref="P:Antlr4.Runtime.Parser.Context"/>
            ,
            respectively.
            </summary>
            <seealso cref="M:Antlr4.Runtime.Atn.ATN.GetExpectedTokens(System.Int32,Antlr4.Runtime.RuleContext)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetRuleIndex(System.String)">
            <summary>
            Get a rule's index (i.e.,
            <c>RULE_ruleName</c>
            field) or -1 if not found.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetRuleInvocationStack">
            <summary>
            Return List&lt;String&gt; of the rule names in your parser instance
            leading up to a call to the current rule.
            </summary>
            <remarks>
            Return List&lt;String&gt; of the rule names in your parser instance
            leading up to a call to the current rule.  You could override if
            you want more details such as the file/line info of where
            in the ATN a rule is invoked.
            This is very useful for error messages.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetDFAStrings">
            <summary>For debugging and other purposes.</summary>
            <remarks>For debugging and other purposes.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.DumpDFA">
            <summary>For debugging and other purposes.</summary>
            <remarks>For debugging and other purposes.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Profile">
            <since>4.3</since>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Trace">
            <summary>
            During a parse is sometimes useful to listen in on the rule entry and exit
            events as well as token matches.
            </summary>
            <remarks>
            During a parse is sometimes useful to listen in on the rule entry and exit
            events as well as token matches. This is for quick and dirty debugging.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.ParserInterpreter">
            <summary>
            A parser simulator that mimics what ANTLR's generated
            parser code does.
            </summary>
            <remarks>
            A parser simulator that mimics what ANTLR's generated
            parser code does. A ParserATNSimulator is used to make
            predictions via adaptivePredict but this class moves a pointer through the
            ATN to simulate parsing. ParserATNSimulator just
            makes us efficient rather than having to backtrack, for example.
            This properly creates parse trees even for left recursive rules.
            We rely on the left recursive rule invocation and special predicate
            transitions to make left recursive rules work.
            See TestParserInterpreter for examples.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserInterpreter.Parse(System.Int32)">
            <summary>Begin parsing at startRuleIndex</summary>
        </member>
        <member name="T:Antlr4.Runtime.ParserRuleContext">
            <summary>A rule invocation record for parsing.</summary>
            <remarks>
            A rule invocation record for parsing.
            Contains all of the information about the current rule not stored in the
            RuleContext. It handles parse tree children list, Any ATN state
            tracing, and the default values available for rule indications:
            start, stop, rule index, current alt number, current
            ATN state.
            Subclasses made for each rule and grammar track the parameters,
            return values, locals, and labels specific to that rule. These
            are the objects that are returned from rules.
            Note text is not an actual field of a rule return value; it is computed
            from start and stop using the input stream's toString() method.  I
            could add a ctor to this so that we can pass in and store the input
            stream, but I'm not sure we want to do that.  It would seem to be undefined
            to get the .text property anyway if the rule matches tokens from multiple
            input streams.
            I do not use getters for fields of objects that are used simply to
            group values such as this aggregate.  The getters/setters are there to
            satisfy the superclass interface.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.children">
            <summary>
            If we are debugging or building a parse tree for a visitor,
            we need to track all of the tokens and rule invocations associated
            with this rule's context.
            </summary>
            <remarks>
            If we are debugging or building a parse tree for a visitor,
            we need to track all of the tokens and rule invocations associated
            with this rule's context. This is empty for parsing w/o tree constr.
            operation because we don't the need to track the details about
            how we parse this rule.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext._start">
            <summary>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            </summary>
            <remarks>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            This list indicates the sequence of ATN nodes used to match
            the elements of the children list. This list does not include
            ATN nodes and other rules used to match rule invocations. It
            traces the rule invocation node itself but nothing inside that
            other rule's ATN submachine.
            There is NOT a one-to-one correspondence between the children and
            states list. There are typically many nodes in the ATN traversed
            for each element in the children list. For example, for a rule
            invocation there is the invoking state and the following state.
            The parser setState() method updates field s and adds it to this list
            if we are debugging/tracing.
            This does not trace states visited during prediction.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext._stop">
            <summary>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            </summary>
            <remarks>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            This list indicates the sequence of ATN nodes used to match
            the elements of the children list. This list does not include
            ATN nodes and other rules used to match rule invocations. It
            traces the rule invocation node itself but nothing inside that
            other rule's ATN submachine.
            There is NOT a one-to-one correspondence between the children and
            states list. There are typically many nodes in the ATN traversed
            for each element in the children list. For example, for a rule
            invocation there is the invoking state and the following state.
            The parser setState() method updates field s and adds it to this list
            if we are debugging/tracing.
            This does not trace states visited during prediction.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.exception">
            <summary>The exception that forced this rule to return.</summary>
            <remarks>
            The exception that forced this rule to return. If the rule successfully
            completed, this is
            <see langword="null"/>
            .
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.CopyFrom(Antlr4.Runtime.ParserRuleContext)">
            <summary>COPY a ctx (I'm deliberately not using copy constructor)</summary>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>Does not set parent link; other add methods do that</summary>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.RemoveLastChild">
            <summary>
            Used by enterOuterAlt to toss out a RuleContext previously added as
            we entered a rule.
            </summary>
            <remarks>
            Used by enterOuterAlt to toss out a RuleContext previously added as
            we entered a rule. If we have # label, we will need to remove
            generic ruleContext object.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.ToInfoString(Antlr4.Runtime.Parser)">
            <summary>Used for rule context info debugging during parse-time, not so much for ATN debugging</summary>
        </member>
        <member name="T:Antlr4.Runtime.ProxyErrorListener`1">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            dispatches all calls to a
            collection of delegate listeners. This reduces the effort required to support multiple
            listeners.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.ProxyParserErrorListener">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.RecognitionException">
            <summary>The root of the ANTLR exception hierarchy.</summary>
            <remarks>
            The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
            3 kinds of errors: prediction errors, failed predicate errors, and
            mismatched input errors. In each case, the parser knows where it is
            in the input, where it is in the ATN, the rule invocation stack,
            and what kind of problem occurred.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.RecognitionException.recognizer">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.IRecognizer"/>
            where this exception originated.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.RecognitionException.offendingToken">
            <summary>
            The current
            <see cref="T:Antlr4.Runtime.IToken"/>
            when an error occurred. Since not all streams
            support accessing symbols by index, we have to track the
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance itself.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.OffendingState">
            <summary>
            Get the ATN state number the parser was in at the time the error
            occurred.
            </summary>
            <remarks>
            Get the ATN state number the parser was in at the time the error
            occurred. For
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            and
            <see cref="T:Antlr4.Runtime.LexerNoViableAltException"/>
            exceptions, this is the
            <see cref="T:Antlr4.Runtime.Atn.DecisionState"/>
            number. For others, it is the state whose outgoing
            edge we couldn't match.
            <p>If the state number is not known, this method returns -1.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RecognitionException.GetExpectedTokens">
            <summary>
            Gets the set of input symbols which could potentially follow the
            previously matched symbol at the time this exception was thrown.
            </summary>
            <remarks>
            Gets the set of input symbols which could potentially follow the
            previously matched symbol at the time this exception was thrown.
            <p>If the set of expected tokens is not known and could not be computed,
            this method returns
            <see langword="null"/>
            .</p>
            </remarks>
            <returns>
            The set of token types that could potentially follow the current
            state in the ATN, or
            <see langword="null"/>
            if the information is not available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.Context">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            at the time this exception was thrown.
            <p>If the context is not available, this method returns
            <see langword="null"/>
            .</p>
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            at the time this exception was thrown.
            If the context is not available, this method returns
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.InputStream">
            <summary>
            Gets the input stream which is the symbol source for the recognizer where
            this exception was thrown.
            </summary>
            <remarks>
            Gets the input stream which is the symbol source for the recognizer where
            this exception was thrown.
            <p>If the input stream is not available, this method returns
            <see langword="null"/>
            .</p>
            </remarks>
            <returns>
            The input stream which is the symbol source for the recognizer
            where this exception was thrown, or
            <see langword="null"/>
            if the stream is not
            available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.Recognizer">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.IRecognizer"/>
            where this exception occurred.
            <p>If the recognizer is not available, this method returns
            <see langword="null"/>
            .</p>
            </summary>
            <returns>
            The recognizer where this exception occurred, or
            <see langword="null"/>
            if
            the recognizer is not available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.RuleNames">
            <summary>
            Used to print out token names like ID during debugging and
            error reporting.
            </summary>
            <remarks>
            Used to print out token names like ID during debugging and
            error reporting.  The generated parsers implement a method
            that overrides this to point to their String[] tokenNames.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.Vocabulary">
            <summary>Get the vocabulary used by the recognizer.</summary>
            <remarks>Get the vocabulary used by the recognizer.</remarks>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.IVocabulary"/>
            instance providing information about the
            vocabulary used by the grammar.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.TokenTypeMap">
            <summary>Get a map from token names to token types.</summary>
            <remarks>
            Get a map from token names to token types.
            <p>Used for XPath and tree pattern compilation.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.RuleIndexMap">
            <summary>Get a map from rule names to rule indexes.</summary>
            <remarks>
            Get a map from rule names to rule indexes.
            <p>Used for XPath and tree pattern compilation.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.SerializedAtn">
            <summary>
            If this recognizer was generated, it will have a serialized ATN
            representation of the grammar.
            </summary>
            <remarks>
            If this recognizer was generated, it will have a serialized ATN
            representation of the grammar.
            <p>For interpreters, we don't know their serialized ATN despite having
            created the interpreter from it.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.GrammarFileName">
            <summary>For debugging and other purposes, might want the grammar name.</summary>
            <remarks>
            For debugging and other purposes, might want the grammar name.
            Have ANTLR generate an implementation for this method.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.Atn">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            used by the recognizer for prediction.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            used by the recognizer for prediction.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.Interpreter">
            <summary>Get the ATN interpreter used by the recognizer for prediction.</summary>
            <remarks>Get the ATN interpreter used by the recognizer for prediction.</remarks>
            <returns>The ATN interpreter used by the recognizer for prediction.</returns>
            <summary>Set the ATN interpreter used by the recognizer for prediction.</summary>
            <remarks>Set the ATN interpreter used by the recognizer for prediction.</remarks>
            <value>
            The ATN interpreter used by the recognizer for
            prediction.
            </value>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.ParseInfo">
            <summary>
            If profiling during the parse/lex, this will return DecisionInfo records
            for each decision in recognizer in a ParseInfo object.
            </summary>
            <remarks>
            If profiling during the parse/lex, this will return DecisionInfo records
            for each decision in recognizer in a ParseInfo object.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.GetErrorHeader(Antlr4.Runtime.RecognitionException)">
            <summary>What is the error header, normally line/character position information?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.GetTokenErrorDisplay(Antlr4.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.
            </summary>
            <remarks>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.toString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.AddErrorListener(Antlr4.Runtime.IAntlrErrorListener{`0})">
            <exception>
            NullPointerException
            if
            <paramref name="listener"/>
            is
            <see langword="null"/>
            .
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.State">
            <summary>
            Indicate that the recognizer has changed internal state that is
            consistent with the ATN state passed in.
            </summary>
            <remarks>
            Indicate that the recognizer has changed internal state that is
            consistent with the ATN state passed in.  This way we always know
            where we are in the ATN as the parser goes along. The rule
            context objects form a stack that lets us see the stack of
            invoking rules. Combine this and we have complete ATN
            configuration information.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.RuleContext">
            <summary>A rule context is a record of a single rule invocation.</summary>
            <remarks>
            A rule context is a record of a single rule invocation. It knows
            which context invoked it, if any. If there is no parent context, then
            naturally the invoking state is not valid.  The parent link
            provides a chain upwards from the current rule invocation to the root
            of the invocation tree, forming a stack. We actually carry no
            information about the rule associated with this context (except
            when parsing). We keep only the state number of the invoking state from
            the ATN submachine that invoked this. Contrast this with the s
            pointer inside ParserRuleContext that tracks the current state
            being "executed" for the current rule.
            The parent contexts are useful for computing lookahead sets and
            getting error information.
            These objects are used during parsing and prediction.
            For the special case of parsers, we use the subclass
            ParserRuleContext.
            </remarks>
            <seealso cref="T:Antlr4.Runtime.ParserRuleContext"/>
        </member>
        <member name="F:Antlr4.Runtime.RuleContext._parent">
            <summary>What context invoked this rule?</summary>
        </member>
        <member name="F:Antlr4.Runtime.RuleContext.invokingState">
            <summary>
            What state invoked the rule associated with this context?
            The "return address" is the followState of invokingState
            If parent is null, this should be -1.
            </summary>
            <remarks>
            What state invoked the rule associated with this context?
            The "return address" is the followState of invokingState
            If parent is null, this should be -1.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.RuleContext.IsEmpty">
            <summary>
            A context is empty if there is no invoking state; meaning nobody call
            current context.
            </summary>
            <remarks>
            A context is empty if there is no invoking state; meaning nobody call
            current context.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.GetText">
            <summary>Return the combined text of all child nodes.</summary>
            <remarks>
            Return the combined text of all child nodes. This method only considers
            tokens which have been added to the parse tree.
            <p/>
            Since tokens on hidden channels (e.g. whitespace or comments) are not
            added to the parse trees, they will not appear in the output of this
            method.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.ToStringTree(Antlr4.Runtime.Parser)">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            (root child1 ..
            </summary>
            <remarks>
            Print out a whole tree, not just a node, in LISP format
            (root child1 .. childN). Print just a node if this is a leaf.
            We have to know the recognizer so we can get rule names.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.ToStringTree(System.Collections.Generic.IList{System.String})">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            (root child1 ..
            </summary>
            <remarks>
            Print out a whole tree, not just a node, in LISP format
            (root child1 .. childN). Print just a node if this is a leaf.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.TokenStreamRewriter">
            <summary>
            Useful for rewriting out a buffered input token stream after doing some
            augmentation or other manipulations on it.
            </summary>
            <remarks>
            Useful for rewriting out a buffered input token stream after doing some
            augmentation or other manipulations on it.
            <p>
            You can insert stuff, replace, and delete chunks. Note that the operations
            are done lazily--only if you convert the buffer to a
            <see cref="T:System.String"/>
            with
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText"/>
            . This is very efficient because you are not
            moving data around all the time. As the buffer of tokens is converted to
            strings, the
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            method(s) scan the input token stream and
            check to see if there is an operation at the current index. If so, the
            operation is done and then normal
            <see cref="T:System.String"/>
            rendering continues on the
            buffer. This is like having multiple Turing machine instruction streams
            (programs) operating on a single input tape. :)</p>
            <p>
            This rewriter makes no modifications to the token stream. It does not ask the
            stream to fill itself up nor does it advance the input cursor. The token
            stream
            <see cref="P:Antlr4.Runtime.IIntStream.Index"/>
            will return the same value before and
            after any
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            call.</p>
            <p>
            The rewriter only works on tokens that you have in the buffer and ignores the
            current input cursor. If you are buffering tokens on-demand, calling
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            halfway through the input will only do rewrites for those
            tokens in the first half of the file.</p>
            <p>
            Since the operations are done lazily at
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            -time, operations do
            not screw up the token index values. That is, an insert operation at token
            index
            <c>i</c>
            does not change the index values for tokens
            <c>i</c>
            +1..n-1.</p>
            <p>
            Because operations never actually alter the buffer, you may always get the
            original token stream back without undoing anything. Since the instructions
            are queued up, you can easily simulate transactions and roll back any changes
            if there is an error just by removing instructions. For example,</p>
            <pre>
            CharStream input = new ANTLRFileStream("input");
            TLexer lex = new TLexer(input);
            CommonTokenStream tokens = new CommonTokenStream(lex);
            T parser = new T(tokens);
            TokenStreamRewriter rewriter = new TokenStreamRewriter(tokens);
            parser.startRule();
            </pre>
            <p>
            Then in the rules, you can execute (assuming rewriter is visible):</p>
            <pre>
            Token t,u;
            ...
            rewriter.insertAfter(t, "text to put after t");}
            rewriter.insertAfter(u, "text after u");}
            System.out.println(tokens.toString());
            </pre>
            <p>
            You can also have multiple "instruction streams" and get multiple rewrites
            from a single pass over the input. Just name the instruction streams and use
            that name again when printing the buffer. This could be useful for generating
            a C file and also its header file--all from the same buffer:</p>
            <pre>
            tokens.insertAfter("pass1", t, "text to put after t");}
            tokens.insertAfter("pass2", u, "text after u");}
            System.out.println(tokens.toString("pass1"));
            System.out.println(tokens.toString("pass2"));
            </pre>
            <p>
            If you don't use named rewrite streams, a "default" stream is used as the
            first example shows.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.instructionIndex">
            <summary>What index into rewrites List are we?</summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.index">
            <summary>Token buffer index.</summary>
            <remarks>Token buffer index.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.Execute(System.Text.StringBuilder)">
            <summary>Execute the rewrite operation by possibly adding to the buffer.</summary>
            <remarks>
            Execute the rewrite operation by possibly adding to the buffer.
            Return the index of the next token to operate on.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.TokenStreamRewriter.ReplaceOp">
            <summary>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </summary>
            <remarks>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.tokens">
            <summary>Our source stream</summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.programs">
            <summary>You may have multiple, named streams of rewrite operations.</summary>
            <remarks>
            You may have multiple, named streams of rewrite operations.
            I'm calling these things "programs."
            Maps String (name) &#x2192; rewrite (List)
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.lastRewriteTokenIndexes">
            <summary>Map String (program name) &#x2192; Integer index</summary>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.Rollback(System.String,System.Int32)">
            <summary>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream.
            </summary>
            <remarks>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream. UNTESTED!
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.DeleteProgram(System.String)">
            <summary>Reset the program so that no instructions exist</summary>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetText">
            <summary>
            Return the text from the original tokens altered per the
            instructions given to this rewriter.
            </summary>
            <remarks>
            Return the text from the original tokens altered per the
            instructions given to this rewriter.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the text associated with the tokens in the interval from the
            original token stream but with the alterations given to this rewriter.
            </summary>
            <remarks>
            Return the text associated with the tokens in the interval from the
            original token stream but with the alterations given to this rewriter.
            The interval refers to the indexes in the original token stream.
            We do not alter the token stream in any way, so the indexes
            and intervals are still consistent. Includes any operations done
            to the first and last token in the interval. So, if you did an
            insertBefore on the first token, you would get that insertion.
            The same is true if you do an insertAfter the stop token.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.ReduceToSingleOperationPerIndex(System.Collections.Generic.IList{Antlr4.Runtime.TokenStreamRewriter.RewriteOperation})">
            <summary>
            We need to combine operations and report invalid operations (like
            overlapping replaces that are not completed nested).
            </summary>
            <remarks>
            We need to combine operations and report invalid operations (like
            overlapping replaces that are not completed nested). Inserts to
            same index need to be combined etc...  Here are the cases:
            I.i.u I.j.v								leave alone, nonoverlapping
            I.i.u I.i.v								combine: Iivu
            R.i-j.u R.x-y.v	| i-j in x-y			delete first R
            R.i-j.u R.i-j.v							delete first R
            R.i-j.u R.x-y.v	| x-y in i-j			ERROR
            R.i-j.u R.x-y.v	| boundaries overlap	ERROR
            Delete special case of replace (text==null):
            D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
            I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
            we're not deleting i)
            I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
            R.x-y.v I.i.u | i in x-y				ERROR
            R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
            R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
            I.i.u = insert u before op @ index i
            R.x-y.u = replace x-y indexed tokens with u
            First we need to examine replaces. For any replace op:
            1. wipe out any insertions before op within that range.
            2. Drop any replace op before that is contained completely within
            that range.
            3. Throw exception upon boundary overlap with any previous replace.
            Then we can deal with inserts:
            1. for any inserts to same index, combine even if not adjacent.
            2. for any prior replace with same left boundary, combine this
            insert with replace and delete this replace.
            3. throw exception if index in same range as previous replace
            Don't actually delete; make op null in list. Easier to walk list.
            Later we can throw as we add to index &#x2192; op map.
            Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
            inserted stuff would be before the replace range. But, if you
            add tokens in front of a method body '{' and then delete the method
            body, I think the stuff before the '{' you added should disappear too.
            Return a map from token index to operation.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetKindOfOps``1(System.Collections.Generic.IList{Antlr4.Runtime.TokenStreamRewriter.RewriteOperation},System.Int32)">
            <summary>Get all operations before an index of a particular kind</summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.Visit(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            <inheritDoc/>
            <p>The default implementation calls
            <see cref="M:Antlr4.Runtime.Tree.IParseTree.Accept``1(Antlr4.Runtime.Tree.IParseTreeVisitor{``0})"/>
            on the
            specified tree.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            <inheritDoc/>
            <p>The default implementation initializes the aggregate result to
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult()</see>
            . Before visiting each child, it
            calls
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)">shouldVisitNextChild</see>
            ; if the result
            is
            <see langword="false"/>
            no more children are visited and the current aggregate
            result is returned. After visiting a child, the aggregate result is
            updated by calling
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.AggregateResult(`0,`0)">aggregateResult</see>
            with the
            previous aggregate result and the result of visiting the child.</p>
            <p>The default implementation is not safe for use in visitors that modify
            the tree structure. Visitors that modify the tree should override this
            method to behave properly in respect to the specific algorithm in use.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>
            <inheritDoc/>
            <p>The default implementation returns the result of
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult</see>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <summary>
            <inheritDoc/>
            <p>The default implementation returns the result of
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult</see>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">
            <summary>Gets the default value returned by visitor methods.</summary>
            <remarks>
            Gets the default value returned by visitor methods. This value is
            returned by the default implementations of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">visitTerminal</see>
            ,
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">visitErrorNode</see>
            .
            The default implementation of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">visitChildren</see>
            initializes its aggregate result to this value.
            <p>The base implementation returns
            <see langword="null"/>
            .</p>
            </remarks>
            <returns>The default value returned by visitor methods.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.AggregateResult(`0,`0)">
            <summary>Aggregates the results of visiting multiple children of a node.</summary>
            <remarks>
            Aggregates the results of visiting multiple children of a node. After
            either all children are visited or
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)"/>
            returns
            <see langword="false"/>
            , the aggregate value is returned as the result of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            .
            <p>The default implementation returns
            <paramref name="nextResult"/>
            , meaning
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            will return the result of the last child visited
            (or return the initial value if the node has no children).</p>
            </remarks>
            <param name="aggregate">
            The previous aggregate value. In the default
            implementation, the aggregate value is initialized to
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult"/>
            , which is passed as the
            <paramref name="aggregate"/>
            argument
            to this method after the first child node is visited.
            </param>
            <param name="nextResult">
            The result of the immediately preceeding call to visit
            a child node.
            </param>
            <returns>The updated aggregate result.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)">
            <summary>
            This method is called after visiting each child in
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            . This method is first called before the first
            child is visited; at that point
            <paramref name="currentResult"/>
            will be the initial
            value (in the default implementation, the initial value is returned by a
            call to
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult"/>
            . This method is not called after the last
            child is visited.
            <p>The default implementation always returns
            <see langword="true"/>
            , indicating that
            <c>visitChildren</c>
            should only return after all children are visited.
            One reason to override this method is to provide a "short circuit"
            evaluation option for situations where the result of visiting a single
            child has the potential to determine the result of the visit operation as
            a whole.</p>
            </summary>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IRuleNode"/>
            whose children are currently being
            visited.
            </param>
            <param name="currentResult">
            The current aggregate result of the children visited
            to the current point.
            </param>
            <returns>

            <see langword="true"/>
            to continue visiting children. Otherwise return
            <see langword="false"/>
            to stop visiting children and immediately return the
            current aggregate result from
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ErrorNodeImpl">
            <summary>
            Represents a token that was consumed during resynchronization
            rather than during a valid match operation.
            </summary>
            <remarks>
            Represents a token that was consumed during resynchronization
            rather than during a valid match operation. For example,
            we will create this kind of a node during single token insertion
            and deletion as well as during "consume until error recovery set"
            upon no viable alternative exceptions.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.IParseTree">
            <summary>
            An interface to access the tree of
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            objects created
            during a parse that makes the data structure look like a simple parse tree.
            This node represents both internal nodes, rule invocations,
            and leaf nodes, token matches.
            <p>The payload is either a
            <see cref="T:Antlr4.Runtime.IToken"/>
            or a
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            object.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.Accept``1(Antlr4.Runtime.Tree.IParseTreeVisitor{``0})">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTreeVisitor`1"/>
            needs a double dispatch method.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.GetText">
            <summary>Return the combined text of all leaf nodes.</summary>
            <remarks>
            Return the combined text of all leaf nodes. Does not get any
            off-channel tokens (if any) so won't return whitespace and
            comments if they are sent to parser on hidden channel.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.ToStringTree(Antlr4.Runtime.Parser)">
            <summary>
            Specialize toStringTree so that it can print out more information
            based upon the parser.
            </summary>
            <remarks>
            Specialize toStringTree so that it can print out more information
            based upon the parser.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.IParseTreeVisitor`1">
            <summary>This interface defines the basic notion of a parse tree visitor.</summary>
            <remarks>
            This interface defines the basic notion of a parse tree visitor. Generated
            visitors implement this interface and the
            <c>XVisitor</c>
            interface for
            grammar
            <c>X</c>
            .
            </remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.Visit(Antlr4.Runtime.Tree.IParseTree)">
            <summary>Visit a parse tree, and return a user-defined result of the operation.</summary>
            <remarks>Visit a parse tree, and return a user-defined result of the operation.</remarks>
            <param name="tree">
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            to visit.
            </param>
            <returns>The result of visiting the parse tree.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            Visit the children of a node, and return a user-defined result
            of the operation.
            </summary>
            <remarks>
            Visit the children of a node, and return a user-defined result
            of the operation.
            </remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IRuleNode"/>
            whose children should be visited.
            </param>
            <returns>The result of visiting the children of the node.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>Visit a terminal node, and return a user-defined result of the operation.</summary>
            <remarks>Visit a terminal node, and return a user-defined result of the operation.</remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.ITerminalNode"/>
            to visit.
            </param>
            <returns>The result of visiting the node.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <summary>Visit an error node, and return a user-defined result of the operation.</summary>
            <remarks>Visit an error node, and return a user-defined result of the operation.</remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IErrorNode"/>
            to visit.
            </param>
            <returns>The result of visiting the node.</returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ISyntaxTree">
            <summary>
            A tree that knows about an interval in a token stream
            is some kind of syntax tree.
            </summary>
            <remarks>
            A tree that knows about an interval in a token stream
            is some kind of syntax tree. Subinterfaces distinguish
            between parse trees and other kinds of syntax trees we might want to create.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ISyntaxTree.SourceInterval">
            <summary>
            Return an
            <see cref="T:Antlr4.Runtime.Misc.Interval"/>
            indicating the index in the
            <see cref="T:Antlr4.Runtime.ITokenStream"/>
            of the first and last token associated with this
            subtree. If this node is a leaf, then the interval represents a single
            token.
            <p>If source interval is unknown, this returns
            <see cref="F:Antlr4.Runtime.Misc.Interval.Invalid"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ITree">
            <summary>The basic notion of a tree has a parent, a payload, and a list of children.</summary>
            <remarks>
            The basic notion of a tree has a parent, a payload, and a list of children.
            It is the most abstract interface for all the trees used by ANTLR.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.Parent">
            <summary>The parent of this node.</summary>
            <remarks>
            The parent of this node. If the return value is null, then this
            node is the root of the tree.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.Payload">
            <summary>This method returns whatever object represents the data at this note.</summary>
            <remarks>
            This method returns whatever object represents the data at this note. For
            example, for parse trees, the payload can be a
            <see cref="T:Antlr4.Runtime.IToken"/>
            representing
            a leaf node or a
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            object representing a rule
            invocation. For abstract syntax trees (ASTs), this is a
            <see cref="T:Antlr4.Runtime.IToken"/>
            object.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ITree.GetChild(System.Int32)">
            <summary>
            If there are children, get the
            <paramref name="i"/>
            th value indexed from 0.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.ChildCount">
            <summary>
            How many children are there? If there is none, then this
            node represents a leaf node.
            </summary>
            <remarks>
            How many children are there? If there is none, then this
            node represents a leaf node.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ITree.ToStringTree">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            <c>(root child1 .. childN)</c>
            . Print just a node if this is a leaf.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ParseTreeProperty`1">
            <summary>Associate a property with a parse tree node.</summary>
            <remarks>
            Associate a property with a parse tree node. Useful with parse tree listeners
            that need to associate values with particular tree nodes, kind of like
            specifying a return value for the listener event method that visited a
            particular node. Example:
            <pre>
            ParseTreeProperty&lt;Integer&gt; values = new ParseTreeProperty&lt;Integer&gt;();
            values.put(tree, 36);
            int x = values.get(tree);
            values.removeFrom(tree);
            </pre>
            You would make one decl (values here) in the listener and use lots of times
            in your event methods.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ParseTreeWalker.EnterRule(Antlr4.Runtime.Tree.IParseTreeListener,Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            The discovery of a rule node, involves sending two events: the generic
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)"/>
            and a
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            -specific event. First we trigger the generic and then
            the rule specific. We to them in reverse order upon finishing the node.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.Chunk">
            <summary>
            A chunk is either a token tag, a rule tag, or a span of literal text within a
            tree pattern.
            </summary>
            <remarks>
            A chunk is either a token tag, a rule tag, or a span of literal text within a
            tree pattern.
            <p>The method
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Split(System.String)"/>
            returns a list of
            chunks in preparation for creating a token stream by
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Tokenize(System.String)"/>
            . From there, we get a parse
            tree from with
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Compile(System.String,System.Int32)"/>
            . These
            chunks are converted to
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            ,
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            , or the
            regular tokens of the text surrounding the tags.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch">
            <summary>
            Represents the result of matching a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            against a tree pattern.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.tree">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Tree"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.pattern">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Pattern"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.labels">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Labels"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.mismatchedNode">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.MismatchedNode"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.#ctor(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern,Antlr4.Runtime.Misc.MultiMap{System.String,Antlr4.Runtime.Tree.IParseTree},Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            from the specified
            parse tree and pattern.
            </summary>
            <param name="tree">The parse tree to match against the pattern.</param>
            <param name="pattern">The parse tree pattern.</param>
            <param name="labels">
            A mapping from label names to collections of
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            objects located by the tree pattern matching process.
            </param>
            <param name="mismatchedNode">
            The first node which failed to match the tree
            pattern during the matching process.
            </param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="tree"/>
            is
            <see langword="null"/>
            </exception>
            <exception>
            IllegalArgumentException
            if
            <paramref name="pattern"/>
            is
            <see langword="null"/>
            </exception>
            <exception>
            IllegalArgumentException
            if
            <paramref name="labels"/>
            is
            <see langword="null"/>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Get(System.String)">
            <summary>
            Get the last node associated with a specific
            <paramref name="label"/>
            .
            <p>For example, for pattern
            <c>&lt;id:ID&gt;</c>
            ,
            <c>get("id")</c>
            returns the
            node matched for that
            <c>ID</c>
            . If more than one node
            matched the specified label, only the last is returned. If there is
            no node associated with the label, this returns
            <see langword="null"/>
            .</p>
            <p>Pattern tags like
            <c>&lt;ID&gt;</c>
            and
            <c>&lt;expr&gt;</c>
            without labels are
            considered to be labeled with
            <c>ID</c>
            and
            <c>expr</c>
            , respectively.</p>
            </summary>
            <param name="label">The label to check.</param>
            <returns>
            The last
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            to match a tag with the specified
            label, or
            <see langword="null"/>
            if no parse tree matched a tag with the label.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.GetAll(System.String)">
            <summary>Return all nodes matching a rule or token tag with the specified label.</summary>
            <remarks>
            Return all nodes matching a rule or token tag with the specified label.
            <p>If the
            <paramref name="label"/>
            is the name of a parser rule or token in the
            grammar, the resulting list will contain both the parse trees matching
            rule or tags explicitly labeled with the label and the complete set of
            parse trees matching the labeled and unlabeled tags in the pattern for
            the parser rule or token. For example, if
            <paramref name="label"/>
            is
            <c>"foo"</c>
            ,
            the result will contain <em>all</em> of the following.</p>
            <ul>
            <li>Parse tree nodes matching tags of the form
            <c>&lt;foo:anyRuleName&gt;</c>
            and
            <c>&lt;foo:AnyTokenName&gt;</c>
            .</li>
            <li>Parse tree nodes matching tags of the form
            <c>&lt;anyLabel:foo&gt;</c>
            .</li>
            <li>Parse tree nodes matching tags of the form
            <c>&lt;foo&gt;</c>
            .</li>
            </ul>
            </remarks>
            <param name="label">The label.</param>
            <returns>
            A collection of all
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            nodes matching tags with
            the specified
            <paramref name="label"/>
            . If no nodes matched the label, an empty list
            is returned.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Labels">
            <summary>Return a mapping from label &#x2192; [list of nodes].</summary>
            <remarks>
            Return a mapping from label &#x2192; [list of nodes].
            <p>The map includes special entries corresponding to the names of rules and
            tokens referenced in tags in the original pattern. For additional
            information, see the description of
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.GetAll(System.String)"/>
            .</p>
            </remarks>
            <returns>
            A mapping from labels to parse tree nodes. If the parse tree
            pattern did not contain any rule or token tags, this map will be empty.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.MismatchedNode">
            <summary>Get the node at which we first detected a mismatch.</summary>
            <remarks>Get the node at which we first detected a mismatch.</remarks>
            <returns>
            the node at which we first detected a mismatch, or
            <see langword="null"/>
            if the match was successful.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Succeeded">
            <summary>Gets a value indicating whether the match operation succeeded.</summary>
            <remarks>Gets a value indicating whether the match operation succeeded.</remarks>
            <returns>

            <see langword="true"/>
            if the match operation succeeded; otherwise,
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Pattern">
            <summary>Get the tree pattern we are matching against.</summary>
            <remarks>Get the tree pattern we are matching against.</remarks>
            <returns>The tree pattern we are matching against.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Tree">
            <summary>Get the parse tree we are trying to match to a pattern.</summary>
            <remarks>Get the parse tree we are trying to match to a pattern.</remarks>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            we are trying to match to a pattern.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.ToString">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern">
            <summary>
            A pattern like
            <c>&lt;ID&gt; = &lt;expr&gt;;</c>
            converted to a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            by
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Compile(System.String,System.Int32)"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.patternRuleIndex">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternRuleIndex"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.pattern">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Pattern"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.patternTree">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternTree"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.matcher">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Matcher"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.#ctor(Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher,System.String,System.Int32,Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Construct a new instance of the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            class.
            </summary>
            <param name="matcher">
            The
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            which created this
            tree pattern.
            </param>
            <param name="pattern">The tree pattern in concrete syntax form.</param>
            <param name="patternRuleIndex">
            The parser rule which serves as the root of the
            tree pattern.
            </param>
            <param name="patternTree">
            The tree pattern in
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            form.
            </param>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Match(Antlr4.Runtime.Tree.IParseTree)">
            <summary>Match a specific parse tree against this tree pattern.</summary>
            <remarks>Match a specific parse tree against this tree pattern.</remarks>
            <param name="tree">The parse tree to match against this tree pattern.</param>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object describing the result of the
            match operation. The
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Succeeded"/>
            method can be
            used to determine whether or not the match was successful.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Matches(Antlr4.Runtime.Tree.IParseTree)">
            <summary>Determine whether or not a parse tree matches this tree pattern.</summary>
            <remarks>Determine whether or not a parse tree matches this tree pattern.</remarks>
            <param name="tree">The parse tree to match against this tree pattern.</param>
            <returns>

            <see langword="true"/>
            if
            <paramref name="tree"/>
            is a match for the current tree
            pattern; otherwise,
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.FindAll(Antlr4.Runtime.Tree.IParseTree,System.String)">
            <summary>
            Find all nodes using XPath and then try to match those subtrees against
            this tree pattern.
            </summary>
            <remarks>
            Find all nodes using XPath and then try to match those subtrees against
            this tree pattern.
            </remarks>
            <param name="tree">
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            to match against this pattern.
            </param>
            <param name="xpath">An expression matching the nodes</param>
            <returns>
            A collection of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            objects describing the
            successful matches. Unsuccessful matches are omitted from the result,
            regardless of the reason for the failure.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Matcher">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            which created this tree pattern.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            which created this tree
            pattern.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Pattern">
            <summary>Get the tree pattern in concrete syntax form.</summary>
            <remarks>Get the tree pattern in concrete syntax form.</remarks>
            <returns>The tree pattern in concrete syntax form.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternRuleIndex">
            <summary>
            Get the parser rule which serves as the outermost rule for the tree
            pattern.
            </summary>
            <remarks>
            Get the parser rule which serves as the outermost rule for the tree
            pattern.
            </remarks>
            <returns>
            The parser rule which serves as the outermost rule for the tree
            pattern.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternTree">
            <summary>
            Get the tree pattern as a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            . The rule and token tags from
            the pattern are present in the parse tree as terminal nodes with a symbol
            of type
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            or
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            .
            </summary>
            <returns>
            The tree pattern as a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher">
            <summary>
            A tree pattern matching mechanism for ANTLR
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            s.
            <p>Patterns are strings of source input text with special tags representing
            token or rule references such as:</p>
            <p>
            <c>&lt;ID&gt; = &lt;expr&gt;;</c>
            </p>
            <p>Given a pattern start rule such as
            <c>statement</c>
            , this object constructs
            a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            with placeholders for the
            <c>ID</c>
            and
            <c>expr</c>
            subtree. Then the
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)"/>
            routines can compare an actual
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            from a parse with this pattern. Tag
            <c>&lt;ID&gt;</c>
            matches
            any
            <c>ID</c>
            token and tag
            <c>&lt;expr&gt;</c>
            references the result of the
            <c>expr</c>
            rule (generally an instance of
            <c>ExprContext</c>
            .</p>
            <p>Pattern
            <c>x = 0;</c>
            is a similar pattern that matches the same pattern
            except that it requires the identifier to be
            <c>x</c>
            and the expression to
            be
            <c>0</c>
            .</p>
            <p>The
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Matches(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)"/>
            routines return
            <see langword="true"/>
            or
            <see langword="false"/>
            based
            upon a match for the tree rooted at the parameter sent in. The
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)"/>
            routines return a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object that
            contains the parse tree, the parse tree pattern, and a map from tag name to
            matched nodes (more below). A subtree that fails to match, returns with
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.MismatchedNode"/>
            set to the first tree node that did not
            match.</p>
            <p>For efficiency, you can compile a tree pattern in string form to a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            object.</p>
            <p>See
            <c>TestParseTreeMatcher</c>
            for lots of examples.
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            has two static helper methods:
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.FindAll(Antlr4.Runtime.Tree.IParseTree,System.String)"/>
            and
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Match(Antlr4.Runtime.Tree.IParseTree)"/>
            that
            are easy to use but not super efficient because they create new
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            objects each time and have to compile the
            pattern in string form before using it.</p>
            <p>The lexer and parser that you pass into the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            constructor are used to parse the pattern in string form. The lexer converts
            the
            <c>&lt;ID&gt; = &lt;expr&gt;;</c>
            into a sequence of four tokens (assuming lexer
            throws out whitespace or puts it on a hidden channel). Be aware that the
            input stream is reset for the lexer (but not the parser; a
            <see cref="T:Antlr4.Runtime.ParserInterpreter"/>
            is created to parse the input.). Any user-defined
            fields you have put into the lexer might get changed when this mechanism asks
            it to scan the pattern string.</p>
            <p>Normally a parser does not accept token
            <c>&lt;expr&gt;</c>
            as a valid
            <c>expr</c>
            but, from the parser passed in, we create a special version of
            the underlying grammar representation (an
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            ) that allows imaginary
            tokens representing rules (
            <c>&lt;expr&gt;</c>
            ) to match entire rules. We call
            these <em>bypass alternatives</em>.</p>
            <p>Delimiters are
            <c>&lt;</c>
            and
            <c>&gt;</c>
            , with
            <c>\</c>
            as the escape string
            by default, but you can set them to whatever you want using
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.SetDelimiters(System.String,System.String,System.String)"/>
            . You must escape both start and stop strings
            <c>\&lt;</c>
            and
            <c>\&gt;</c>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.lexer">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Lexer"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.parser">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Parser"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.#ctor(Antlr4.Runtime.Lexer,Antlr4.Runtime.Parser)">
            <summary>
            Constructs a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            or from a
            <see cref="T:Antlr4.Runtime.Lexer"/>
            and
            <see cref="T:Antlr4.Runtime.Parser"/>
            object. The lexer input stream is altered for tokenizing
            the tree patterns. The parser is used as a convenient mechanism to get
            the grammar name, plus token, rule names.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.SetDelimiters(System.String,System.String,System.String)">
            <summary>
            Set the delimiters used for marking rule and token tags within concrete
            syntax used by the tree pattern parser.
            </summary>
            <remarks>
            Set the delimiters used for marking rule and token tags within concrete
            syntax used by the tree pattern parser.
            </remarks>
            <param name="start">The start delimiter.</param>
            <param name="stop">The stop delimiter.</param>
            <param name="escapeLeft">The escape sequence to use for escaping a start or stop delimiter.</param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="start"/>
            is
            <see langword="null"/>
            or empty.
            </exception>
            <exception>
            IllegalArgumentException
            if
            <paramref name="stop"/>
            is
            <see langword="null"/>
            or empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Matches(Antlr4.Runtime.Tree.IParseTree,System.String,System.Int32)">
            <summary>
            Does
            <paramref name="pattern"/>
            matched as rule
            <paramref name="patternRuleIndex"/>
            match
            <paramref name="tree"/>
            ?
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Matches(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)">
            <summary>
            Does
            <paramref name="pattern"/>
            matched as rule patternRuleIndex match tree? Pass in a
            compiled pattern instead of a string representation of a tree pattern.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,System.String,System.Int32)">
            <summary>
            Compare
            <paramref name="pattern"/>
            matched as rule
            <paramref name="patternRuleIndex"/>
            against
            <paramref name="tree"/>
            and return a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object that contains the
            matched elements, or the node at which the match failed.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)">
            <summary>
            Compare
            <paramref name="pattern"/>
            matched against
            <paramref name="tree"/>
            and return a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object that contains the matched elements, or the
            node at which the match failed. Pass in a compiled pattern instead of a
            string representation of a tree pattern.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Compile(System.String,System.Int32)">
            <summary>
            For repeated use of a tree pattern, compile it to a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            using this method.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Lexer">
            <summary>Used to convert the tree pattern string into a series of tokens.</summary>
            <remarks>
            Used to convert the tree pattern string into a series of tokens. The
            input stream is reset.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Parser">
            <summary>
            Used to collect to the grammar file name, token names, rule names for
            used to parse the pattern into a parse tree.
            </summary>
            <remarks>
            Used to collect to the grammar file name, token names, rule names for
            used to parse the pattern into a parse tree.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.MatchImpl(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Misc.MultiMap{System.String,Antlr4.Runtime.Tree.IParseTree})">
            <summary>
            Recursively walk
            <paramref name="tree"/>
            against
            <paramref name="patternTree"/>
            , filling
            <c>match.</c>
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Labels"/>
            .
            </summary>
            <returns>
            the first node encountered in
            <paramref name="tree"/>
            which does not match
            a corresponding node in
            <paramref name="patternTree"/>
            , or
            <see langword="null"/>
            if the match
            was successful. The specific node returned depends on the matching
            algorithm used by the implementation, and may be overridden.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.GetRuleTagToken(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Is
            <paramref name="t"/>

            <c>(expr &lt;expr&gt;)</c>
            subtree?
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Split(System.String)">
            <summary>
            Split
            <c>&lt;ID&gt; = &lt;e:expr&gt; ;</c>
            into 4 chunks for tokenizing by
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Tokenize(System.String)"/>
            .
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken">
            <summary>
            A
            <see cref="T:Antlr4.Runtime.IToken"/>
            object representing an entire subtree matched by a parser
            rule; e.g.,
            <c>&lt;expr&gt;</c>
            . These tokens are created for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            chunks where the tag corresponds to a parser rule.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.RuleTagToken.ruleName">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.RuleName"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.RuleTagToken.bypassTokenType">
            <summary>The token type for the current token.</summary>
            <remarks>
            The token type for the current token. This is the token type assigned to
            the bypass alternative for the rule during ATN deserialization.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.RuleTagToken.label">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Label"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.RuleTagToken.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            with the specified rule
            name and bypass token type and no label.
            </summary>
            <param name="ruleName">The name of the parser rule this rule tag matches.</param>
            <param name="bypassTokenType">The bypass token type assigned to the parser rule.</param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="ruleName"/>
            is
            <see langword="null"/>
            or empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.RuleTagToken.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            with the specified rule
            name, bypass token type, and label.
            </summary>
            <param name="ruleName">The name of the parser rule this rule tag matches.</param>
            <param name="bypassTokenType">The bypass token type assigned to the parser rule.</param>
            <param name="label">
            The label associated with the rule tag, or
            <see langword="null"/>
            if
            the rule tag is unlabeled.
            </param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="ruleName"/>
            is
            <see langword="null"/>
            or empty.
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.RuleName">
            <summary>Gets the name of the rule associated with this rule tag.</summary>
            <remarks>Gets the name of the rule associated with this rule tag.</remarks>
            <returns>The name of the parser rule associated with this rule tag.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Label">
            <summary>Gets the label associated with the rule tag.</summary>
            <remarks>Gets the label associated with the rule tag.</remarks>
            <returns>
            The name of the label associated with the rule tag, or
            <see langword="null"/>
            if this is an unlabeled rule tag.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Channel">
            <summary>
            <inheritDoc/>
            <p>Rule tag tokens are always placed on the
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Text">
            <summary>
            <inheritDoc/>
            <p>This method returns the rule tag formatted with
            <c>&lt;</c>
            and
            <c>&gt;</c>
            delimiters.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Type">
            <summary>
            <inheritDoc/>
            <p>Rule tag tokens have types assigned according to the rule bypass
            transitions created during ATN deserialization.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Line">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns 0.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Column">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.TokenIndex">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.StartIndex">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.StopIndex">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.TokenSource">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns
            <see langword="null"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.InputStream">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns
            <see langword="null"/>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.RuleTagToken.ToString">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            returns a string of the form
            <c>ruleName:bypassTokenType</c>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.TagChunk">
            <summary>Represents a placeholder tag in a tree pattern.</summary>
            <remarks>
            Represents a placeholder tag in a tree pattern. A tag can have any of the
            following forms.
            <ul>
            <li>
            <c>expr</c>
            : An unlabeled placeholder for a parser rule
            <c>expr</c>
            .</li>
            <li>
            <c>ID</c>
            : An unlabeled placeholder for a token of type
            <c>ID</c>
            .</li>
            <li>
            <c>e:expr</c>
            : A labeled placeholder for a parser rule
            <c>expr</c>
            .</li>
            <li>
            <c>id:ID</c>
            : A labeled placeholder for a token of type
            <c>ID</c>
            .</li>
            </ul>
            This class does not perform any validation on the tag or label names aside
            from ensuring that the tag is a non-null, non-empty string.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TagChunk.tag">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Tag"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TagChunk.label">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Label"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TagChunk.#ctor(System.String)">
            <summary>
            Construct a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            using the specified tag and
            no label.
            </summary>
            <param name="tag">
            The tag, which should be the name of a parser rule or token
            type.
            </param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="tag"/>
            is
            <see langword="null"/>
            or
            empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TagChunk.#ctor(System.String,System.String)">
            <summary>
            Construct a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            using the specified label
            and tag.
            </summary>
            <param name="label">
            The label for the tag. If this is
            <see langword="null"/>
            , the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            represents an unlabeled tag.
            </param>
            <param name="tag">
            The tag, which should be the name of a parser rule or token
            type.
            </param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="tag"/>
            is
            <see langword="null"/>
            or
            empty.
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Tag">
            <summary>Get the tag for this chunk.</summary>
            <remarks>Get the tag for this chunk.</remarks>
            <returns>The tag for the chunk.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Label">
            <summary>Get the label, if any, assigned to this chunk.</summary>
            <remarks>Get the label, if any, assigned to this chunk.</remarks>
            <returns>
            The label assigned to this chunk, or
            <see langword="null"/>
            if no label is
            assigned to the chunk.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TagChunk.ToString">
            <summary>This method returns a text representation of the tag chunk.</summary>
            <remarks>
            This method returns a text representation of the tag chunk. Labeled tags
            are returned in the form
            <c>label:tag</c>
            , and unlabeled tags are
            returned as just the tag name.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.TextChunk">
            <summary>
            Represents a span of raw text (concrete syntax) between tags in a tree
            pattern string.
            </summary>
            <remarks>
            Represents a span of raw text (concrete syntax) between tags in a tree
            pattern string.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TextChunk.text">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TextChunk.Text"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TextChunk.#ctor(System.String)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TextChunk"/>
            with the specified text.
            </summary>
            <param name="text">The text of this chunk.</param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="text"/>
            is
            <see langword="null"/>
            .
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TextChunk.Text">
            <summary>Gets the raw text of this chunk.</summary>
            <remarks>Gets the raw text of this chunk.</remarks>
            <returns>The text of the chunk.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TextChunk.ToString">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TextChunk"/>
            returns the result of
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TextChunk.Text"/>
            in single quotes.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken">
            <summary>
            A
            <see cref="T:Antlr4.Runtime.IToken"/>
            object representing a token of a particular type; e.g.,
            <c>&lt;ID&gt;</c>
            . These tokens are created for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            chunks where the
            tag corresponds to a lexer rule or token type.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TokenTagToken.tokenName">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.TokenName"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TokenTagToken.label">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.Label"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TokenTagToken.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            for an unlabeled tag
            with the specified token name and type.
            </summary>
            <param name="tokenName">The token name.</param>
            <param name="type">The token type.</param>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TokenTagToken.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            with the specified
            token name, type, and label.
            </summary>
            <param name="tokenName">The token name.</param>
            <param name="type">The token type.</param>
            <param name="label">
            The label associated with the token tag, or
            <see langword="null"/>
            if
            the token tag is unlabeled.
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.TokenName">
            <summary>Gets the token name.</summary>
            <remarks>Gets the token name.</remarks>
            <returns>The token name.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.Label">
            <summary>Gets the label associated with the rule tag.</summary>
            <remarks>Gets the label associated with the rule tag.</remarks>
            <returns>
            The name of the label associated with the rule tag, or
            <see langword="null"/>
            if this is an unlabeled rule tag.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.Text">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            returns the token tag
            formatted with
            <c>&lt;</c>
            and
            <c>&gt;</c>
            delimiters.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TokenTagToken.ToString">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            returns a string of the form
            <c>tokenName:type</c>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Trees">
            <summary>A set of utility routines useful for all kinds of ANTLR trees.</summary>
            <remarks>A set of utility routines useful for all kinds of ANTLR trees.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree)">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)"/>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)"/>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree,System.Collections.Generic.IList{System.String})">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)"/>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.GetChildren(Antlr4.Runtime.Tree.ITree)">
            <summary>Return ordered list of all children of this node</summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.GetAncestors(Antlr4.Runtime.Tree.ITree)">
            <summary>Return a list of all ancestors of this node.</summary>
            <remarks>
            Return a list of all ancestors of this node.  The first node of
            list is the root and the last is the parent of this node.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Xpath.XPath">
            <summary>
            Represent a subset of XPath XML path syntax for use in identifying nodes in
            parse trees.
            </summary>
            <remarks>
            Represent a subset of XPath XML path syntax for use in identifying nodes in
            parse trees.
            <p>
            Split path into words and separators
            <c>/</c>
            and
            <c>//</c>
            via ANTLR
            itself then walk path elements from left to right. At each separator-word
            pair, find set of nodes. Next stage uses those as work list.</p>
            <p>
            The basic interface is
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.FindAll(Antlr4.Runtime.Tree.IParseTree,System.String,Antlr4.Runtime.Parser)">ParseTree.findAll</see>
            <c>(tree, pathString, parser)</c>
            .
            But that is just shorthand for:</p>
            <pre>
            <see cref="T:Antlr4.Runtime.Tree.Xpath.XPath"/>
            p = new
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.#ctor(Antlr4.Runtime.Parser,System.String)">XPath</see>
            (parser, pathString);
            return p.
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.Evaluate(Antlr4.Runtime.Tree.IParseTree)">evaluate</see>
            (tree);
            </pre>
            <p>
            See
            <c>org.antlr.v4.test.TestXPath</c>
            for descriptions. In short, this
            allows operators:</p>
            <dl>
            <dt>/</dt> <dd>root</dd>
            <dt>//</dt> <dd>anywhere</dd>
            <dt>!</dt> <dd>invert; this must appear directly after root or anywhere
            operator</dd>
            </dl>
            <p>
            and path elements:</p>
            <dl>
            <dt>ID</dt> <dd>token name</dd>
            <dt>'string'</dt> <dd>any string literal token from the grammar</dd>
            <dt>expr</dt> <dd>rule name</dd>
            <dt>*</dt> <dd>wildcard matching any node</dd>
            </dl>
            <p>
            Whitespace is not allowed.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPath.GetXPathElement(Antlr4.Runtime.IToken,System.Boolean)">
            <summary>
            Convert word like
            <c>*</c>
            or
            <c>ID</c>
            or
            <c>expr</c>
            to a path
            element.
            <paramref name="anywhere"/>
            is
            <see langword="true"/>
            if
            <c>//</c>
            precedes the
            word.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPath.Evaluate(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Return a list of all nodes starting at
            <paramref name="t"/>
            as root that satisfy the
            path. The root
            <c>/</c>
            is relative to the node passed to
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.Evaluate(Antlr4.Runtime.Tree.IParseTree)"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPathElement.#ctor(System.String)">
            <summary>
            Construct element like
            <c>/ID</c>
            or
            <c>ID</c>
            or
            <c>/*</c>
            etc...
            op is null if just node
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPathElement.Evaluate(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Given tree rooted at
            <paramref name="t"/>
            return all nodes matched by this path
            element.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Xpath.XPathRuleAnywhereElement">
            <summary>
            Either
            <c>ID</c>
            at start of path or
            <c>...//ID</c>
            in middle of path.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.UnbufferedCharStream">
            <summary>Do not buffer up the entire char stream.</summary>
            <remarks>
            Do not buffer up the entire char stream. It does keep a small buffer
            for efficiency and also buffers while a mark exists (set by the
            lookahead prediction in parser). "Unbuffered" here refers to fact
            that it doesn't buffer all data, not that's it's on demand loading of char.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.data">
            <summary>A moving window buffer of the data being scanned.</summary>
            <remarks>
            A moving window buffer of the data being scanned. While there's a marker,
            we keep adding to buffer. Otherwise,
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Consume">consume()</see>
            resets so
            we start filling at index 0 again.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.n">
            <summary>
            The number of characters currently in
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            .
            <p>This is not the buffer capacity, that's
            <c>data.length</c>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.p">
            <summary>
            0..n-1 index into
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            of next character.
            <p>The
            <c>LA(1)</c>
            character is
            <c>data[p]</c>
            . If
            <c>p == n</c>
            , we are
            out of buffered characters.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.numMarkers">
            <summary>
            Count up with
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Mark">mark()</see>
            and down with
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Release(System.Int32)">release()</see>
            . When we
            <c>release()</c>
            the last mark,
            <c>numMarkers</c>
            reaches 0 and we reset the buffer. Copy
            <c>data[p]..data[n-1]</c>
            to
            <c>data[0]..data[(n-1)-p]</c>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.lastChar">
            <summary>
            This is the
            <c>LA(-1)</c>
            character for the current position.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.lastCharBufferStart">
            <summary>
            When
            <c>numMarkers &gt; 0</c>
            , this is the
            <c>LA(-1)</c>
            character for the
            first character in
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            . Otherwise, this is unspecified.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.currentCharIndex">
            <summary>Absolute character index.</summary>
            <remarks>
            Absolute character index. It's the index of the character about to be
            read via
            <c>LA(1)</c>
            . Goes from 0 to the number of characters in the
            entire stream, although the stream size is unknown before the end is
            reached.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.name">
            <summary>The name or source of this char stream.</summary>
            <remarks>The name or source of this char stream.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.#ctor">
            <summary>Useful for subclasses that pull char from other than this.input.</summary>
            <remarks>Useful for subclasses that pull char from other than this.input.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.#ctor(System.Int32)">
            <summary>Useful for subclasses that pull char from other than this.input.</summary>
            <remarks>Useful for subclasses that pull char from other than this.input.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Sync(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.p">p</see>
            .
            Last valid
            <c>p</c>
            index is
            <c>data.length-1</c>
            .
            <c>p+need-1</c>
            is
            the char index 'need' elements ahead. If we need 1 element,
            <c>(p+1-1)==p</c>
            must be less than
            <c>data.length</c>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Fill(System.Int32)">
            <summary>
            Add
            <paramref name="n"/>
            characters to the buffer. Returns the number of characters
            actually added to the buffer. If the return value is less than
            <paramref name="n"/>
            ,
            then EOF was reached before
            <paramref name="n"/>
            characters could be added.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.NextChar">
            <summary>
            Override to provide different source of characters than
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.input">input</see>
            .
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Mark">
            <summary>Return a marker that we can release later.</summary>
            <remarks>
            Return a marker that we can release later.
            <p>The specific marker value used for this class allows for some level of
            protection against misuse where
            <c>seek()</c>
            is called on a mark or
            <c>release()</c>
            is called in the wrong order.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Release(System.Int32)">
            <summary>Decrement number of markers, resetting buffer if we hit 0.</summary>
            <remarks>Decrement number of markers, resetting buffer if we hit 0.</remarks>
            <param name="marker"/>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Seek(System.Int32)">
            <summary>
            Seek to absolute character index, which might not be in the current
            sliding window.
            </summary>
            <remarks>
            Seek to absolute character index, which might not be in the current
            sliding window.  Move
            <c>p</c>
            to
            <c>index-bufferStartIndex</c>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">
            <summary>A moving window buffer of the data being scanned.</summary>
            <remarks>
            A moving window buffer of the data being scanned. While there's a marker,
            we keep adding to buffer. Otherwise,
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Consume">consume()</see>
            resets so
            we start filling at index 0 again.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.n">
            <summary>
            The number of tokens currently in
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">tokens</see>
            .
            <p>This is not the buffer capacity, that's
            <c>tokens.length</c>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.p">
            <summary>
            0..n-1 index into
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">tokens</see>
            of next token.
            <p>The
            <c>LT(1)</c>
            token is
            <c>tokens[p]</c>
            . If
            <c>p == n</c>
            , we are
            out of buffered tokens.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.numMarkers">
            <summary>
            Count up with
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Mark">mark()</see>
            and down with
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Release(System.Int32)">release()</see>
            . When we
            <c>release()</c>
            the last mark,
            <c>numMarkers</c>
            reaches 0 and we reset the buffer. Copy
            <c>tokens[p]..tokens[n-1]</c>
            to
            <c>tokens[0]..tokens[(n-1)-p]</c>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.lastToken">
            <summary>
            This is the
            <c>LT(-1)</c>
            token for the current position.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.lastTokenBufferStart">
            <summary>
            When
            <c>numMarkers &gt; 0</c>
            , this is the
            <c>LT(-1)</c>
            token for the
            first token in
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens"/>
            . Otherwise, this is
            <see langword="null"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.currentTokenIndex">
            <summary>Absolute token index.</summary>
            <remarks>
            Absolute token index. It's the index of the token about to be read via
            <c>LT(1)</c>
            . Goes from 0 to the number of tokens in the entire stream,
            although the stream size is unknown before the end is reached.
            <p>This value is used to set the token indexes if the stream provides tokens
            that implement
            <see cref="T:Antlr4.Runtime.IWritableToken"/>
            .</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Sync(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.p">p</see>
            . Last valid
            <c>p</c>
            index is
            <c>tokens.length-1</c>
            .
            <c>p+need-1</c>
            is the tokens index 'need' elements
            ahead.  If we need 1 element,
            <c>(p+1-1)==p</c>
            must be less than
            <c>tokens.length</c>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Fill(System.Int32)">
            <summary>
            Add
            <paramref name="n"/>
            elements to the buffer. Returns the number of tokens
            actually added to the buffer. If the return value is less than
            <paramref name="n"/>
            ,
            then EOF was reached before
            <paramref name="n"/>
            tokens could be added.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Mark">
            <summary>Return a marker that we can release later.</summary>
            <remarks>
            Return a marker that we can release later.
            <p>The specific marker value used for this class allows for some level of
            protection against misuse where
            <c>seek()</c>
            is called on a mark or
            <c>release()</c>
            is called in the wrong order.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Vocabulary">
            <summary>
            This class provides a default implementation of the
            <see cref="T:Antlr4.Runtime.IVocabulary"/>
            interface.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Vocabulary.EmptyVocabulary">
            <summary>
            Gets an empty
            <see cref="T:Antlr4.Runtime.IVocabulary"/>
            instance.
            <p>
            No literal or symbol names are assigned to token types, so
            <see cref="M:Antlr4.Runtime.Vocabulary.GetDisplayName(System.Int32)"/>
            returns the numeric value for all tokens
            except
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Vocabulary.#ctor(System.String[],System.String[])">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Vocabulary"/>
            from the specified
            literal and symbolic token names.
            </summary>
            <param name="literalNames">
            The literal names assigned to tokens, or
            <see langword="null"/>
            if no literal names are assigned.
            </param>
            <param name="symbolicNames">
            The symbolic names assigned to tokens, or
            <see langword="null"/>
            if no symbolic names are assigned.
            </param>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetLiteralName(System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetSymbolicName(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.Vocabulary.#ctor(System.String[],System.String[],System.String[])">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Vocabulary"/>
            from the specified
            literal, symbolic, and display token names.
            </summary>
            <param name="literalNames">
            The literal names assigned to tokens, or
            <see langword="null"/>
            if no literal names are assigned.
            </param>
            <param name="symbolicNames">
            The symbolic names assigned to tokens, or
            <see langword="null"/>
            if no symbolic names are assigned.
            </param>
            <param name="displayNames">
            The display names assigned to tokens, or
            <see langword="null"/>
            to use the values in
            <paramref name="literalNames"/>
            and
            <paramref name="symbolicNames"/>
            as
            the source of display names, as described in
            <see cref="M:Antlr4.Runtime.Vocabulary.GetDisplayName(System.Int32)"/>
            .
            </param>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetLiteralName(System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetSymbolicName(System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetDisplayName(System.Int32)"/>
        </member>
        <member name="T:BindingPathBaseListener">
            <summary>
            This class provides an empty implementation of <see cref="T:IBindingPathListener"/>,
            which can be extended to create a listener which only needs to handle a subset
            of the available methods.
            </summary>
        </member>
        <member name="M:BindingPathBaseListener.EnterProgram(BindingPathParser.ProgramContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.program"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitProgram(BindingPathParser.ProgramContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.program"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterDecimal_value(BindingPathParser.Decimal_valueContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.decimal_value"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitDecimal_value(BindingPathParser.Decimal_valueContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.decimal_value"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterBoolean_value(BindingPathParser.Boolean_valueContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.boolean_value"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitBoolean_value(BindingPathParser.Boolean_valueContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.boolean_value"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterNamespace_qualifier(BindingPathParser.Namespace_qualifierContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.namespace_qualifier"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitNamespace_qualifier(BindingPathParser.Namespace_qualifierContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.namespace_qualifier"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterStatic_type(BindingPathParser.Static_typeContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.static_type"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitStatic_type(BindingPathParser.Static_typeContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.static_type"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterAttached_expr(BindingPathParser.Attached_exprContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.attached_expr"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitAttached_expr(BindingPathParser.Attached_exprContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.attached_expr"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterCast_expr(BindingPathParser.Cast_exprContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.cast_expr"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitCast_expr(BindingPathParser.Cast_exprContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.cast_expr"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterFunction(BindingPathParser.FunctionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.function"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitFunction(BindingPathParser.FunctionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.function"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathStaticFuction(BindingPathParser.PathStaticFuctionContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathStaticFuction"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathStaticFuction(BindingPathParser.PathStaticFuctionContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathStaticFuction"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathCast(BindingPathParser.PathCastContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathCast"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathCast(BindingPathParser.PathCastContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathCast"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathPathToFunction(BindingPathParser.PathPathToFunctionContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathPathToFunction"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathPathToFunction(BindingPathParser.PathPathToFunctionContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathPathToFunction"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathIndexer(BindingPathParser.PathIndexerContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathIndexer"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathIndexer(BindingPathParser.PathIndexerContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathIndexer"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathCastInvalid(BindingPathParser.PathCastInvalidContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathCastInvalid"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathCastInvalid(BindingPathParser.PathCastInvalidContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathCastInvalid"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathCastPathParen(BindingPathParser.PathCastPathParenContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathCastPathParen"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathCastPathParen(BindingPathParser.PathCastPathParenContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathCastPathParen"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathFunction(BindingPathParser.PathFunctionContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathFunction"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathFunction(BindingPathParser.PathFunctionContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathFunction"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathStringIndexer(BindingPathParser.PathStringIndexerContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathStringIndexer"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathStringIndexer(BindingPathParser.PathStringIndexerContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathStringIndexer"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathIdentifier(BindingPathParser.PathIdentifierContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathIdentifier"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathIdentifier(BindingPathParser.PathIdentifierContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathIdentifier"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathCastPath(BindingPathParser.PathCastPathContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathCastPath"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathCastPath(BindingPathParser.PathCastPathContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathCastPath"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathStaticIdentifier(BindingPathParser.PathStaticIdentifierContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathStaticIdentifier"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathStaticIdentifier(BindingPathParser.PathStaticIdentifierContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathStaticIdentifier"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathDotIdentifier(BindingPathParser.PathDotIdentifierContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathDotIdentifier"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathDotIdentifier(BindingPathParser.PathDotIdentifierContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathDotIdentifier"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterPathDotAttached(BindingPathParser.PathDotAttachedContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.PathDotAttached"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitPathDotAttached(BindingPathParser.PathDotAttachedContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.PathDotAttached"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterFunctionParameterInvalid(BindingPathParser.FunctionParameterInvalidContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.FunctionParameterInvalid"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitFunctionParameterInvalid(BindingPathParser.FunctionParameterInvalidContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.FunctionParameterInvalid"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterFunctionParamPath(BindingPathParser.FunctionParamPathContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.FunctionParamPath"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitFunctionParamPath(BindingPathParser.FunctionParamPathContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.FunctionParamPath"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterFunctionParamBool(BindingPathParser.FunctionParamBoolContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.FunctionParamBool"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitFunctionParamBool(BindingPathParser.FunctionParamBoolContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.FunctionParamBool"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterFunctionParamNumber(BindingPathParser.FunctionParamNumberContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.FunctionParamNumber"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitFunctionParamNumber(BindingPathParser.FunctionParamNumberContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.FunctionParamNumber"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterFunctionParamString(BindingPathParser.FunctionParamStringContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.FunctionParamString"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitFunctionParamString(BindingPathParser.FunctionParamStringContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.FunctionParamString"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterFunctionParamNullValue(BindingPathParser.FunctionParamNullValueContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:BindingPathParser.FunctionParamNullValue"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.ExitFunctionParamNullValue(BindingPathParser.FunctionParamNullValueContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:BindingPathParser.FunctionParamNullValue"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:BindingPathBaseListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:BindingPathBaseListener.ExitEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:BindingPathBaseListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:BindingPathBaseListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="T:IBindingPathListener">
            <summary>
            This interface defines a complete listener for a parse tree produced by
            <see cref="T:BindingPathParser"/>.
            </summary>
        </member>
        <member name="M:IBindingPathListener.EnterProgram(BindingPathParser.ProgramContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.program"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitProgram(BindingPathParser.ProgramContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.program"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterDecimal_value(BindingPathParser.Decimal_valueContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.decimal_value"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitDecimal_value(BindingPathParser.Decimal_valueContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.decimal_value"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterBoolean_value(BindingPathParser.Boolean_valueContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.boolean_value"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitBoolean_value(BindingPathParser.Boolean_valueContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.boolean_value"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterNamespace_qualifier(BindingPathParser.Namespace_qualifierContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.namespace_qualifier"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitNamespace_qualifier(BindingPathParser.Namespace_qualifierContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.namespace_qualifier"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterStatic_type(BindingPathParser.Static_typeContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.static_type"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitStatic_type(BindingPathParser.Static_typeContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.static_type"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterAttached_expr(BindingPathParser.Attached_exprContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.attached_expr"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitAttached_expr(BindingPathParser.Attached_exprContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.attached_expr"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterCast_expr(BindingPathParser.Cast_exprContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.cast_expr"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitCast_expr(BindingPathParser.Cast_exprContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.cast_expr"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterFunction(BindingPathParser.FunctionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:BindingPathParser.function"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitFunction(BindingPathParser.FunctionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:BindingPathParser.function"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathStaticFuction(BindingPathParser.PathStaticFuctionContext)">
            <summary>
            Enter a parse tree produced by the <c>PathStaticFuction</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathStaticFuction(BindingPathParser.PathStaticFuctionContext)">
            <summary>
            Exit a parse tree produced by the <c>PathStaticFuction</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathCast(BindingPathParser.PathCastContext)">
            <summary>
            Enter a parse tree produced by the <c>PathCast</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathCast(BindingPathParser.PathCastContext)">
            <summary>
            Exit a parse tree produced by the <c>PathCast</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathPathToFunction(BindingPathParser.PathPathToFunctionContext)">
            <summary>
            Enter a parse tree produced by the <c>PathPathToFunction</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathPathToFunction(BindingPathParser.PathPathToFunctionContext)">
            <summary>
            Exit a parse tree produced by the <c>PathPathToFunction</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathIndexer(BindingPathParser.PathIndexerContext)">
            <summary>
            Enter a parse tree produced by the <c>PathIndexer</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathIndexer(BindingPathParser.PathIndexerContext)">
            <summary>
            Exit a parse tree produced by the <c>PathIndexer</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathCastInvalid(BindingPathParser.PathCastInvalidContext)">
            <summary>
            Enter a parse tree produced by the <c>PathCastInvalid</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathCastInvalid(BindingPathParser.PathCastInvalidContext)">
            <summary>
            Exit a parse tree produced by the <c>PathCastInvalid</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathCastPathParen(BindingPathParser.PathCastPathParenContext)">
            <summary>
            Enter a parse tree produced by the <c>PathCastPathParen</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathCastPathParen(BindingPathParser.PathCastPathParenContext)">
            <summary>
            Exit a parse tree produced by the <c>PathCastPathParen</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathFunction(BindingPathParser.PathFunctionContext)">
            <summary>
            Enter a parse tree produced by the <c>PathFunction</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathFunction(BindingPathParser.PathFunctionContext)">
            <summary>
            Exit a parse tree produced by the <c>PathFunction</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathStringIndexer(BindingPathParser.PathStringIndexerContext)">
            <summary>
            Enter a parse tree produced by the <c>PathStringIndexer</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathStringIndexer(BindingPathParser.PathStringIndexerContext)">
            <summary>
            Exit a parse tree produced by the <c>PathStringIndexer</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathIdentifier(BindingPathParser.PathIdentifierContext)">
            <summary>
            Enter a parse tree produced by the <c>PathIdentifier</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathIdentifier(BindingPathParser.PathIdentifierContext)">
            <summary>
            Exit a parse tree produced by the <c>PathIdentifier</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathCastPath(BindingPathParser.PathCastPathContext)">
            <summary>
            Enter a parse tree produced by the <c>PathCastPath</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathCastPath(BindingPathParser.PathCastPathContext)">
            <summary>
            Exit a parse tree produced by the <c>PathCastPath</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathStaticIdentifier(BindingPathParser.PathStaticIdentifierContext)">
            <summary>
            Enter a parse tree produced by the <c>PathStaticIdentifier</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathStaticIdentifier(BindingPathParser.PathStaticIdentifierContext)">
            <summary>
            Exit a parse tree produced by the <c>PathStaticIdentifier</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathDotIdentifier(BindingPathParser.PathDotIdentifierContext)">
            <summary>
            Enter a parse tree produced by the <c>PathDotIdentifier</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathDotIdentifier(BindingPathParser.PathDotIdentifierContext)">
            <summary>
            Exit a parse tree produced by the <c>PathDotIdentifier</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterPathDotAttached(BindingPathParser.PathDotAttachedContext)">
            <summary>
            Enter a parse tree produced by the <c>PathDotAttached</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitPathDotAttached(BindingPathParser.PathDotAttachedContext)">
            <summary>
            Exit a parse tree produced by the <c>PathDotAttached</c>
            labeled alternative in <see cref="M:BindingPathParser.path"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterFunctionParameterInvalid(BindingPathParser.FunctionParameterInvalidContext)">
            <summary>
            Enter a parse tree produced by the <c>FunctionParameterInvalid</c>
            labeled alternative in <see cref="M:BindingPathParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitFunctionParameterInvalid(BindingPathParser.FunctionParameterInvalidContext)">
            <summary>
            Exit a parse tree produced by the <c>FunctionParameterInvalid</c>
            labeled alternative in <see cref="M:BindingPathParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterFunctionParamPath(BindingPathParser.FunctionParamPathContext)">
            <summary>
            Enter a parse tree produced by the <c>FunctionParamPath</c>
            labeled alternative in <see cref="M:BindingPathParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitFunctionParamPath(BindingPathParser.FunctionParamPathContext)">
            <summary>
            Exit a parse tree produced by the <c>FunctionParamPath</c>
            labeled alternative in <see cref="M:BindingPathParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterFunctionParamBool(BindingPathParser.FunctionParamBoolContext)">
            <summary>
            Enter a parse tree produced by the <c>FunctionParamBool</c>
            labeled alternative in <see cref="M:BindingPathParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitFunctionParamBool(BindingPathParser.FunctionParamBoolContext)">
            <summary>
            Exit a parse tree produced by the <c>FunctionParamBool</c>
            labeled alternative in <see cref="M:BindingPathParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterFunctionParamNumber(BindingPathParser.FunctionParamNumberContext)">
            <summary>
            Enter a parse tree produced by the <c>FunctionParamNumber</c>
            labeled alternative in <see cref="M:BindingPathParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitFunctionParamNumber(BindingPathParser.FunctionParamNumberContext)">
            <summary>
            Exit a parse tree produced by the <c>FunctionParamNumber</c>
            labeled alternative in <see cref="M:BindingPathParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterFunctionParamString(BindingPathParser.FunctionParamStringContext)">
            <summary>
            Enter a parse tree produced by the <c>FunctionParamString</c>
            labeled alternative in <see cref="M:BindingPathParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitFunctionParamString(BindingPathParser.FunctionParamStringContext)">
            <summary>
            Exit a parse tree produced by the <c>FunctionParamString</c>
            labeled alternative in <see cref="M:BindingPathParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.EnterFunctionParamNullValue(BindingPathParser.FunctionParamNullValueContext)">
            <summary>
            Enter a parse tree produced by the <c>FunctionParamNullValue</c>
            labeled alternative in <see cref="M:BindingPathParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IBindingPathListener.ExitFunctionParamNullValue(BindingPathParser.FunctionParamNullValueContext)">
            <summary>
            Exit a parse tree produced by the <c>FunctionParamNullValue</c>
            labeled alternative in <see cref="M:BindingPathParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="T:ConditionalNamespaceBaseListener">
            <summary>
            This class provides an empty implementation of <see cref="T:IConditionalNamespaceListener"/>,
            which can be extended to create a listener which only needs to handle a subset
            of the available methods.
            </summary>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.EnterProgram(ConditionalNamespaceParser.ProgramContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.program"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.ExitProgram(ConditionalNamespaceParser.ProgramContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.program"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.EnterExpression(ConditionalNamespaceParser.ExpressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.ExitExpression(ConditionalNamespaceParser.ExpressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.EnterUri(ConditionalNamespaceParser.UriContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.uri"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.ExitUri(ConditionalNamespaceParser.UriContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.uri"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.EnterUnquoted_namespace(ConditionalNamespaceParser.Unquoted_namespaceContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.unquoted_namespace"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.ExitUnquoted_namespace(ConditionalNamespaceParser.Unquoted_namespaceContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.unquoted_namespace"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.EnterApi_information(ConditionalNamespaceParser.Api_informationContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.api_information"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.ExitApi_information(ConditionalNamespaceParser.Api_informationContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.api_information"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.EnterFunction_param(ConditionalNamespaceParser.Function_paramContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.function_param"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.ExitFunction_param(ConditionalNamespaceParser.Function_paramContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.function_param"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.EnterTarget_platform_value(ConditionalNamespaceParser.Target_platform_valueContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.target_platform_value"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.ExitTarget_platform_value(ConditionalNamespaceParser.Target_platform_valueContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.target_platform_value"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.EnterQuery_string(ConditionalNamespaceParser.Query_stringContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.query_string"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.ExitQuery_string(ConditionalNamespaceParser.Query_stringContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.query_string"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.EnterQueryStringTargetPlatform(ConditionalNamespaceParser.QueryStringTargetPlatformContext)">
            <summary>
            Enter a parse tree produced by the <c>QueryStringTargetPlatform</c>
            labeled alternative in <see cref="M:ConditionalNamespaceParser.query_string_component"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.ExitQueryStringTargetPlatform(ConditionalNamespaceParser.QueryStringTargetPlatformContext)">
            <summary>
            Exit a parse tree produced by the <c>QueryStringTargetPlatform</c>
            labeled alternative in <see cref="M:ConditionalNamespaceParser.query_string_component"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.EnterQueryStringApiInformation(ConditionalNamespaceParser.QueryStringApiInformationContext)">
            <summary>
            Enter a parse tree produced by the <c>QueryStringApiInformation</c>
            labeled alternative in <see cref="M:ConditionalNamespaceParser.query_string_component"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.ExitQueryStringApiInformation(ConditionalNamespaceParser.QueryStringApiInformationContext)">
            <summary>
            Exit a parse tree produced by the <c>QueryStringApiInformation</c>
            labeled alternative in <see cref="M:ConditionalNamespaceParser.query_string_component"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.EnterTarget_platform_func(ConditionalNamespaceParser.Target_platform_funcContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.target_platform_func"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.ExitTarget_platform_func(ConditionalNamespaceParser.Target_platform_funcContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.target_platform_func"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.ExitEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:ConditionalNamespaceBaseListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="T:IConditionalNamespaceListener">
            <summary>
            This interface defines a complete listener for a parse tree produced by
            <see cref="T:ConditionalNamespaceParser"/>.
            </summary>
        </member>
        <member name="M:IConditionalNamespaceListener.EnterProgram(ConditionalNamespaceParser.ProgramContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.program"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.ExitProgram(ConditionalNamespaceParser.ProgramContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.program"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.EnterExpression(ConditionalNamespaceParser.ExpressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.ExitExpression(ConditionalNamespaceParser.ExpressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.EnterUri(ConditionalNamespaceParser.UriContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.uri"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.ExitUri(ConditionalNamespaceParser.UriContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.uri"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.EnterUnquoted_namespace(ConditionalNamespaceParser.Unquoted_namespaceContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.unquoted_namespace"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.ExitUnquoted_namespace(ConditionalNamespaceParser.Unquoted_namespaceContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.unquoted_namespace"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.EnterApi_information(ConditionalNamespaceParser.Api_informationContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.api_information"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.ExitApi_information(ConditionalNamespaceParser.Api_informationContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.api_information"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.EnterFunction_param(ConditionalNamespaceParser.Function_paramContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.ExitFunction_param(ConditionalNamespaceParser.Function_paramContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.function_param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.EnterTarget_platform_value(ConditionalNamespaceParser.Target_platform_valueContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.target_platform_value"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.ExitTarget_platform_value(ConditionalNamespaceParser.Target_platform_valueContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.target_platform_value"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.EnterQuery_string(ConditionalNamespaceParser.Query_stringContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.query_string"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.ExitQuery_string(ConditionalNamespaceParser.Query_stringContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.query_string"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.EnterQueryStringTargetPlatform(ConditionalNamespaceParser.QueryStringTargetPlatformContext)">
            <summary>
            Enter a parse tree produced by the <c>QueryStringTargetPlatform</c>
            labeled alternative in <see cref="M:ConditionalNamespaceParser.query_string_component"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.ExitQueryStringTargetPlatform(ConditionalNamespaceParser.QueryStringTargetPlatformContext)">
            <summary>
            Exit a parse tree produced by the <c>QueryStringTargetPlatform</c>
            labeled alternative in <see cref="M:ConditionalNamespaceParser.query_string_component"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.EnterQueryStringApiInformation(ConditionalNamespaceParser.QueryStringApiInformationContext)">
            <summary>
            Enter a parse tree produced by the <c>QueryStringApiInformation</c>
            labeled alternative in <see cref="M:ConditionalNamespaceParser.query_string_component"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.ExitQueryStringApiInformation(ConditionalNamespaceParser.QueryStringApiInformationContext)">
            <summary>
            Exit a parse tree produced by the <c>QueryStringApiInformation</c>
            labeled alternative in <see cref="M:ConditionalNamespaceParser.query_string_component"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.EnterTarget_platform_func(ConditionalNamespaceParser.Target_platform_funcContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:ConditionalNamespaceParser.target_platform_func"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IConditionalNamespaceListener.ExitTarget_platform_func(ConditionalNamespaceParser.Target_platform_funcContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:ConditionalNamespaceParser.target_platform_func"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="T:MS.Internal.Serialization.StringValueSerializer">
            <summary>
            Stub string serializer. It exists to remove special caseing strings in a couple cases in the
            serialization code. It essentially states that strings are serialized as their value.
            </summary>
        </member>
        <member name="T:MS.Internal.Serialization.TypeConverterValueSerializer">
            <summary>
            The TypeConverter value serializer uses a TypeConverter to implement the translation
            to and from a string. The caller of the constructor must ensure the TypeConverter supports
            converstion to and from string.
            </summary>
        </member>
        <member name="T:MS.Internal.Xaml.Parser.SpecialBracketCharacters">
            <summary>
            Class that provides helper functions for the parser/Xaml Reader
            to process Bracket Characters specified on a Markup Extension Property
            </summary>
        </member>
        <member name="M:MS.Internal.Xaml.Parser.XamlPullParser.Logic_IsDiscardableWhitespace(MS.Internal.Xaml.Parser.XamlText)">
            <summary>
            Returns true if whitespace is discardable at this phase in
            the parsing.  Here we discard whitespace between property elements
            but keep it between object elements for collections that accept it.
            Discarding trailing whitespace in collections cannot be decided here.
            [see: Logic_ReadAhead_ApplyFinalTextTrimming
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:MS.Internal.Xaml.SecurityCriticalDataForSet`1.#ctor(`0)">
            <SecurityNote>
               Critical - "by definition" - this class is intended only for data that's
                          Critical for setting.
            </SecurityNote>
        </member>
        <member name="P:MS.Internal.Xaml.SecurityCriticalDataForSet`1.Value">
            <SecurityNote>
               Critical - Setter is Critical "by definition" - this class is intended only
                          for data that's Critical for setting.
                Safe - get is safe by definition.
                Not Safe - set is not safe by definition.
            </SecurityNote>
        </member>
        <member name="F:MS.Internal.Xaml.SecurityCriticalDataForSet`1._value">
            <SecurityNote>
            Critical - by definition as this data is Critical for set.
            </SecurityNote>>
        </member>
        <member name="P:MS.Internal.Xaml.Context.FixupTarget.Property">
            <summary>
            The Property the value will be assigned into.
            In the case of FixupType.Property, this property will be set directly
            when the Name is known.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.FixupTarget.Instance">
            <summary>
            The Instance the Property is on.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.FixupTarget.InstanceName">
            <summary>
            The x:Name, if any, of Instance. May not be set yet if InstanceIsOnTheStack is still true.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.FixupTarget.InstanceType">
            <summary>
            The XamlType of the Instance (taken from the Frame, not exactly the type of the instance)
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.FixupTarget.TemporaryCollectionIndex">
            <summary>
            If Property is XamlLanguage.Items, then all the items being added to the target collection
            are stored in a temporary holding collection. This is the index of the location in the collection
            where this token is stored.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.FixupTarget.EndInstanceLineNumber">
            <summary>
            The LineNumber to use when calling EndInit on the Target Instance
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.FixupTarget.EndInstanceLinePosition">
            <summary>
            The LinePosition to use when calling EndInit on the Target Instance
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.FixupTarget.KeyHolder">
            <summary>
            The ObjectWriterFrame and the FixupTarget need to both be updated when the Key is changed.
            We create a KeyHolder to accomplish this
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.FixupTarget.InstanceIsOnTheStack">
            <summary>
            Whether Instance is still on the live builder stack. We will use this to determine
            whether to call EndInit on it when all fixups are resolved.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.FixupTarget.InstanceWasGotten">
            <summary>
            Whether Instance was retrieved from a property (i.e. was a GO). If so, we don't call EndInit on it.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.NameFixupToken.SavedContext">
            <summary>
            Saved state for the reparse option.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.NameFixupToken.NameScopeDictionaryList">
            <summary>
            Saved List of Name Scopes.   With simple fixups we don't have a full context stack.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.ObjectWriterContext.Depth">
            <summary>
            Total depth of the stack SavedDepth+LiveDepth
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.ObjectWriterContext.SavedDepth">
            <summary>
            The Depth of the Saved (template) part.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.ObjectWriterContext.LiveDepth">
            <summary>
            The Depth of the Stack above the Saved (template) part
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.ObjectWriterContext.CurrentCtorArgs">
            <summary>
            From x:Arguments or ME positional syntax.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.ObjectWriterFrame.InstanceRegisteredName">
            <summary>
            The x:Name of this.Instance.
            Used to trigger forward ref resolution.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.ObjectWriterFrame.PreconstructionPropertyValues">
            <summary>
            Collection of directives set on this object, because
            directives can't be stored on the object.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.Context.ObjectWriterFrame.AssignedProperties">
            <summary>
            All Properties that are set so far.
            </summary>
        </member>
        <member name="M:MS.Internal.Xaml.Context.XamlParserContext.InitLongestConstructor(System.Xaml.XamlType)">
            <summary>
            Finds the list of parameters of the constructor with the most number
            of arguments.
            </summary>
        </member>
        <member name="P:MS.Internal.Xaml.XamlContext.LocalAssembly">
            <SecurityNote>
            Note: not SecurityCritical. Should be used only for convenience filtering, not for security decisions.
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.XamlContext.GetDottedProperty(System.Xaml.XamlType,System.String,MS.Internal.Xaml.Parser.XamlPropertyName,System.Boolean)">
            <summary>
            Resolves a property of the form 'Foo.Bar' or 'a:Foo.Bar', in
            in the context of a parent tag.  The parent tagType may or may not
            be covariant with the ownerType.  In the case of dotted attribute
            syntax, the namespace my be passed in.
            </summary>
            <param name="tagType">The xamlType of the enclosing Tag</param>
            <param name="tagNamespace">The namespace of the enclosing Tag</param>
            <param name="propName">The dotted name of the property</param>
            <param name="tagIsRoot">Whether the tag is the root of the document</param>
            <returns></returns>
        </member>
        <member name="M:MS.Internal.Xaml.XamlContext.IgnoreAPIInformation(System.String)">
            <summary>
            This function returns the namespace part without API Information.
            For instance, for the folowing namespace:
                http://schemas.microsoft.com/winfx/2006/xaml/presentation?IsApiContractPresent(Windows.Foundation.UniversalApiContract, 4, 0)
            it returns:
                http://schemas.microsoft.com/winfx/2006/xaml/presentation
            Or for this other one:
                using:Conditionals?IsTypeNotPresent(Conditionals.Foo)
            it returns:
                using:Conditionals
            </summary>
        </member>
        <member name="T:MS.Internal.Xaml.Runtime.DynamicMethodRuntime">
            <SecurityNote>
            Critical: Creates and stores delegates with the ability to access non-public members
            </SecurityNote>
        </member>
        <member name="F:MS.Internal.Xaml.Runtime.DynamicMethodRuntime._xamlLoadPermission">
            <SecurityNote>
            Critical: this is the permision that we demand to allow use of our delegate cache, so
                      shouldn't be changed once we've started creating delegates
            </SecurityNote>
        </member>
        <member name="F:MS.Internal.Xaml.Runtime.DynamicMethodRuntime._localAssembly">
            <SecurityNote>
            Critical: used as the ownerModule of delegates created under full trust
            </SecurityNote>
        </member>
        <member name="F:MS.Internal.Xaml.Runtime.DynamicMethodRuntime._localType">
            <SecurityNote>
            Critical: used as the ownerType of delegates created under full trust
            </SecurityNote>
        </member>
        <member name="F:MS.Internal.Xaml.Runtime.DynamicMethodRuntime._propertyGetDelegates">
            <SecurityNote>
            Critical: all the fields below cache delegates created with the ownerType/ownerAssembly
                      specified in _localAssembly or _localType
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.#ctor(MS.Internal.Xaml.Runtime.XamlRuntimeSettings,System.Xaml.XamlSchemaContext,System.Xaml.Permissions.XamlAccessLevel)">
            <SecurityNote>
            Critical: Sets critical fields _xamlLoadPermission, _localAssembly, _localType
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.GetConverterInstance``1(System.Xaml.Schema.XamlValueConverter{``0})">
            <SecurityNote>
            Critical: Creates/accesses non-public accessors
            Safe: Can only access non-publics specified in _xamlLoadPermission, which we demand XamlLoadPermission for
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.CreateFromValue(MS.Internal.Xaml.ServiceProviderContext,System.Xaml.Schema.XamlValueConverter{System.ComponentModel.TypeConverter},System.Object,System.Xaml.XamlMember)">
            <SecurityNote>
            Critical: part of a critical class
            Safe: does not access any critical member
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.CreateDelegate(System.Type,System.Object,System.String)">
            <SecurityNote>
            Critical: Creates/accesses non-public accessors
            Safe: Can only access non-publics specified in _xamlLoadPermission, which we demand XamlLoadPermission for
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.CreateInstanceWithCtor(System.Xaml.XamlType,System.Object[])">
            <SecurityNote>
            Critical: Creates/accesses non-public accessors
            Safe: Can only access non-publics specified in _xamlLoadPermission, which we demand XamlLoadPermission for
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.CreateInstanceWithCtor(System.Type,System.Object[])">
            <SecurityNote>
            Critical: Creates/accesses non-public accessors
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.InvokeFactoryMethod(System.Type,System.String,System.Object[])">
            <SecurityNote>
            Critical: Creates/accesses non-public accessors
            Safe: Can only access non-publics specified in _xamlLoadPermission, which we demand XamlLoadPermission for
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.GetValue(System.Xaml.XamlMember,System.Object)">
            <SecurityNote>
            Critical: Creates/accesses non-public accessors
            Safe: Can only access non-publics specified in _xamlLoadPermission, which we demand XamlLoadPermission for
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.SetValue(System.Xaml.XamlMember,System.Object,System.Object)">
            <SecurityNote>
            Critical: Creates/accesses non-public accessors
            Safe: Can only access non-publics specified in _xamlLoadPermission, which we demand XamlLoadPermission for
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.CreateDelegateCreator(System.Type)">
            <SecurityNote>
            Critical: Calls critical method CreateDynamicMethod
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.CreateDelegateCreatorWithoutHelper">
            <SecurityNote>
            Critical: Calls critical method CreateDynamicMethod
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.CreateFactoryDelegate(System.Reflection.ConstructorInfo)">
            <SecurityNote>
            Critical: Calls critical method CreateDynamicMethod
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.CreateFactoryDelegate(System.Reflection.MethodInfo)">
            <SecurityNote>
            Critical: Calls critical method CreateDynamicMethod
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.LoadArguments(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
            <SecurityNote>
            Critical: ILGens into critically created method
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.UnloadArguments(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder[])">
            <SecurityNote>
            Critical: ILGens into critically created method
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.CreateGetDelegate(System.Reflection.MethodInfo)">
            <SecurityNote>
            Critical: Calls critical method CreateDynamicMethod
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.CreateSetDelegate(System.Reflection.MethodInfo)">
            <SecurityNote>
            Critical: Calls critical method CreateDynamicMethod
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.CreateDynamicMethod(System.String,System.Type,System.Type[])">
            <SecurityNote>
            Critical: Asserts Full Trust. We are relying on our safe caller to have demanded _xamlLoadPermission
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.DemandXamlLoadPermission">
            <SecurityNote>
            Critical: All the SafeCritical entry points rely on this method for their access check.
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.Emit_Call(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
            <SecurityNote>
            Critical: ILGens into critically created method
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.Emit_CastTo(System.Reflection.Emit.ILGenerator,System.Type)">
            <SecurityNote>
            Critical: ILGens into critically created method
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.Emit_BoxIfValueType(System.Reflection.Emit.ILGenerator,System.Type)">
            <SecurityNote>
            Critical: ILGens into critically created method
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.Emit_ConstInt(System.Reflection.Emit.ILGenerator,System.Int32)">
            <SecurityNote>
            Critical: ILGens into critically created method
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.Emit_LateBoundInvoke(System.Reflection.Emit.ILGenerator,System.Type,System.String,System.Reflection.BindingFlags,System.Int16,System.Int16[])">
            <SecurityNote>
            Critical: ILGens into critically created method
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.DynamicMethodRuntime.Emit_TypeOf(System.Reflection.Emit.ILGenerator,System.Type)">
            <SecurityNote>
            Critical: ILGens into critically created method
            </SecurityNote>
        </member>
        <member name="M:MS.Internal.Xaml.Runtime.PartialTrustTolerantRuntime.EnsureElevatedRuntime">
            <SecurityNote>
            Critical: Initializes critical type DynamicMethodRuntime
            Safe: Initializes via safe ctor, and DMR demands at all its safe entry points
            </SecurityNote>
        </member>
    </members>
</doc>
