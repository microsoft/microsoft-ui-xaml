// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 17.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.UI.Xaml.Markup.Compiler.CodeGen
{
    using System.Linq;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
    internal partial class MoComCppTypeInfoPass2 : CppCX_CodeGenerator<TypeInfoDefinition>
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
");
  if(!String.IsNullOrEmpty(ProjectInfo.PrecompiledHeaderFile)) { 
            this.Write("#include \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(ProjectInfo.PrecompiledHeaderFile));
            this.Write("\"\r\n");
  }
  if (ProjectInfo.GenerateIncrementalTypeInfo) { 
            this.Write("#ifdef XAML_TYPE_INFO_INC\r\n#include XAML_TYPE_INFO_INC\r\n#endif\r\n");
  } 
            this.Write("#include \"XamlTypeInfo.g.h\"\r\n\r\n");
  if (!ProjectInfo.GenerateIncrementalTypeInfo) { 
      foreach(string includeFile in Model.AllLocalXamlHeaderFiles) 
      { 
            this.Write("#include \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(includeFile));
            this.Write("\"\r\n");
      } 
  } 
            this.Write("#include \"XamlBindingInfo.g.hpp\"\r\n");
  if (!ProjectInfo.GenerateIncrementalTypeInfo) { 
      foreach(string includeFile in Model.AllLocalHppGeneratedFiles) 
      { 
            this.Write("#include \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(includeFile));
            this.Write("\"\r\n");
      } 
  } 
  if (Model.TypeInfos.Count() > 0) 
  { 
            this.Write("\r\n");
  if (ProjectInfo.GenerateIncrementalTypeInfo) { 
      foreach(var entry in Model.TypeInfos.OrderBy(t => t.StandardName)) { 
          IncludeTemplate<CXMetadataDelegates>(entry, ProjectInfo.ClassToHeaderFileMap.ContainsKey(entry.StandardName));
      } 
  } else { 
      IncludeTemplate<CXTemplatedMetadataDelegates>(Model);
  } 
 if(!ProjectInfo.EnableTypeInfoReflection) 
 { 
            this.Write(@"
enum TypeInfo_Flags
{
    TypeInfo_Flags_None                 = 0x00,
    TypeInfo_Flags_IsLocalType          = 0x01,
    TypeInfo_Flags_IsSystemType         = 0x02,
    TypeInfo_Flags_IsReturnTypeStub     = 0x04,
    TypeInfo_Flags_IsBindable           = 0x08,
    TypeInfo_Flags_IsMarkupExtension    = 0x10, 
};

struct TypeInfo
{
    PCWSTR  typeName;
    PCWSTR contentPropertyName;
    ::Platform::Object^ (*activator)();
    void (*collectionAdd)(::Platform::Object^, ::Platform::Object^);
    void (*dictionaryAdd)(::Platform::Object^, ::Platform::Object^, ::Platform::Object^);
    ::Platform::Object^ (*fromStringConverter)(::XamlTypeInfo::InfoProvider::XamlUserType^, ::Platform::String^);
    int     baseTypeIndex;
    int     firstMemberIndex;
    int     firstEnumValueIndex;
    int     createFromStringIndex;
    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsXamlInterop)));
            this.Write("::TypeKind kindofType;\r\n    unsigned int flags;\r\n    int boxedTypeIndex;\r\n};\r\n");
  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) 
  { 
            this.Write("\r\n#pragma warning( push )\r\n#pragma warning( disable : 4973 )\r\n");
  } 
  if (Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod).Any() && !ProjectInfo.EnableTypeInfoReflection) { 
            this.Write("\r\n::XamlTypeInfo::InfoProvider::XamlUserType::CreateFromStringFn CreateFromString" +
                    "Methods[] =\r\n{\r\n");
      foreach(var entry in Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod)) { 
            this.Write("    [](::Platform::String^ value) -> ::Platform::Object^ { return ");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.CreateFromStringMethod.ResolvedName.CppCXName()));
            this.Write("(value); },\r\n");
      }
            this.Write("};\r\n");
  } 
            this.Write("\r\nconst TypeInfo TypeInfos[] = \r\n{\r\n");
  int entryIndex = 0; 
  int firstEnumValueIndex = 0; 
  int firstMemberIndex = 0; 
  int createFromStringIndex = 0; 
  foreach(var entry in Model.TypeInfos) 
  { 
      String isLocalType = entry.IsLocalType ? "TypeInfo_Flags_IsLocalType | " : "";
      String isSystemType = entry.IsSystemType ? "TypeInfo_Flags_IsSystemType | " : "";
      String isReturnTypeStub = entry.IsReturnTypeStub ? "TypeInfo_Flags_IsReturnTypeStub | " : "";
      String isBindable = entry.IsBindable ? "TypeInfo_Flags_IsBindable | " : "";
      String isMarkupExtension = entry.IsMarkupExtension ? "TypeInfo_Flags_IsMarkupExtension | " : "";
      String baseTypeIndex = entry.BaseTypeStandardName.Length > 0 ? Model.TypeInfoIndexes[entry.BaseTypeStandardName].ToString() + ", // " + entry.BaseTypeStandardName : "-1,";
      String boxedTypeIndex = entry.BoxedTypeStandardName.Length > 0 ? Model.TypeInfoIndexes[entry.BoxedTypeStandardName].ToString() + ", // " + entry.BoxedTypeStandardName : "-1,";
      String kindofType = String.Format("{0}::TypeKind::{1}", Projection(KnownNamespaces.WindowsXamlInterop), entry.IsLocalType && !ProjectInfo.IsLibrary ? "Custom" : "Metadata");
      String activator = entry.HasActivator ? $"&{entry.ActivatorName.CppCXName()}" : "nullptr";
      String collectionAdd = entry.IsCollection ? $"&{entry.CollectionAddName.CppCXName()}" : "nullptr";
      String dictionaryAdd = entry.IsDictionary ? $"&{entry.DictionaryAddName.CppCXName()}" : "nullptr";
      String fromStringConverter = entry.HasEnumValues ? $"&{entry.FromStringConverterName.CppCXName()}" : "nullptr";
      String createFromString = "-1";
      if (entry.HasCreateFromStringMethod)
      {
          createFromString = createFromStringIndex.ToString();
          createFromStringIndex++;
      }
      if (entry.HasMembers) 
      { 
          Model.TrackTypeMembers(entry, out firstMemberIndex); 
      } 
      if(entry.HasEnumValues) 
      { 
          Model.TrackTypeEnumValues(entry, out firstEnumValueIndex); 
      } 
            this.Write("    // ");
            this.Write(this.ToStringHelper.ToStringWithCulture(String.Format("{0,3}", entryIndex++)));
            this.Write("\r\n    L\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.StandardName));
            this.Write("\", L\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.ContentPropertyName));
            this.Write("\",\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(activator));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(collectionAdd));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(dictionaryAdd));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(fromStringConverter));
            this.Write(",\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeIndex));
            this.Write("\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(firstMemberIndex));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(firstEnumValueIndex));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(createFromString));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(kindofType));
            this.Write(",\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(isLocalType));
            this.Write(this.ToStringHelper.ToStringWithCulture(isSystemType));
            this.Write(this.ToStringHelper.ToStringWithCulture(isReturnTypeStub));
            this.Write(this.ToStringHelper.ToStringWithCulture(isBindable));
            this.Write(this.ToStringHelper.ToStringWithCulture(isMarkupExtension));
            this.Write("TypeInfo_Flags_None,\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(boxedTypeIndex));
            this.Write("\r\n");
      firstEnumValueIndex += entry.EnumValues.Count(); 
      firstMemberIndex += entry.Members.Count(); 
  } 
            this.Write("    //  Last type here is for padding\r\n    L\"\", L\"\",\r\n    nullptr, nullptr, nullp" +
                    "tr, nullptr,\r\n    -1, \r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(firstMemberIndex));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(firstEnumValueIndex));
            this.Write(", -1, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsXamlInterop)));
            this.Write("::TypeKind::Custom,\r\n    TypeInfo_Flags_None,\r\n};\r\n");
  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) 
  { 
            this.Write("#pragma warning( pop )\r\n");
  } 
            this.Write("\r\n");
  entryIndex = 0; 
            this.Write("const UINT TypeInfoLookup[] = { \r\n");
  foreach(var entry in Model.TypeInfoLookup) 
  { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(String.Format("{0,3},   // {1,3}", entry, entryIndex++)));
            this.Write("\r\n");
  } 
            this.Write("};\r\n\r\n");
 Output_GetTypeInfo(); 
  if (Model.EnumValues.Count() > 0) 
  { 
            this.Write("\r\nstruct EnumValueInfo\r\n{\r\n    PCWSTR name;\r\n    int eValue;\r\n};\r\n\r\nconst EnumVal" +
                    "ueInfo EnumValues[] =\r\n{ \r\n");
      foreach (var enumValue in Model.EnumValues) 
      { 
            this.Write("    L\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(enumValue.ValueName));
            this.Write("\", (int) ");
            this.Write(this.ToStringHelper.ToStringWithCulture(enumValue.TypeInfo.FullName));
            this.Write("::");
            this.Write(this.ToStringHelper.ToStringWithCulture(enumValue.ValueName));
            this.Write(",\r\n");
      } 
            this.Write("};\r\n");
  } 
  if (Model.MemberInfos.Count() > 0) 
  { 
            this.Write(@"
struct MemberInfo 
{
    PCWSTR shortName;
    ::Platform::Object^ (*getter)(::Platform::Object^);
    void (*setter)(::Platform::Object^, ::Platform::Object^);
    int typeIndex;
    int targetTypeIndex;
    bool isReadOnly;
    bool isDependencyProperty;
    bool isAttachable;
};

");
      if (Model.MemberInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) 
      { 
            this.Write("#pragma warning( push )\r\n#pragma warning( disable : 4973 )\r\n");
      } 
            this.Write("const MemberInfo MemberInfos[] = \r\n{\r\n");
      entryIndex = 0; 
      foreach(var entry in Model.MemberInfos) 
      { 
      String isReadOnly = entry.HasPublicGetter && !entry.HasPublicSetter ? "true, " : "false,"; 
      String isDependencyProperty = entry.IsDependencyProperty ? "true, " : "false,"; 
      String isAttachable = entry.IsAttachable ? "true, " : "false,"; 
      String targetTypeIndex = entry.TargetType != null ? Model.TypeInfoIndexes[entry.TargetType.StandardName].ToString() + ", // " + entry.TargetType.StandardName : "-1,";
            this.Write("    // ");
            this.Write(this.ToStringHelper.ToStringWithCulture(String.Format("{0,3}", entryIndex++)));
            this.Write(" - ");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.DeclaringType.StandardName));
            this.Write(".");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.Name));
            this.Write("\r\n    L\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.Name));
            this.Write("\",\r\n");
          if (entry.HasGetAttachableMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.GetAttachableMemberName));
            this.Write(",\r\n");
          } else if (entry.HasGetValueTypeMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.GetValueTypeMemberName));
            this.Write(",\r\n");
          } else if (entry.HasGetReferenceTypeMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.GetReferenceTypeMemberName));
            this.Write(",\r\n");
          } else { 
            this.Write("    nullptr,\r\n");
          } 
          if (entry.HasSetAttachableMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.SetAttachableMemberName));
            this.Write(",\r\n");
          } else if (entry.HasSetEnumMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.SetEnumMemberName));
            this.Write(",\r\n");
          } else if (entry.HasSetValueTypeMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.SetValueTypeMemberName));
            this.Write(",\r\n");
          } else if (entry.HasSetReferenceTypeMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.SetReferenceTypeMemberName));
            this.Write(",\r\n");
          } else { 
            this.Write("    nullptr,\r\n");
          } 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Model.TypeInfoIndexes[entry.Type.StandardName]));
            this.Write(", // ");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.Type.StandardName));
            this.Write("\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(targetTypeIndex));
            this.Write("\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(isReadOnly));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(isDependencyProperty));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(isAttachable));
            this.Write("\r\n");
      } 
            this.Write("};\r\n");
      if (Model.MemberInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) 
      { 
            this.Write("#pragma warning( pop )\r\n");
      } 
            this.Write("\r\nPCWSTR GetShortName(PCWSTR longName)\r\n{\r\n    PCWSTR separator = wcsrchr(longNam" +
                    "e, \'.\');\r\n    return separator != nullptr ? separator + 1: longName;\r\n}\r\n\r\n");
  } 
  if (Model.MemberInfos.Count() > 0) 
  { 
            this.Write(@"
const MemberInfo* GetMemberInfo(::Platform::String^ longMemberName)
{
    auto lastDotIndex = longMemberName->Length();
    while (true)
    {
        if (longMemberName->Data()[lastDotIndex] == '.')
        {
            const TypeInfo* pTypeInfo = GetTypeInfo(ref new ::Platform::String(longMemberName->Data(), lastDotIndex));
            const TypeInfo* pNextTypeInfo = pTypeInfo + 1;
            if (pTypeInfo)
            {
                PCWSTR shortMemberName = GetShortName(longMemberName->Data());
                for (int i = pTypeInfo->firstMemberIndex; i < pNextTypeInfo->firstMemberIndex; i++)
                {
                    if (wcscmp(shortMemberName, MemberInfos[i].shortName) == 0)
                    {
                        return &MemberInfos[i];
                    }
                }
            }
            break;
        }
        if (lastDotIndex == 0)
        {
            break;
        }
        lastDotIndex--;
    }
    return nullptr;
}
");
  } 
 } //End EnableTypeInfoReflection disabled block 
 else 
 { 
            this.Write("\r\nstruct TypeInfo\r\n{\r\n    PCWSTR  typeName;\r\n    ::Platform::Object^ (*activator)" +
                    "();\r\n};\r\n");
  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) 
  { 
            this.Write("\r\n#pragma warning( push )\r\n#pragma warning( disable : 4973 )\r\n");
  } 
  if (Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod).Any()) { 
            this.Write("\r\n::XamlTypeInfo::InfoProvider::XamlUserType::CreateFromStringFn CreateFromString" +
                    "Methods[] =\r\n{\r\n");
      foreach(var entry in Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod)) { 
            this.Write("    [](::Platform::String^ value) -> ::Platform::Object^ { return ");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.CreateFromStringMethod.ResolvedName.CppCXName()));
            this.Write("(value); },\r\n");
      }
            this.Write("};\r\n");
  } 
            this.Write("\r\nconst TypeInfo TypeInfos[] = \r\n{\r\n");
  int entryIndex = 0; 
  foreach(var entry in Model.TypeInfos) 
  { 
      String activator = entry.HasActivator ? $"&{entry.ActivatorName.CppCXName()}" : "nullptr";
            this.Write("    // ");
            this.Write(this.ToStringHelper.ToStringWithCulture(String.Format("{0,3}", entryIndex++)));
            this.Write("\r\n    L\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.StandardName));
            this.Write("\", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(activator));
            this.Write(",\r\n");
  } 
            this.Write("    //  Last type here is for padding\r\n    L\"\", nullptr\r\n};\r\n");
  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) 
  { 
            this.Write("#pragma warning( pop )\r\n");
  } 
            this.Write("\r\n");
  entryIndex = 0; 
            this.Write("const UINT TypeInfoLookup[] = { \r\n");
  foreach(var entry in Model.TypeInfoLookup) 
  { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(String.Format("{0,3},   // {1,3}", entry, entryIndex++)));
            this.Write("\r\n");
  } 
            this.Write("};\r\n");
 Output_GetTypeInfo(); 
 } // End of EnableTypeInfoReflection enabled
  } // if (Model.TypeInfos.Count() > 0) 
  if (ProjectInfo.GenerateOtherProvidersForCX  || !ProjectInfo.GenerateProviderCode) { 
            this.Write("\r\n#pragma warning(push)\r\n#pragma warning(disable: 4691)\r\n::Platform::Collections:" +
                    ":Vector<");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));
            this.Write(@"::IXamlMetadataProvider^>^ ::XamlTypeInfo::InfoProvider::XamlTypeInfoProvider::OtherProviders::get()
{
    auto lock = _xamlTypesCriticalSection.Lock();
    if(_otherProviders == nullptr)
    {
        auto otherProviders = ref new ::Platform::Collections::Vector<");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));
            this.Write("::IXamlMetadataProvider^>();\r\n");
                  if (ProjectInfo.GenerateProviderCode) 
                  { 
                      if(SchemaInfo.OtherMetadataProviders.Any()) 
                      { 
            this.Write("        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));
            this.Write("::IXamlMetadataProvider^ provider;\r\n");
                          foreach(var xmp in SchemaInfo.OtherMetadataProviders) 
                          { 
            this.Write("        provider = ref new ");
            this.Write(this.ToStringHelper.ToStringWithCulture(xmp.FullName));
            this.Write("();\r\n        otherProviders->Append(provider); \r\n");
                          } 
                      } 
                  } 
            this.Write("        _otherProviders = otherProviders;\r\n    }\r\n    return _otherProviders;\r\n}\r" +
                    "\n#pragma warning(pop)\r\n");
  } 
            this.Write("\r\n");
 if(ProjectInfo.EnableTypeInfoReflection) 
 { 
            this.Write("::XamlTypeInfo::InfoProvider::XamlActivatableType^ ::XamlTypeInfo::InfoProvider::" +
                    "XamlTypeInfoProvider::GetActivatableTypeForTypeName(::Platform::String^ typeName" +
                    ")\r\n{\r\n");
  if(!Model.TypeInfos.Any()) 
  { 
            this.Write("    // No Local Types\r\n    (void)typeName; // Unused parameter\r\n    return nullpt" +
                    "r;\r\n");
  } 
  else
  { 
            this.Write(@"    const TypeInfo* pTypeInfo = GetTypeInfo(typeName);
    const TypeInfo* pNextTypeInfo = pTypeInfo + 1;
    if (pTypeInfo == nullptr || pNextTypeInfo == nullptr)
    {
        return nullptr;
    }
    else
    {
        auto activatableType = ref new XamlTypeInfo::InfoProvider::XamlActivatableType();
        activatableType->Activator = pTypeInfo->activator;
        return activatableType;
    }
");
 } 
            this.Write("}\r\n");
 } 
 else 
 { 
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));
            this.Write("::IXamlType^ ::XamlTypeInfo::InfoProvider::XamlTypeInfoProvider::CreateXamlType(:" +
                    ":Platform::String^ typeName)\r\n{\r\n");
  if(!Model.TypeInfos.Any()) 
  { 
            this.Write("    // No Local Types\r\n    (void)typeName; // Unused parameter\r\n    return nullpt" +
                    "r;\r\n");
  } 
  else
  { 
            this.Write("    const TypeInfo* pTypeInfo = GetTypeInfo(typeName);\r\n    const TypeInfo* pNext" +
                    "TypeInfo = pTypeInfo + 1;\r\n    if (pTypeInfo == nullptr || pNextTypeInfo == null" +
                    "ptr)\r\n    {\r\n        return nullptr;\r\n    }\r\n    else if (pTypeInfo->flags & Typ" +
                    "eInfo_Flags_IsSystemType)\r\n    {\r\n        return ref new ::XamlTypeInfo::InfoPro" +
                    "vider::XamlSystemBaseType(typeName);\r\n    }\r\n    else\r\n    {\r\n        ::XamlType" +
                    "Info::InfoProvider::XamlUserType^ userType = ref new ::XamlTypeInfo::InfoProvide" +
                    "r::XamlUserType(\r\n            this, \r\n            ::Platform::StringReference(pT" +
                    "ypeInfo->typeName), \r\n            this->GetXamlTypeByName(::Platform::StringRefe" +
                    "rence(pTypeInfo->baseTypeIndex >= 0 ? TypeInfos[pTypeInfo->baseTypeIndex].typeNa" +
                    "me : L\"\")));\r\n        userType->KindOfType = pTypeInfo->kindofType;\r\n        use" +
                    "rType->Activator = pTypeInfo->activator;\r\n        userType->CollectionAdd = pTyp" +
                    "eInfo->collectionAdd;\r\n        userType->DictionaryAdd = pTypeInfo->dictionaryAd" +
                    "d;\r\n        userType->FromStringConverter = pTypeInfo->fromStringConverter;\r\n   " +
                    "     userType->ContentPropertyName = ::Platform::StringReference(pTypeInfo->cont" +
                    "entPropertyName);\r\n        userType->IsLocalType = pTypeInfo->flags & TypeInfo_F" +
                    "lags_IsLocalType;\r\n        userType->IsReturnTypeStub = pTypeInfo->flags & TypeI" +
                    "nfo_Flags_IsReturnTypeStub;\r\n        userType->IsBindable = pTypeInfo->flags & T" +
                    "ypeInfo_Flags_IsBindable;\r\n        userType->IsMarkupExtension = pTypeInfo->flag" +
                    "s & TypeInfo_Flags_IsMarkupExtension;\r\n        userType->CreateFromStringMethod " +
                    "= nullptr;\r\n");
  if (Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod).Any()) { 
            this.Write("        if (pTypeInfo->createFromStringIndex != -1)\r\n        {\r\n            userT" +
                    "ype->CreateFromStringMethod = CreateFromStringMethods[pTypeInfo->createFromStrin" +
                    "gIndex];\r\n        }\r\n");
 } 
            this.Write("        userType->SetBoxedType(this->GetXamlTypeByName(::Platform::StringReferenc" +
                    "e(pTypeInfo->boxedTypeIndex >= 0 ? TypeInfos[pTypeInfo->boxedTypeIndex].typeName" +
                    " : L\"\")));\r\n");
  if (Model.MemberInfos.Count() > 0) 
  { 
            this.Write(@"        int nextMemberIndex = pTypeInfo->firstMemberIndex;
        for (int i=pTypeInfo->firstMemberIndex; i < pNextTypeInfo->firstMemberIndex; i++)
        {
            userType->AddMemberName(::Platform::StringReference(MemberInfos[i].shortName));
            nextMemberIndex++;
        }
");
  } 
  if (Model.EnumValues.Count() > 0) 
  { 
            this.Write(@"        for (int i = pTypeInfo->firstEnumValueIndex; i < pNextTypeInfo->firstEnumValueIndex; i++)
        {
            userType->AddEnumValue(
                ::Platform::StringReference(EnumValues[i].name),
                ::Windows::Foundation::PropertyValue::CreateInt32(EnumValues[i].eValue));
        }
");
  } 
            this.Write("        return userType;\r\n    }\r\n");
  } 
            this.Write("}\r\n\r\n");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));
            this.Write("::IXamlMember^ ::XamlTypeInfo::InfoProvider::XamlTypeInfoProvider::CreateXamlMemb" +
                    "er(::Platform::String^ longMemberName)\r\n{\r\n    ::XamlTypeInfo::InfoProvider::Xam" +
                    "lMember^ xamlMember = nullptr;\r\n");
  if (!Model.MemberInfos.Any()) 
  { 
            this.Write("    // No Local Properties\r\n    (void)longMemberName; // Unused parameter\r\n");
  } 
  else
  { 
            this.Write(@"    const MemberInfo* pMemberInfo = GetMemberInfo(longMemberName);
    if (pMemberInfo != nullptr)
    {
        xamlMember = ref new ::XamlTypeInfo::InfoProvider::XamlMember(
            this,
            ::Platform::StringReference(pMemberInfo->shortName),
            ::Platform::StringReference(TypeInfos[pMemberInfo->typeIndex].typeName));
        xamlMember->Getter = pMemberInfo->getter;
        xamlMember->Setter = pMemberInfo->setter;
        xamlMember->TargetTypeName = pMemberInfo->targetTypeIndex >= 0 ? ::Platform::StringReference(TypeInfos[pMemberInfo->targetTypeIndex].typeName) : L"""";
        xamlMember->IsReadOnly = pMemberInfo->isReadOnly;
        xamlMember->IsDependencyProperty = pMemberInfo->isDependencyProperty;
        xamlMember->IsAttachable = pMemberInfo->isAttachable;
    }
");
  } 
            this.Write("    return xamlMember;\r\n}\r\n");
 } 
            return this.GenerationEnvironment.ToString();
        }
     private void Output_GetTypeInfo() 
     { 
this.Write(@"const TypeInfo* GetTypeInfo(::Platform::String^ typeName)
{
    auto typeNameLength = typeName->Length();
    if (typeNameLength < _countof(TypeInfoLookup) - 1)
    {
        for (UINT i = TypeInfoLookup[typeNameLength]; i < TypeInfoLookup[typeNameLength+1]; i++)
        {
            if (typeName == ::Platform::StringReference(TypeInfos[i].typeName))
            {
                return &TypeInfos[i];
            }
        }
    }
    return nullptr;
}
");

     } 
    }
}
