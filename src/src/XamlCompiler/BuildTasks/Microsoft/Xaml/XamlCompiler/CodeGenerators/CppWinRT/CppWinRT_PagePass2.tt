<#@ template language="C#" inherits="CppWinRT_CodeGenerator<PageDefinition>" visibility="internal" linePragmas="false"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xaml" #>
<#@ import namespace="Microsoft.UI.Xaml.Markup.Compiler.Properties" #>
<#@ import namespace="Microsoft.UI.Xaml.Markup.Compiler.Utilities" #>

//------------------------------------------------------------------------------
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//------------------------------------------------------------------------------
<#  if(!String.IsNullOrEmpty(ProjectInfo.PrecompiledHeaderFile)) { #>
#include "<#=ProjectInfo.PrecompiledHeaderFile#>"
<#  }#>
<#  foreach (var includeFile in Model.NeededLocalXamlHeaderFiles) { #>
#include "<#=includeFile#>"
<#  }#>

#pragma warning(push)
#pragma warning(disable: 4100) // unreferenced formal parameter

namespace winrt::<#=Colonize(Model.CodeInfo.ClassName.Namespace)#>::implementation
{

<#  if (Model.CodeInfo.IsUsingCompiledBinding && Model.CodeInfo.BindUniverses.Any(bu => bu.BindAssignments.Any(ba => ba.HasSetValueHelper))) { #>
<#      if (ProjectInfo.GenerateCppWinRTStaticAsserts) { #>

    namespace <#=Colonize(Model.CodeInfo.ClassName.ShortName)#>_staticasserts
    {
        template<typename, typename = void>
        constexpr bool is_type_complete_v = false;

        template<typename T>
        constexpr bool is_type_complete_v<T, std::void_t<decltype(sizeof(T))>> = true;

<#          foreach (var bindUniverse in Model.CodeInfo.BindUniverses) { #>
<#              var distinctAsignmentsByMember = from ba in bindUniverse.BindAssignments.Where(ba => ba.HasSetValueHelper) group ba by ba.MemberFullName; #>
<#              foreach (var item in distinctAsignmentsByMember) { #>
<#                  Output_StaticAssertTypeIsComplete(item.First().MemberType, Indent.TwoTabs); #>
<#                  Output_StaticAssertTypeIsComplete(item.First().MemberDeclaringType, Indent.TwoTabs); #>
<#              } #>
<#          } #>

    }

<#      } #>
<#  } #>

    using Application = <#=Projection(KnownNamespaces.Xaml)#>::Application;
    using ComponentResourceLocation = <#=Projection(KnownNamespaces.XamlControlsPrimitives)#>::ComponentResourceLocation;
    using DataTemplate = <#=Projection(KnownNamespaces.Xaml)#>::DataTemplate;
    using DependencyObject = <#=Projection(KnownNamespaces.Xaml)#>::DependencyObject;
    using DependencyProperty = <#=Projection(KnownNamespaces.Xaml)#>::DependencyProperty;
    using IComponentConnector = <#=Projection(KnownNamespaces.XamlMarkup)#>::IComponentConnector;
    using Uri = <#=Projection(KnownNamespaces.WindowsFoundation)#>::Uri;
    using XamlBindingHelper = <#=Projection(KnownNamespaces.XamlMarkup)#>::XamlBindingHelper;

<#  if (Model.ApiInformationDeclarations.Any()) { #>
    // Api Information for conditional namespace declarations
<#      foreach (var apiInformation in Model.ApiInformationDeclarations) { #>
    bool <#=Model.CodeInfo.ClassName.ShortName#>_<#= apiInformation.MemberFriendlyName #>;
<#      } #>

<#  } #>
<# Output_InitializeComponent(); #>

<# Output_ConnectMethod(); #>

<#   if (Model.UnloadableFields.Count() > 0) { #>
<#        Output_UnloadMethods(); #>
<#   } else { #>
<#        Output_EmptyUnloadMethods(); #>
<#   } #>

<# if (Model.CodeInfo.BindStatus != BindStatus.None) { #>
<#      Output_GetBindingConnectorMethod(); #>
<# } else { #>
<#      Output_EmptyGetBindingConnectorMethod(); #>
<# } #>
<#  if (Model.CodeInfo.IsUsingCompiledBinding) { #>
<#      foreach (BindUniverse bindUniverse in Model.CodeInfo.BindUniverses) { #>
<#          if (bindUniverse.NeedsCppBindingTrackingClass) { #>

<#          IncludeTemplate<CppWinRT_PageBindingTracking>(Model, bindUniverse); #>
<#          } #>

<#          IncludeTemplate<CppWinRT_PageBinding>(Model, bindUniverse); #>
<#      }#>
<# } #>

    template struct <#=Model.CodeInfo.ClassName.ShortName#>T<struct <#=Model.CodeInfo.ClassName.ShortName#>>;
}

<# if (ProjectInfo.GenerateIncrementalTypeInfo) { #>

namespace winrt::<#=Colonize(ProjectInfo.RootNamespace)#>::implementation
{
<#      foreach(var entry in Model.TypeInfos.Where(t => t.StandardName == Model.CodeInfo.ClassType.StandardName)) { #>
<#        IncludeTemplate<CppWinRT_MetadataDelegates>(entry, false); #>
<#      } #>
}
<#  } #>

#pragma warning(pop)

<#+ private void Output_InitializeComponent() { #>
<#+     string defaultUri = Model.GetLoadComponentUri(Model.CodeInfo.PriIndexName, Model.CodeInfo.BaseApparentRelativePath);#>
<#+     string loadType = !String.IsNullOrEmpty(Model.CodeInfo.XamlComponentResourceLocation) ? Model.CodeInfo.XamlComponentResourceLocation : (ProjectInfo.IsLibrary ? "Nested" : "Application"); #>
    template <typename D, typename ... I>
    void <#=Model.CodeInfo.ClassName.ShortName#>T<D, I...>::InitializeComponent()
    {
<#+     if(Model.CodeInfo.PerXamlFileInfo.Count > 1) { #>
        InitializeComponent(Uri(L"<#=defaultUri#>"));
    }

    template <typename D, typename ... I>
    void <#=Model.CodeInfo.ClassName.ShortName#>T<D, I...>::InitializeComponent(Uri const& resourceLocator)
    {
<#+     }#>
        if (!_contentLoaded)
        {
            _contentLoaded = true;
<#+     if (Model.ApiInformationDeclarations.Any()) { #>

<#+         foreach (var apiInformation in Model.ApiInformationDeclarations) { #>
            <#=Model.CodeInfo.ClassName.ShortName#>_<#= apiInformation.MemberFriendlyName #> = <#= apiInformation.CodeGen().CallExpression #>;
<#+         } #> 
<#+     } #>
<#+     if(Model.CodeInfo.PerXamlFileInfo.Count <= 1) { #>
            ::winrt::Windows::Foundation::Uri resourceLocator{ L"<#=defaultUri#>" };
<#+     } #>
            <#=Projection(KnownNamespaces.Xaml)#>::Application::LoadComponent(*this, resourceLocator, ComponentResourceLocation::<#=loadType#>);
        }
    }
<#+ } #>

<#+ private void Output_ConnectMethod()#>
<#+ {#>
<#+     if (Model.ConnectableElements.Any()) { #>
    template <typename D, typename ... I>
    void <#=Model.CodeInfo.ClassName.ShortName#>T<D, I...>::Connect(int32_t connectionId, IInspectable const& target)
    {
<#+         if(Model.ConnectableElements.Any()) { #>
        switch (connectionId)
        {
<#+             foreach (var element in Model.ConnectableElements) { #>
        case <#=element.ConnectionId#>:
            {
<#+                 Output_ConnectionId_Case(element); #>
            }
            break;
<#+             }#>
        }
<#+         }#>
<#+     } else { #>
    template <typename D, typename... I>
    void <#=Model.CodeInfo.ClassName.ShortName#>T<D, I...>::Connect(int32_t, IInspectable const&)
    {
<#+     } #>
        _contentLoaded = true;
    }
<#+ }#>

<#+ private void Output_EmptyUnloadMethods()#>
<#+ {#>
    template <typename D, typename ... I>
    void <#=Model.CodeInfo.ClassName.ShortName#>T<D, I...>::DisconnectUnloadedObject(int32_t)
    {
        throw ::winrt::hresult_invalid_argument { L"No unloadable objects to disconnect." };
    }

    template <typename D, typename ... I>
    void <#=Model.CodeInfo.ClassName.ShortName#>T<D, I...>::UnloadObject(DependencyObject const&)
    {
        throw ::winrt::hresult_invalid_argument { L"No unloadable objects." };
    }
<#+ } #>

<#+ private void Output_UnloadMethods()#>
<#+ {#>
    template <typename D, typename ... I>
    void <#=Model.CodeInfo.ClassName.ShortName#>T<D, I...>::UnloadObject(DependencyObject const& unloadableObject)
    {
        if (unloadableObject)
        {
<#+         foreach (var element in Model.UnloadableFields) { #>
            // <#=element.LineNumberAndXamlFile#>
<#+             Output_ApiInformationCall_Push(element.ApiInformation, Indent.OneTab); #>
            if (unloadableObject == <#=element.ElementName#>())
            {
                DisconnectUnloadedObject(<#=element.ConnectionId#>);
            }
<#+             Output_ApiInformationCall_Pop(element.ApiInformation, Indent.OneTab); #>
<#+         } #>
            <#=Projection(KnownNamespaces.XamlMarkup)#>::XamlMarkupHelper::UnloadObject(unloadableObject);
        }
    }

    template <typename D, typename ... I>
    void <#=Model.CodeInfo.ClassName.ShortName#>T<D, I...>::DisconnectUnloadedObject(int32_t connectionId)
    {
        switch(connectionId)
        {
<#+         foreach (var element in Model.DeferrableElements)#>
<#+         {#>
            case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
            {
<#+             foreach (var childElem in element.Children) #>
<#+             {#>
<#+                 if (childElem.HasFieldDefinition) #>
<#+                 {#>
                DisconnectUnloadedObject(<#=childElem.ConnectionId#>);
<#+                 }#>
<#+                 if (childElem.HasBindAssignments || element.HasRootNamedElementStep) #>
<#+                 {#>
                Bindings->DisconnectUnloadedObject(<#=childElem.ConnectionId#>);
<#+                 }#>
<#+             }#>
<#+             if (element.HasBindAssignments || element.HasRootNamedElementStep) #>
<#+             {#>
                Bindings->DisconnectUnloadedObject(<#=element.ConnectionId#>);
<#+             }#>
<#+             FieldDefinition fieldInfo = element.FieldDefinition; #>
<#+             if(fieldInfo != null) #>
<#+             { #>
<#+                 Output_ApiInformationCall_Push(element.ApiInformation, Indent.TwoTabs); #>
                <#=fieldInfo.FieldName#>(nullptr);
<#+                 Output_ApiInformationCall_Pop(element.ApiInformation, Indent.TwoTabs); #>
<#+             } #>
                break;
            }
<#+         }#>
            default:
            {
                throw hresult_invalid_argument(L"Invalid connectionId.");
            }
        }
    }
<#+ }#>

<#+ private void Output_ConnectionId_Case(ConnectionIdElement element)#>
<#+ {#>
<#+     string objectName = element.ElementCodeName;#>
<#+     Output_PushDeprecated(element.Type.IsDeprecated()); #>
<#+     Output_ApiInformationCall_Push(element.ApiInformation, Indent.TwoTabs); #>
                auto targetElement = target.as<<#=element.Type#>>();
<#+     if (element.HasFieldDefinition) {#>
<#+         objectName = $"{element.FieldDefinition.FieldName}()"; #>
                this-><#=element.FieldDefinition.FieldName#>(targetElement);
<#+     }#>
<#+     if (element.EventAssignments.Any()) { #>
                auto weakThis = ::winrt::make_weak<class_type>(*this);
<#+     } #>
<#+     foreach (EventAssignment ev in element.EventAssignments) { #>
<#+         Output_ApiInformationCall_Push(ev.ApiInformation, Indent.TwoTabs); #>
                targetElement.<#=ev.EventName#>([weakThis](<#=ev.Parameters.Declaration()#>){
                    if (auto t = weakThis.get())
                    {
                        ::winrt::get_self<D>(t)-><#=ev.HandlerName#>(<#=ev.Parameters.ForCall()#>);
                    }
                });
<#+         Output_ApiInformationCall_Pop(ev.ApiInformation, Indent.TwoTabs); #>
<#+     } #>
<#+     Output_ApiInformationCall_Pop(element.ApiInformation, Indent.TwoTabs); #>
<#+     Output_PopDeprecated(element.Type.IsDeprecated()); #>
<#+ }#>

<#+ private void Output_EmptyGetBindingConnectorMethod()#>
<#+ {#>

    template <typename D, typename... I>
    IComponentConnector <#=Model.CodeInfo.ClassName.ShortName#>T<D, I...>::GetBindingConnector(int32_t, IInspectable const&)
    {
        return nullptr;
    }
<#+ } #>

<#+ private void Output_GetBindingConnectorMethod()#>
<#+ {#>
    template <typename D, typename... I>
    IComponentConnector <#=Model.CodeInfo.ClassName.ShortName#>T<D, I...>::GetBindingConnector(int32_t connectionId, IInspectable const& target)
    {
        ::winrt::com_ptr<<#=Projection(ProjectInfo.RootNamespace)#>::implementation::XamlBindings> bindings;
        switch (connectionId)
        {
<#+     foreach (var element in Model.AllConnectionIdElements) { #>
<#+         if (element.IsBindingRoot) { #>
            case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
                {
<#+             Output_PushDeprecated(element.Type.IsDeprecated());#>
<#+                 if (element.Type.IsDerivedFromControlTemplate()) #>
<#+                 {#>
                    if (auto <#=element.ElementTemplatedParentCodeName#> = target.try_as<<#=element.TemplatedParentType#>>())
                    {
                        auto objBindings = std::make_unique<<#=element.BindUniverse.BindingsClassName#>>();
                        objBindings->SetDataRoot(<#=element.ElementTemplatedParentCodeName#>);
                        bindings = ::winrt::make_self<<#=Projection(ProjectInfo.RootNamespace)#>::implementation::XamlBindings>(std::move(objBindings));
                        XamlBindingHelper::SetDataTemplateComponent(<#=element.ElementTemplatedParentCodeName#>, bindings.as<<#=Projection(KnownNamespaces.XamlMarkup)#>::IDataTemplateComponent>());
                    }
<#+                 } else {#>
                    auto <#=element.ElementCodeName#> = target.as<<#=element.Type#>>();
                    auto objBindings = std::make_unique<<#=element.BindUniverse.BindingsClassName#>>();
                    objBindings->SetDataRoot(<#=element.IsBindingFileRoot ? "*this" : element.ElementCodeName + ".DataContext()"#>);
<#+                     if (element.BindUniverse.DistinctConvertersUsed.Count() > 0) { #>
                    objBindings->SetConverterLookupRoot(*this);
<#+                     }#>
                    bindings = ::winrt::make_self<<#=Projection(ProjectInfo.RootNamespace)#>::implementation::XamlBindings>(std::move(objBindings));
<#+                     if (element.IsBindingFileRoot) { #>
                    Bindings = bindings;
<#+                         if (element.Type.IsDerivedFromWindow()) { #>
                    <#=element.ElementCodeName#>.Activated({&*bindings, &<#=Projection(ProjectInfo.RootNamespace)#>::implementation::XamlBindings::Activated});
<#+                         } #>
<#+                         else { #>
                    <#=element.ElementCodeName#>.Loading({&*bindings, &<#=Projection(ProjectInfo.RootNamespace)#>::implementation::XamlBindings::Loading});
<#+                         } #>
<#+                     } else { #>
                    bindings->SubscribeForDataContextChanged(<#=element.ElementCodeName#>);
                    DataTemplate::SetExtensionInstance(<#=element.ElementCodeName#>, bindings.as<<#=Projection(KnownNamespaces.Xaml)#>::IDataTemplateExtension>());
                    XamlBindingHelper::SetDataTemplateComponent(<#=element.ElementCodeName#>, bindings.as<<#=Projection(KnownNamespaces.XamlMarkup)#>::IDataTemplateComponent>());
<#+                     }#>
<#+                 }#>
<#+                 Output_PopDeprecated(element.Type.IsDeprecated()); #>
                }
                break;
<#+             }#>
<#+         }#>
        }
        return bindings ? bindings.as<<#=Projection(KnownNamespaces.XamlMarkup)#>::IComponentConnector>() : nullptr;
    }
<#+ }#>

<#+     private void Output_PushDeprecated(bool isDeprecated)#>
<#+     {#>
<#+         if (isDeprecated) #>
<#+         { #>
#pragma warning( push )
#pragma warning( disable : 4973 )
<#+         } #>
<#+     }#>

<#+     private void Output_PopDeprecated(bool isDeprecated)#>
<#+     {#>
<#+         if (isDeprecated) #>
<#+         { #>
#pragma warning( pop )
<#+         } #>
<#+     }#>

<#+ private void Output_ApiInformationCall_Push(ApiInformation apiInformation, Indent indent)#>
<#+ {#>
<#+     if (apiInformation != null) { #>
<#+         PushIndent(indent); #>
        if (<#=Model.CodeInfo.ClassName.ShortName#>_<#= apiInformation.MemberFriendlyName #>)
        {
<#+         PopIndent(); #>
<#+         PushIndent(); #>
<#+     } #>
<#+ } #>

<#+ private void Output_ApiInformationCall_Pop(ApiInformation apiInformation, Indent indent)#>
<#+ {#>
<#+     if (apiInformation != null) { #>
<#+         PopIndent(); #>
<#+         PushIndent(indent); #>
        }
<#+         PopIndent(); #>
<#+     } #>
<#+ } #>

<#+ HashSet<XamlType> staticAssertTypes = new HashSet<XamlType>();#>

<#+ private void Output_StaticAssertTypeIsComplete(XamlType type, Indent indent = Indent.None)#>
<#+ {#>
<#+     if(!XamlSchemaCodeInfo.IsProjectedPrimitiveCppType(type.ToString()) && !type.IsArray && !staticAssertTypes.Contains(type))#>
<#+     {#>
<#+         staticAssertTypes.Add(type);#>
<#+         PushIndent(indent);#>
<#+         if(!String.IsNullOrEmpty(ProjectInfo.PrecompiledHeaderFile))#>
<#+         {#>
static_assert( is_type_complete_v<<#=type#>>, "<#=ResourceUtilities.FormatString(XamlCompilerResources.XamlCompiler_CodeGenStaticAssert_IncompleteType, this.ToStringHelper.ToStringWithCulture(type), ProjectInfo.PrecompiledHeaderFile)#>" );
<#+         }#>
<#+         else#>
<#+         {#>
static_assert( is_type_complete_v<<#=type#>>, "<#=ResourceUtilities.FormatString(XamlCompilerResources.XamlCompiler_CodeGenStaticAssert_IncompleteType_NoPch, this.ToStringHelper.ToStringWithCulture(type))#>" );
<#+         }#>
<#+         PopIndent();#>
<#+     }#>
<#+ }#>
