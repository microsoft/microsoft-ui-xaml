<#@ template language="C#" inherits="CppCX_CodeGenerator<TypeInfoDefinition>" visibility="internal" linePragmas="false"#>
<#@ assembly name="System.Core"#>
<#@ import namespace="System.Linq" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<#  if(!String.IsNullOrEmpty(ProjectInfo.PrecompiledHeaderFile)) { #>
#include "<#=ProjectInfo.PrecompiledHeaderFile#>"
<#  }#>
<#  if (ProjectInfo.GenerateIncrementalTypeInfo) { #>
#ifdef XAML_TYPE_INFO_INC
#include XAML_TYPE_INFO_INC
#endif
<#  } #>
#include "XamlTypeInfo.g.h"

<#  if (!ProjectInfo.GenerateIncrementalTypeInfo) { #>
<#      foreach(string includeFile in Model.AllLocalXamlHeaderFiles) #>
<#      { #>
#include "<#=includeFile#>"
<#      } #>
<#  } #>
#include "XamlBindingInfo.g.hpp"
<#  if (!ProjectInfo.GenerateIncrementalTypeInfo) { #>
<#      foreach(string includeFile in Model.AllLocalHppGeneratedFiles) #>
<#      { #>
#include "<#=includeFile#>"
<#      } #>
<#  } #>
<#  if (Model.TypeInfos.Count() > 0) #>
<#  { #>

<#  if (ProjectInfo.GenerateIncrementalTypeInfo) { #>
<#      foreach(var entry in Model.TypeInfos.OrderBy(t => t.StandardName)) { #>
<#          IncludeTemplate<CXMetadataDelegates>(entry, ProjectInfo.ClassToHeaderFileMap.ContainsKey(entry.StandardName));#>
<#      } #>
<#  } else { #>
<#      IncludeTemplate<CXTemplatedMetadataDelegates>(Model);#>
<#  } #>
<# if(!ProjectInfo.EnableTypeInfoReflection) #>
<# { #>

enum TypeInfo_Flags
{
    TypeInfo_Flags_None                 = 0x00,
    TypeInfo_Flags_IsLocalType          = 0x01,
    TypeInfo_Flags_IsSystemType         = 0x02,
    TypeInfo_Flags_IsReturnTypeStub     = 0x04,
    TypeInfo_Flags_IsBindable           = 0x08,
    TypeInfo_Flags_IsMarkupExtension    = 0x10, 
};

struct TypeInfo
{
    PCWSTR  typeName;
    PCWSTR contentPropertyName;
    ::Platform::Object^ (*activator)();
    void (*collectionAdd)(::Platform::Object^, ::Platform::Object^);
    void (*dictionaryAdd)(::Platform::Object^, ::Platform::Object^, ::Platform::Object^);
    ::Platform::Object^ (*fromStringConverter)(::XamlTypeInfo::InfoProvider::XamlUserType^, ::Platform::String^);
    int     baseTypeIndex;
    int     firstMemberIndex;
    int     firstEnumValueIndex;
    int     createFromStringIndex;
    <#=Projection(KnownNamespaces.WindowsXamlInterop)#>::TypeKind kindofType;
    unsigned int flags;
    int boxedTypeIndex;
};
<#  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
<#  { #>

#pragma warning( push )
#pragma warning( disable : 4973 )
<#  } #>
<#  if (Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod).Any() && !ProjectInfo.EnableTypeInfoReflection) { #>

::XamlTypeInfo::InfoProvider::XamlUserType::CreateFromStringFn CreateFromStringMethods[] =
{
<#      foreach(var entry in Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod)) { #>
    [](::Platform::String^ value) -> ::Platform::Object^ { return <#=entry.CreateFromStringMethod.ResolvedName.CppCXName()#>(value); },
<#      }#>
};
<#  } #>

const TypeInfo TypeInfos[] = 
{
<#  int entryIndex = 0; #>
<#  int firstEnumValueIndex = 0; #>
<#  int firstMemberIndex = 0; #>
<#  int createFromStringIndex = 0; #>
<#  foreach(var entry in Model.TypeInfos) #>
<#  { #>
<#      String isLocalType = entry.IsLocalType ? "TypeInfo_Flags_IsLocalType | " : "";#>
<#      String isSystemType = entry.IsSystemType ? "TypeInfo_Flags_IsSystemType | " : "";#>
<#      String isReturnTypeStub = entry.IsReturnTypeStub ? "TypeInfo_Flags_IsReturnTypeStub | " : "";#>
<#      String isBindable = entry.IsBindable ? "TypeInfo_Flags_IsBindable | " : "";#>
<#      String isMarkupExtension = entry.IsMarkupExtension ? "TypeInfo_Flags_IsMarkupExtension | " : "";#>
<#      String baseTypeIndex = entry.BaseTypeStandardName.Length > 0 ? Model.TypeInfoIndexes[entry.BaseTypeStandardName].ToString() + ", // " + entry.BaseTypeStandardName : "-1,";#>
<#      String boxedTypeIndex = entry.BoxedTypeStandardName.Length > 0 ? Model.TypeInfoIndexes[entry.BoxedTypeStandardName].ToString() + ", // " + entry.BoxedTypeStandardName : "-1,";#>
<#      String kindofType = String.Format("{0}::TypeKind::{1}", Projection(KnownNamespaces.WindowsXamlInterop), entry.IsLocalType && !ProjectInfo.IsLibrary ? "Custom" : "Metadata");#>
<#      String activator = entry.HasActivator ? $"&{entry.ActivatorName.CppCXName()}" : "nullptr";#>
<#      String collectionAdd = entry.IsCollection ? $"&{entry.CollectionAddName.CppCXName()}" : "nullptr";#>
<#      String dictionaryAdd = entry.IsDictionary ? $"&{entry.DictionaryAddName.CppCXName()}" : "nullptr";#>
<#      String fromStringConverter = entry.HasEnumValues ? $"&{entry.FromStringConverterName.CppCXName()}" : "nullptr";#>
<#      String createFromString = "-1";#>
<#      if (entry.HasCreateFromStringMethod)#>
<#      {#>
<#          createFromString = createFromStringIndex.ToString();#>
<#          createFromStringIndex++;#>
<#      }#>
<#      if (entry.HasMembers) #>
<#      { #>
<#          Model.TrackTypeMembers(entry, out firstMemberIndex); #>
<#      } #>
<#      if(entry.HasEnumValues) #>
<#      { #>
<#          Model.TrackTypeEnumValues(entry, out firstEnumValueIndex); #>
<#      } #>
    // <#= String.Format("{0,3}", entryIndex++) #>
    L"<#=entry.StandardName#>", L"<#=entry.ContentPropertyName#>",
    <#=activator#>, <#=collectionAdd#>, <#=dictionaryAdd#>, <#=fromStringConverter#>,
    <#=baseTypeIndex#>
    <#=firstMemberIndex#>, <#=firstEnumValueIndex#>, <#=createFromString#>, <#=kindofType#>,
    <#=isLocalType#><#=isSystemType#><#=isReturnTypeStub#><#=isBindable#><#=isMarkupExtension#>TypeInfo_Flags_None,
    <#=boxedTypeIndex#>
<#      firstEnumValueIndex += entry.EnumValues.Count(); #>
<#      firstMemberIndex += entry.Members.Count(); #>
<#  } #>
    //  Last type here is for padding
    L"", L"",
    nullptr, nullptr, nullptr, nullptr,
    -1, 
    <#=firstMemberIndex#>, <#=firstEnumValueIndex#>, -1, <#=Projection(KnownNamespaces.WindowsXamlInterop)#>::TypeKind::Custom,
    TypeInfo_Flags_None,
};
<#  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
<#  { #>
#pragma warning( pop )
<#  } #>

<#  entryIndex = 0; #>
const UINT TypeInfoLookup[] = { 
<#  foreach(var entry in Model.TypeInfoLookup) #>
<#  { #>
    <#= String.Format("{0,3},   // {1,3}", entry, entryIndex++) #>
<#  } #>
};

<# Output_GetTypeInfo(); #>
<#  if (Model.EnumValues.Count() > 0) #>
<#  { #>

struct EnumValueInfo
{
    PCWSTR name;
    int eValue;
};

const EnumValueInfo EnumValues[] =
{ 
<#      foreach (var enumValue in Model.EnumValues) #>
<#      { #>
    L"<#=enumValue.ValueName#>", (int) <#=enumValue.TypeInfo.FullName#>::<#=enumValue.ValueName#>,
<#      } #>
};
<#  } #>
<#  if (Model.MemberInfos.Count() > 0) #>
<#  { #>

struct MemberInfo 
{
    PCWSTR shortName;
    ::Platform::Object^ (*getter)(::Platform::Object^);
    void (*setter)(::Platform::Object^, ::Platform::Object^);
    int typeIndex;
    int targetTypeIndex;
    bool isReadOnly;
    bool isDependencyProperty;
    bool isAttachable;
};

<#      if (Model.MemberInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
<#      { #>
#pragma warning( push )
#pragma warning( disable : 4973 )
<#      } #>
const MemberInfo MemberInfos[] = 
{
<#      entryIndex = 0; #>
<#      foreach(var entry in Model.MemberInfos) #>
<#      { #>
<#      String isReadOnly = entry.HasPublicGetter && !entry.HasPublicSetter ? "true, " : "false,"; #>
<#      String isDependencyProperty = entry.IsDependencyProperty ? "true, " : "false,"; #>
<#      String isAttachable = entry.IsAttachable ? "true, " : "false,"; #>
<#      String targetTypeIndex = entry.TargetType != null ? Model.TypeInfoIndexes[entry.TargetType.StandardName].ToString() + ", // " + entry.TargetType.StandardName : "-1,";#>
    // <#= String.Format("{0,3}", entryIndex++) #> - <#=entry.DeclaringType.StandardName#>.<#=entry.Name#>
    L"<#=entry.Name#>",
<#          if (entry.HasGetAttachableMember) { #>
    &<#=entry.GetAttachableMemberName#>,
<#          } else if (entry.HasGetValueTypeMember) { #>
    &<#=entry.GetValueTypeMemberName#>,
<#          } else if (entry.HasGetReferenceTypeMember) { #>
    &<#=entry.GetReferenceTypeMemberName#>,
<#          } else { #>
    nullptr,
<#          } #>
<#          if (entry.HasSetAttachableMember) { #>
    &<#=entry.SetAttachableMemberName#>,
<#          } else if (entry.HasSetEnumMember) { #>
    &<#=entry.SetEnumMemberName#>,
<#          } else if (entry.HasSetValueTypeMember) { #>
    &<#=entry.SetValueTypeMemberName#>,
<#          } else if (entry.HasSetReferenceTypeMember) { #>
    &<#=entry.SetReferenceTypeMemberName#>,
<#          } else { #>
    nullptr,
<#          } #>
    <#=Model.TypeInfoIndexes[entry.Type.StandardName]#>, // <#=entry.Type.StandardName#>
    <#=targetTypeIndex#>
    <#=isReadOnly#> <#=isDependencyProperty#> <#=isAttachable#>
<#      } #>
};
<#      if (Model.MemberInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
<#      { #>
#pragma warning( pop )
<#      } #>

PCWSTR GetShortName(PCWSTR longName)
{
    PCWSTR separator = wcsrchr(longName, '.');
    return separator != nullptr ? separator + 1: longName;
}

<#  } #>
<#  if (Model.MemberInfos.Count() > 0) #>
<#  { #>

const MemberInfo* GetMemberInfo(::Platform::String^ longMemberName)
{
    auto lastDotIndex = longMemberName->Length();
    while (true)
    {
        if (longMemberName->Data()[lastDotIndex] == '.')
        {
            const TypeInfo* pTypeInfo = GetTypeInfo(ref new ::Platform::String(longMemberName->Data(), lastDotIndex));
            const TypeInfo* pNextTypeInfo = pTypeInfo + 1;
            if (pTypeInfo)
            {
                PCWSTR shortMemberName = GetShortName(longMemberName->Data());
                for (int i = pTypeInfo->firstMemberIndex; i < pNextTypeInfo->firstMemberIndex; i++)
                {
                    if (wcscmp(shortMemberName, MemberInfos[i].shortName) == 0)
                    {
                        return &MemberInfos[i];
                    }
                }
            }
            break;
        }
        if (lastDotIndex == 0)
        {
            break;
        }
        lastDotIndex--;
    }
    return nullptr;
}
<#  } #>
<# } //End EnableTypeInfoReflection disabled block #>
<# else #>
<# { #>

struct TypeInfo
{
    PCWSTR  typeName;
    ::Platform::Object^ (*activator)();
};
<#  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
<#  { #>

#pragma warning( push )
#pragma warning( disable : 4973 )
<#  } #>
<#  if (Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod).Any()) { #>

::XamlTypeInfo::InfoProvider::XamlUserType::CreateFromStringFn CreateFromStringMethods[] =
{
<#      foreach(var entry in Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod)) { #>
    [](::Platform::String^ value) -> ::Platform::Object^ { return <#=entry.CreateFromStringMethod.ResolvedName.CppCXName()#>(value); },
<#      }#>
};
<#  } #>

const TypeInfo TypeInfos[] = 
{
<#  int entryIndex = 0; #>
<#  foreach(var entry in Model.TypeInfos) #>
<#  { #>
<#      String activator = entry.HasActivator ? $"&{entry.ActivatorName.CppCXName()}" : "nullptr";#>
    // <#= String.Format("{0,3}", entryIndex++) #>
    L"<#=entry.StandardName#>", <#=activator#>,
<#  } #>
    //  Last type here is for padding
    L"", nullptr
};
<#  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
<#  { #>
#pragma warning( pop )
<#  } #>

<#  entryIndex = 0; #>
const UINT TypeInfoLookup[] = { 
<#  foreach(var entry in Model.TypeInfoLookup) #>
<#  { #>
    <#= String.Format("{0,3},   // {1,3}", entry, entryIndex++) #>
<#  } #>
};
<# Output_GetTypeInfo(); #>
<# } // End of EnableTypeInfoReflection enabled#>
<#  } // if (Model.TypeInfos.Count() > 0) #>
<#  if (ProjectInfo.GenerateOtherProvidersForCX  || !ProjectInfo.GenerateProviderCode) { #>

#pragma warning(push)
#pragma warning(disable: 4691)
::Platform::Collections::Vector<<#=Projection(KnownNamespaces.XamlMarkup)#>::IXamlMetadataProvider^>^ ::XamlTypeInfo::InfoProvider::XamlTypeInfoProvider::OtherProviders::get()
{
    auto lock = _xamlTypesCriticalSection.Lock();
    if(_otherProviders == nullptr)
    {
        auto otherProviders = ref new ::Platform::Collections::Vector<<#=Projection(KnownNamespaces.XamlMarkup)#>::IXamlMetadataProvider^>();
<#                  if (ProjectInfo.GenerateProviderCode) #>
<#                  { #>
<#                      if(SchemaInfo.OtherMetadataProviders.Any()) #>
<#                      { #>
        <#=Projection(KnownNamespaces.XamlMarkup)#>::IXamlMetadataProvider^ provider;
<#                          foreach(var xmp in SchemaInfo.OtherMetadataProviders) #>
<#                          { #>
        provider = ref new <#=xmp.FullName#>();
        otherProviders->Append(provider); 
<#                          } #>
<#                      } #>
<#                  } #>
        _otherProviders = otherProviders;
    }
    return _otherProviders;
}
#pragma warning(pop)
<#  } #>

<# if(ProjectInfo.EnableTypeInfoReflection) #>
<# { #>
::XamlTypeInfo::InfoProvider::XamlActivatableType^ ::XamlTypeInfo::InfoProvider::XamlTypeInfoProvider::GetActivatableTypeForTypeName(::Platform::String^ typeName)
{
<#  if(!Model.TypeInfos.Any()) #>
<#  { #>
    // No Local Types
    (void)typeName; // Unused parameter
    return nullptr;
<#  } #>
<#  else#>
<#  { #>
    const TypeInfo* pTypeInfo = GetTypeInfo(typeName);
    const TypeInfo* pNextTypeInfo = pTypeInfo + 1;
    if (pTypeInfo == nullptr || pNextTypeInfo == nullptr)
    {
        return nullptr;
    }
    else
    {
        auto activatableType = ref new XamlTypeInfo::InfoProvider::XamlActivatableType();
        activatableType->Activator = pTypeInfo->activator;
        return activatableType;
    }
<# } #>
}
<# } #>
<# else #>
<# { #>
<#=Projection(KnownNamespaces.XamlMarkup)#>::IXamlType^ ::XamlTypeInfo::InfoProvider::XamlTypeInfoProvider::CreateXamlType(::Platform::String^ typeName)
{
<#  if(!Model.TypeInfos.Any()) #>
<#  { #>
    // No Local Types
    (void)typeName; // Unused parameter
    return nullptr;
<#  } #>
<#  else#>
<#  { #>
    const TypeInfo* pTypeInfo = GetTypeInfo(typeName);
    const TypeInfo* pNextTypeInfo = pTypeInfo + 1;
    if (pTypeInfo == nullptr || pNextTypeInfo == nullptr)
    {
        return nullptr;
    }
    else if (pTypeInfo->flags & TypeInfo_Flags_IsSystemType)
    {
        return ref new ::XamlTypeInfo::InfoProvider::XamlSystemBaseType(typeName);
    }
    else
    {
        ::XamlTypeInfo::InfoProvider::XamlUserType^ userType = ref new ::XamlTypeInfo::InfoProvider::XamlUserType(
            this, 
            ::Platform::StringReference(pTypeInfo->typeName), 
            this->GetXamlTypeByName(::Platform::StringReference(pTypeInfo->baseTypeIndex >= 0 ? TypeInfos[pTypeInfo->baseTypeIndex].typeName : L"")));
        userType->KindOfType = pTypeInfo->kindofType;
        userType->Activator = pTypeInfo->activator;
        userType->CollectionAdd = pTypeInfo->collectionAdd;
        userType->DictionaryAdd = pTypeInfo->dictionaryAdd;
        userType->FromStringConverter = pTypeInfo->fromStringConverter;
        userType->ContentPropertyName = ::Platform::StringReference(pTypeInfo->contentPropertyName);
        userType->IsLocalType = pTypeInfo->flags & TypeInfo_Flags_IsLocalType;
        userType->IsReturnTypeStub = pTypeInfo->flags & TypeInfo_Flags_IsReturnTypeStub;
        userType->IsBindable = pTypeInfo->flags & TypeInfo_Flags_IsBindable;
        userType->IsMarkupExtension = pTypeInfo->flags & TypeInfo_Flags_IsMarkupExtension;
        userType->CreateFromStringMethod = nullptr;
<#  if (Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod).Any()) { #>
        if (pTypeInfo->createFromStringIndex != -1)
        {
            userType->CreateFromStringMethod = CreateFromStringMethods[pTypeInfo->createFromStringIndex];
        }
<# } #>
        userType->SetBoxedType(this->GetXamlTypeByName(::Platform::StringReference(pTypeInfo->boxedTypeIndex >= 0 ? TypeInfos[pTypeInfo->boxedTypeIndex].typeName : L"")));
<#  if (Model.MemberInfos.Count() > 0) #>
<#  { #>
        int nextMemberIndex = pTypeInfo->firstMemberIndex;
        for (int i=pTypeInfo->firstMemberIndex; i < pNextTypeInfo->firstMemberIndex; i++)
        {
            userType->AddMemberName(::Platform::StringReference(MemberInfos[i].shortName));
            nextMemberIndex++;
        }
<#  } #>
<#  if (Model.EnumValues.Count() > 0) #>
<#  { #>
        for (int i = pTypeInfo->firstEnumValueIndex; i < pNextTypeInfo->firstEnumValueIndex; i++)
        {
            userType->AddEnumValue(
                ::Platform::StringReference(EnumValues[i].name),
                ::Windows::Foundation::PropertyValue::CreateInt32(EnumValues[i].eValue));
        }
<#  } #>
        return userType;
    }
<#  } #>
}

<#=Projection(KnownNamespaces.XamlMarkup)#>::IXamlMember^ ::XamlTypeInfo::InfoProvider::XamlTypeInfoProvider::CreateXamlMember(::Platform::String^ longMemberName)
{
    ::XamlTypeInfo::InfoProvider::XamlMember^ xamlMember = nullptr;
<#  if (!Model.MemberInfos.Any()) #>
<#  { #>
    // No Local Properties
    (void)longMemberName; // Unused parameter
<#  } #>
<#  else#>
<#  { #>
    const MemberInfo* pMemberInfo = GetMemberInfo(longMemberName);
    if (pMemberInfo != nullptr)
    {
        xamlMember = ref new ::XamlTypeInfo::InfoProvider::XamlMember(
            this,
            ::Platform::StringReference(pMemberInfo->shortName),
            ::Platform::StringReference(TypeInfos[pMemberInfo->typeIndex].typeName));
        xamlMember->Getter = pMemberInfo->getter;
        xamlMember->Setter = pMemberInfo->setter;
        xamlMember->TargetTypeName = pMemberInfo->targetTypeIndex >= 0 ? ::Platform::StringReference(TypeInfos[pMemberInfo->targetTypeIndex].typeName) : L"";
        xamlMember->IsReadOnly = pMemberInfo->isReadOnly;
        xamlMember->IsDependencyProperty = pMemberInfo->isDependencyProperty;
        xamlMember->IsAttachable = pMemberInfo->isAttachable;
    }
<#  } #>
    return xamlMember;
}
<# } #>
<#+     private void Output_GetTypeInfo() #>
<#+     { #>
const TypeInfo* GetTypeInfo(::Platform::String^ typeName)
{
    auto typeNameLength = typeName->Length();
    if (typeNameLength < _countof(TypeInfoLookup) - 1)
    {
        for (UINT i = TypeInfoLookup[typeNameLength]; i < TypeInfoLookup[typeNameLength+1]; i++)
        {
            if (typeName == ::Platform::StringReference(TypeInfos[i].typeName))
            {
                return &TypeInfos[i];
            }
        }
    }
    return nullptr;
}
<#+     } #>