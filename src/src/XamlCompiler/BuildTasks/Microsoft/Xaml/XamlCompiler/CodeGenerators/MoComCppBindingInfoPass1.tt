<#@ template language="C#" inherits="CppCX_CodeGenerator<BindingInfoDefinition>" visibility="internal" linePragmas="false"#>
<#@ assembly name="System.Core" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma once

namespace XamlBindingInfo
{
    ref class XamlBindings;

    class IXamlBindings
    {
    public:
        virtual ~IXamlBindings() {};
        virtual bool IsInitialized() = 0;
        virtual void Update() = 0;
        virtual bool SetDataRoot(::Platform::Object^ data) = 0;
        virtual void StopTracking() = 0;
        virtual void Connect(int connectionId, ::Platform::Object^ target) = 0;
        virtual void Recycle() = 0;
        virtual void ProcessBindings(::Platform::Object^ item, int itemIndex, int phase, int* nextPhase) = 0;
        virtual void SubscribeForDataContextChanged(<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement^ object, ::XamlBindingInfo::XamlBindings^ handler) = 0;
        virtual void DisconnectUnloadedObject(int connectionId) = 0;
<#  if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#  { #>
        virtual void Disable(int lineNumber, int columnNumber) = 0;
<#  } #>
        virtual <#=Projection(KnownNamespaces.XamlMarkup)#>::IComponentConnector^ GetBindingConnector(int connectionId, ::Platform::Object^ target) = 0;
        virtual ::XamlBindingInfo::XamlBindings^ GetParent() = 0;
        virtual void SetParent(::XamlBindingInfo::XamlBindings^ parent) = 0;
        virtual bool ContainsElement(int connectionId) = 0;
        virtual void RegisterForElementConnection(int connectionId, ::XamlBindingInfo::XamlBindings^ connector) = 0;
        virtual void SetOwningBindingsClass(::XamlBindingInfo::XamlBindings^ owningBindings) = 0;
    };

    class IXamlBindingTracking
    {
    public:
        virtual void PropertyChanged(Platform::Object^ sender, <#=Projection(KnownNamespaces.XamlData)#>::PropertyChangedEventArgs^ e) = 0;
        virtual void CollectionChanged(::Platform::Object^ sender, <#=Projection(KnownNamespaces.XamlInterop)#>::NotifyCollectionChangedEventArgs^ e) = 0;
        virtual void DependencyPropertyChanged(<#=Projection(KnownNamespaces.Xaml)#>::DependencyObject^ sender, <#=Projection(KnownNamespaces.Xaml)#>::DependencyProperty^ prop) = 0;
        virtual void VectorChanged(::Platform::Object^ sender, ::Windows::Foundation::Collections::IVectorChangedEventArgs^ e) = 0;
        virtual void MapChanged(::Platform::Object^ sender, ::Windows::Foundation::Collections::IMapChangedEventArgs<::Platform::String^>^ e) = 0;
<# if (ProjectInfo.IsInputValidationEnabled) {#>
        virtual void ErrorsChanged(::Platform::Object^ sender, <#=Projection(KnownNamespaces.XamlData)#>::DataErrorsChangedEventArgs^ e) = 0;
<# } #>
    };

    ref class XamlBindings sealed :
        <#=Projection(KnownNamespaces.Xaml)#>::IDataTemplateExtension,
        <#=Projection(KnownNamespaces.XamlMarkup)#>::IComponentConnector,
<#  if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#  { #>
        <#=Projection(KnownNamespaces.XamlMarkup)#>::IXamlBindScopeDiagnostics,
<#  } #>
        <#=Projection(KnownNamespaces.XamlMarkup)#>::IDataTemplateComponent
    {
    internal:
        XamlBindings(::XamlBindingInfo::IXamlBindings* pBindings);
        void Initialize();
        void Update();
        void StopTracking();
        void Loading(<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement^ src, ::Platform::Object^ data);
        void DataContextChanged(<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement^ sender, <#=Projection(KnownNamespaces.Xaml)#>::DataContextChangedEventArgs^ args);
        void SubscribeForDataContextChanged(<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement^ object);

    public:
        // IComponentConnector
        virtual void Connect(int connectionId, ::Platform::Object^ target);

        // IDataTemplateComponent
        virtual void ProcessBindings(::Platform::Object^ item, int itemIndex, int phase, int* nextPhase);
        virtual void Recycle();

        // IDataTemplateExtension
        virtual bool ProcessBinding(unsigned int);
        virtual int ProcessBindings(<#=Projection(KnownNamespaces.XamlControls)#>::ContainerContentChangingEventArgs^ args);
        virtual void ResetTemplate();

        virtual void DisconnectUnloadedObject(int connectionId);
<#  if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#  { #>
        virtual void Disable(int lineNumber, int columnNumber);
<#  } #>
        // IComponentConnector
        virtual <#=Projection(KnownNamespaces.XamlMarkup)#>::IComponentConnector^ GetBindingConnector(int connectionId, ::Platform::Object^ target);

        virtual ::XamlBindingInfo::XamlBindings^ GetParent();
        virtual void SetParent(::XamlBindingInfo::XamlBindings^ parent);
        virtual bool ContainsElement(int connectionId);
        virtual void RegisterForElementConnection(int connectionId, ::XamlBindingInfo::XamlBindings^ connector);
    private:
        ~XamlBindings();
        ::XamlBindingInfo::IXamlBindings* _pBindings = nullptr;
    };

    ref class WeakRefWrapper sealed
    {
    private:
        ::Platform::WeakReference weakRef;
    public:

        WeakRefWrapper(::Platform::Object^ obj)
        {
            weakRef = obj;
        }

        ::Platform::Object^ Resolve()
        {
            return weakRef.Resolve<::Platform::Object>();
        }
    };

    template <class TBindingsTracking>
    class XamlBindingsBase : public IXamlBindings
    {
    protected:
        bool _isInitialized;
        TBindingsTracking^ _bindingsTracking;
        ::Windows::Foundation::EventRegistrationToken _dataContextChangedToken;
        static const int NOT_PHASED = (1 << 31);
        static const int DATA_CHANGED = (1 << 30);
        ::Platform::WeakReference owningXamlBindings;

    protected:
        XamlBindingsBase()
            : _isInitialized(false)
            , _bindingsTracking(nullptr)
        {
            _dataContextChangedToken.Value = 0;
        }

        virtual ~XamlBindingsBase()
        {
            if (_bindingsTracking != nullptr)
            {
                _bindingsTracking->SetListener(nullptr);
                _bindingsTracking = nullptr;
            }
        }

        virtual void ReleaseAllListeners()
        {
            // Overridden in the binding class as needed.
        }

    public:
        void InitializeTracking(::XamlBindingInfo::IXamlBindingTracking* pBindingsTracking)
        {
            _bindingsTracking = ref new TBindingsTracking();
            _bindingsTracking->SetListener(pBindingsTracking);
        }

        virtual void StopTracking() override
        {
            ReleaseAllListeners();
            this->_isInitialized = false;
        }

        virtual bool IsInitialized() override
        {
            return this->_isInitialized;
        }

        virtual void Update() = 0;

        void SubscribeForDataContextChanged(<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement^ object, ::XamlBindingInfo::XamlBindings^ handler)
        {
            this->_dataContextChangedToken = object->DataContextChanged += 
                ref new ::Windows::Foundation::TypedEventHandler<<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement^, <#=Projection(KnownNamespaces.Xaml)#>::DataContextChangedEventArgs^>(
                    handler, &::XamlBindingInfo::XamlBindings::DataContextChanged);
        }

        virtual void Connect(int connectionId, ::Platform::Object^ target) = 0;

        virtual void Recycle()
        {
            // Overridden in the binding class as needed.
        }

        virtual void ProcessBindings(::Platform::Object^, int, int, int* nextPhase)
        {
            // Overridden in the binding class as needed.
            *nextPhase = -1;
        }
<#  if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#  { #>

        virtual void Disable(int lineNumber, int columnNumber) = 0;
<#  } #>
        virtual void SetOwningBindingsClass(::XamlBindingInfo::XamlBindings^ owningBindings) override
        {
            owningXamlBindings = owningBindings;
        }

        virtual <#=Projection(KnownNamespaces.XamlMarkup)#>::IComponentConnector^ GetBindingConnector(int connectionId, ::Platform::Object^ target)
        {
            // Overridden in the bindings class as needed.
            connectionId;
            target;
            return nullptr;
        }

        virtual ::XamlBindingInfo::XamlBindings^ GetParent()
        {
            return nullptr;
        }

        virtual void SetParent(::XamlBindingInfo::XamlBindings^ parent)
        {
            parent;
        }

        virtual bool ContainsElement(int connectionId)
        {
            connectionId;
            return false;
        }

        virtual void RegisterForElementConnection(int connectionId, ::XamlBindingInfo::XamlBindings^ connector)
        {
            connectionId;
            connector;
        }
    };

    ref class XamlBindingTrackingBase
    {
    internal:
        XamlBindingTrackingBase();
        void SetListener(::XamlBindingInfo::IXamlBindingTracking* pBindings);
        
        // Event handlers
        void PropertyChanged(Platform::Object^ sender, <#=Projection(KnownNamespaces.XamlData)#>::PropertyChangedEventArgs^ e);
        void CollectionChanged(::Platform::Object^ sender, <#=Projection(KnownNamespaces.XamlInterop)#>::NotifyCollectionChangedEventArgs^ e);
        void DependencyPropertyChanged(<#=Projection(KnownNamespaces.Xaml)#>::DependencyObject^ sender, <#=Projection(KnownNamespaces.Xaml)#>::DependencyProperty^ prop);
        void VectorChanged(::Platform::Object^ sender, ::Windows::Foundation::Collections::IVectorChangedEventArgs^ e);
        void MapChanged(::Platform::Object^ sender, ::Windows::Foundation::Collections::IMapChangedEventArgs<::Platform::String^>^ e);
<# if (ProjectInfo.IsInputValidationEnabled) {#>
        void ErrorsChanged(::Platform::Object^ sender, <#=Projection(KnownNamespaces.XamlData)#>::DataErrorsChangedEventArgs^ e);
<# } #>

        // Listener update functions
        void UpdatePropertyChangedListener(<#=Projection(KnownNamespaces.XamlData)#>::INotifyPropertyChanged^ obj, <#=Projection(KnownNamespaces.XamlData)#>::INotifyPropertyChanged^* pCache, ::Windows::Foundation::EventRegistrationToken* pToken);
        void UpdatePropertyChangedListener(<#=Projection(KnownNamespaces.XamlData)#>::INotifyPropertyChanged^ obj, ::Platform::WeakReference& cacheRef, ::Windows::Foundation::EventRegistrationToken* pToken);
        void UpdateCollectionChangedListener(<#=Projection(KnownNamespaces.XamlInterop)#>::INotifyCollectionChanged^ obj, <#=Projection(KnownNamespaces.XamlInterop)#>::INotifyCollectionChanged^* pCache, ::Windows::Foundation::EventRegistrationToken* pToken);
        void UpdateDependencyPropertyChangedListener(<#=Projection(KnownNamespaces.Xaml)#>::DependencyObject^ obj, <#=Projection(KnownNamespaces.Xaml)#>::DependencyProperty^ property, <#=Projection(KnownNamespaces.Xaml)#>::DependencyObject^* pCache, __int64* pToken);
        void UpdateDependencyPropertyChangedListener(<#=Projection(KnownNamespaces.Xaml)#>::DependencyObject^ obj, <#=Projection(KnownNamespaces.Xaml)#>::DependencyProperty^ property, ::Platform::WeakReference& cacheRef, __int64* pToken);
<# if (ProjectInfo.IsInputValidationEnabled) {#>
        void UpdateErrorsChangedListener(<#=Projection(KnownNamespaces.XamlData)#>::INotifyDataErrorInfo^ obj, <#=Projection(KnownNamespaces.XamlData)#>::INotifyDataErrorInfo^* pCache, ::Windows::Foundation::EventRegistrationToken* pToken);
        void UpdateErrorsChangedListener(<#=Projection(KnownNamespaces.XamlData)#>::INotifyDataErrorInfo^ obj, ::Platform::WeakReference& cacheRef, ::Windows::Foundation::EventRegistrationToken* pToken);
<# } #>

    private:
        ::XamlBindingInfo::IXamlBindingTracking* _pBindingsTrackingWeakRef = nullptr;
    };

    template <typename T>
    struct ResolveHelper
    {
        static T^ Resolve(const ::Platform::WeakReference& wr)
        {
            return wr.Resolve<T>();
        }
    };

    template <>
    struct ResolveHelper<::Platform::String>
    {
        typedef ::Platform::IBox<::Platform::String^> ResolveType;

        static ::Platform::String^ Resolve(const ::Platform::WeakReference& wr)
        {
            return safe_cast<::Platform::String^>(wr.Resolve<ResolveType>());
        }

    };

    template<class T, class TBindingsTracking> 
    class ReferenceTypeXamlBindings : public XamlBindingsBase<TBindingsTracking>
    {
    private:
        ::Platform::WeakReference _dataRoot;

    protected:
        ReferenceTypeXamlBindings() {}

        virtual void Update_(T^, int)
        {
            // Overridden in the binding class as needed.
        }

    public:
        T^ GetDataRoot()
        {
            return ResolveHelper<T>::Resolve(this->_dataRoot);
        }

        bool SetDataRoot(::Platform::Object^ data)
        {
            if (data != nullptr)
            {
                this->_dataRoot = data;
                return true;
            }
            return false;
        }

        virtual void Update() override
        {
            this->Update_(this->GetDataRoot(), this->NOT_PHASED);
            this->_isInitialized = true;
        }
    };

    template<class T, class TBindingsTracking> 
    class ValueTypeXamlBindings : public XamlBindingsBase<TBindingsTracking>
    {
    private:
        T _dataRoot;

    protected:
        ValueTypeXamlBindings() {}

        virtual void Update_(T, int)
        {
            // Overridden in the binding class as needed.
        }

    public:
        T GetDataRoot()
        {
            return this->_dataRoot;
        }

        bool SetDataRoot(::Platform::Object^ data)
        {
            if (data != nullptr)
            {
                this->_dataRoot = safe_cast<T>(data);
                return true;
            }
            return false;
        }

        virtual void Update() override
        {
            this->Update_(this->GetDataRoot(), this->NOT_PHASED);
            this->_isInitialized = true;
        }
    };
}
