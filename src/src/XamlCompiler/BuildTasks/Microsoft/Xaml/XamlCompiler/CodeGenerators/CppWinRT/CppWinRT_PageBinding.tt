<#@ template language="C#" inherits="CppWinRT_CodeGenerator<PageDefinition>" visibility="internal" linePragmas="false"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#
    BindUniverse bindUniverse = Arguments[0] as BindUniverse;
#>
    template <typename D, typename ... I>
    struct <#=Model.CodeInfo.ClassName.ShortName#>T<D, I...>::<#=bindUniverse.BindingsClassName#>
        : public <#=Projection(ProjectInfo.RootNamespace)#>::implementation::<#=bindUniverse.DataRootType.NeedsBoxUnbox() ? "ValueTypeXamlBindings" : "ReferenceTypeXamlBindings"#><<#=bindUniverse.DataRootType#>, <#=GetBindingTrackingClassName(bindUniverse, Model.CodeInfo)#>>
<#  if (bindUniverse.NeedsBindingsTracking) { #>
        , public <#=Projection(ProjectInfo.RootNamespace)#>::implementation::IXamlBindingTracking
<#  }#>
{
        <#=bindUniverse.BindingsClassName#>()
        {
<#  if (bindUniverse.NeedsBindingsTracking) {#>
            InitializeTracking(this);
<#  }#>
        }

<#  if (bindUniverse.NeedsBindingsTracking) { #>
        ~<#=bindUniverse.BindingsClassName#>()
        {
            ReleaseAllListeners();
        }

<#  }#>
        void Connect(int32_t connectionId, IInspectable const& target) override
        {
            switch(connectionId)
            {
<# foreach (var element in bindUniverse.ElementsWithConnectCase) { #>
            case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
                {
<#               if (element.Type.IsDerivedFromControlTemplate())#>
<#               {#>
                    Update(); // Template children have been connected, initialize bindings
<#               }#>
<#               else#>
<#               {#>
<#      Output_ConnectionId_Case(element); #>
<#               }#>
                }
                break;
<# } #>
            }
        }

        void DisconnectUnloadedObject(int connectionId) override
        {
<#      if (bindUniverse.ElementsWithDisconnectCase.Count() == 0) { #>
            throw ::winrt::hresult_invalid_argument { L"No unloadable elements to disconnect." };
<#      } else { #>
            switch (connectionId)
            {
<#          foreach (var element in bindUniverse.ElementsWithDisconnectCase) { #>
                case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
                    {
<#              if (bindUniverse.BoundElements.Contains(element)) { #>
<#              Output_ApiInformationCall_Push(element.ApiInformation, Indent.OneTab); #>
                        if (<#=element.ObjectCodeName#>)
                        {
<#              foreach (var ba in element.BindAssignments.Where(ba => ba.HasDeferredValueProxy)) { #>
                            <#=ba.ObjectDeferredAssignmentCodeName#> = <#=element.GetMemberGetExpression(ba)#>;
<#              }#>
                            <#=element.ObjectCodeName#> = nullptr;
                        }
<#              foreach (var childElem in element.Children.Where(c => bindUniverse.ElementsWithDisconnectCase.Contains(c))) {#>
                        DisconnectUnloadedObject(<#=childElem.ConnectionId#>);
<#              }#>
<#              Output_ApiInformationCall_Pop(element.ApiInformation, Indent.OneTab); #>
<#              } #>
<#              if (element.HasRootNamedElementStep) { #>
                    this->UnloadableBindingSourcesToUpdate.push_back([this]()
                    {
<#                  PushIndent(Indent.TwoTabs); #>
<#                  Output_Custom_Update_Call(element.RootNamedElementStep, "nullptr", KnownStrings.NotPhased);#>
<#                  PopIndent(); #>
                            });
<#              } #>
                }
                break;
<#          }#>
                default:
                    throw hresult_invalid_argument(L"Invalid connectionId.");
            }
<#      } #>
        }
<#  if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) { #>

        void UpdateUnloadedElement(int connectionId)
        {
            switch (connectionId)
            {
<#      foreach (var element in bindUniverse.ElementsWithBoundLoadAssignments) { #>
            case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
                {
<#          foreach (var ba in element.BindAssignments.OfType<BoundLoadAssignment>()) { #>
<#              PushIndent(Indent.TwoTabs); #>
<#              Output_Binding_SetValue_Non_Function_Call(ba, ba.ObjectDeferredAssignmentCodeName.CppWinRTName(), false); #>
<#              PopIndent(); #>
<#          } #>
                    }
                    break;
<#      }#>
            default:
                throw hresult_invalid_argument(L"Invalid connectionId.");
            }
        }
<#  }#>
<#  if (bindUniverse.NeedsIDataTemplateExtension) {#>

        void Recycle() override
        {
<#      if (bindUniverse.NeedsBindingsTracking) { #>
            ReleaseAllListeners();
<#      } #>
<#      foreach (KeyValuePair<int, List<PhaseAssignment>> kvp in bindUniverse.PhaseAssignments.Where(kvp => kvp.Key != 0).OrderBy(kvp => kvp.Key)) { #>
<#          foreach(PhaseAssignment phase in kvp.Value) { #>
<#              if (phase.ConnectionIdElement.CanBeInstantiatedLater) { #>
            if (<#=phase.ConnectionIdElement.ReferenceExpression#>)
            {
<#                  PushIndent();#>
<#              }#>
            <#=Projection(KnownNamespaces.XamlMarkup)#>::XamlBindingHelper::SuspendRendering(<#=phase.ConnectionIdElement.ReferenceExpression#>);
<#              if (phase.ConnectionIdElement.CanBeInstantiatedLater) { #>
<#                  PopIndent();#>
            }
<#              }#>
<#          } #>
<#      } #>
        }

        void ProcessBindings(IInspectable const& item, int itemIndex, int phase, int32_t& nextPhase)
        {
            nextPhase = -1;
            switch (phase)
            {
            case 0:
                {
                    nextPhase = <#=bindUniverse.GetNextPhase(0)#>;
                    SetDataRoot(item);
                    if (_dataContextChangedToken.value != 0)
                    {
                        auto rootElement = <#=bindUniverse.RootElement.ReferenceExpression#>;
                        if (rootElement != nullptr)
                        {
                            rootElement.DataContextChanged(_dataContextChangedToken);
                        }
                        _dataContextChangedToken.value = 0;
                    }
                    _isInitialized = true;
                 }
                 break;
<#      foreach(KeyValuePair<int, List<PhaseAssignment>> kvp in bindUniverse.PhaseAssignments.Where(kvp => kvp.Key != 0).OrderBy(kvp => kvp.Key)) { #>
            case <#=kvp.Key#>:
                {
<#          foreach(PhaseAssignment phase in kvp.Value) { #>
<#              if (phase.ConnectionIdElement.CanBeInstantiatedLater) { #>
                    if (<#=phase.ConnectionIdElement.ReferenceExpression#>)
                    {
<#                     PushIndent();#>
<#              }#>
                    <#=Projection(KnownNamespaces.XamlMarkup)#>::XamlBindingHelper::ResumeRendering(<#=phase.ConnectionIdElement.ReferenceExpression#>);
<#              if (phase.ConnectionIdElement.CanBeInstantiatedLater) { #>
<#                     PopIndent();#>
                    }
<#              }#>
<#          } #>
                    nextPhase = <#=bindUniverse.GetNextPhase(kvp.Key)#>;
                }
                break;
<#      } #>
            }
            Update_(::winrt::unbox_value<<#=bindUniverse.RootStep.ValueType#>>(item) , 1 << phase);
        }
<# } else if (bindUniverse.NeedsIDataTemplateComponent) { #>
        void Recycle() override
        {
            return;
        }

        void ProcessBindings(IInspectable const& item, int itemIndex, int phase, int32_t& nextPhase)
        {
            nextPhase = 1;
        }
<# } #>

<# if (bindUniverse.DistinctConvertersUsed.Count() > 0) { #>
<#     if (Model.CodeInfo.IsResourceDictionary) { #>
        void SetConverterLookupRoot(<#=Projection(KnownNamespaces.Xaml)#>::ResourceDictionary const& resources)
        {
            localResources = resources;
        }
<#     } else { #>
        void SetConverterLookupRoot(<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement const& rootElement)
        {
            converterLookupRoot = rootElement;
        }
<#     }#>

        <#=Projection(KnownNamespaces.XamlData)#>::IValueConverter LookupConverter(::winrt::hstring const& key)
        {
<#      if (!Model.CodeInfo.IsResourceDictionary) { #>
            if (!localResources)
            {
                localResources = converterLookupRoot.get().Resources();
                converterLookupRoot = nullptr;
            }
<#      }#>
            auto boxedKey = ::winrt::box_value(key);
            return (localResources.HasKey(boxedKey) ? localResources.Lookup(boxedKey) : <#=Projection(KnownNamespaces.Xaml)#>::Application::Current().Resources().Lookup(boxedKey))
                .as<<#=Projection(KnownNamespaces.XamlData)#>::IValueConverter>();
        }
<#  }#>

    private:
<#  if (bindUniverse.BoundElements != null && bindUniverse.BoundElements.Any()) { #>
        // Fields for each control that has bindings.
<#  }#>
<#  foreach (ConnectionIdElement bindElement in bindUniverse.BoundElements) { #>
<#      if (bindElement.IsWeakRef) { #>
        ::winrt::weak_ref<<#=bindElement.Type#>> <#=bindElement.ObjectCodeName#>;
<#      } else if (!bindElement.Type.IsDerivedFromControlTemplate()) { #>
        <#=bindElement.Type#> <#=bindElement.ObjectCodeName#> { nullptr };
<#      }#>
<#      if (bindElement.CanBeInstantiatedLater) { #>
<#          foreach (var ba in bindElement.BindAssignments) { #>
        <#=ba.MemberType#> <#=ba.ObjectDeferredAssignmentCodeName#> <#=ba.MemberType.IsNullable ? "{nullptr}" : "{}"#>;
<#          } #>
<#      } #>
<#  } #>
<#  if (bindUniverse.UnloadableBindingSourceElements.Any()) { #>
        std::list<std::function<void ()>> UnloadableBindingSourcesToUpdate;
<#  } #>
<#  if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) { #>
        std::list<int> UnloadedElementsToUpdate;
<#  } #>
<#  if (bindUniverse.NeedsBindingsTracking) { #>

        // Fields for binding tracking.
<#      Output_Listener_Tracking_Fields(bindUniverse);#>
<#  }#>
<#  if (bindUniverse.DistinctConvertersUsed.Count() > 0) { #>
        <#=Projection(KnownNamespaces.Xaml)#>::ResourceDictionary localResources { nullptr };
<#      if (!Model.CodeInfo.IsResourceDictionary) { #>
        ::winrt::weak_ref<<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement> converterLookupRoot;
<#      }#>
<#  }#>
<#  if (bindUniverse.HasBindings) { #>
<#      if (bindUniverse.HasFunctionBindings) {#>
<#          Output_TryGetValueFunctions(bindUniverse);#>
<#          Output_FunctionBindings(bindUniverse);#>
<#      }#>
<#      if (bindUniverse.NeedsCompleteUpdate) { #>
<#          Output_CompleteUpdate(bindUniverse);#>
<#      }#>

        // Update methods for each path node used in binding steps.
<#  }#>
<#  foreach (var bindStep in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.IsIncludedInUpdate == true)) { #>

<#      if (bindStep is FunctionStep) { #>
        void Update_<#=bindStep.CodeName#>(int32_t phase)
<#      } else { #>
        void Update_<#=bindStep.CodeName#>(<#=bindStep.ValueType#> obj, int32_t phase)
<#      }#>
        {
<#      Output_UpdateChildListeners_Call(bindStep, "obj");#>
<#      Output_Update_Steps(bindStep.ValueType.IsNullable, bindStep.Children, true, "phase");#>
<#      Output_Update_Steps(false, bindStep.Dependents, false, "phase");#>
<#      foreach (int distinctPhase in bindStep.DistinctPhases) { #>
<#          Output_Binding_Phased_SetValue(distinctPhase, true, bindStep, false);#>
<#          Output_Binding_Phased_SetValue(distinctPhase, false, bindStep, false);#>
<#      }#>
<#      if (bindStep is RootStep) { #>
<#          Output_Update_Steps(false, bindUniverse.BindPathSteps.Values.Where(s => s.Parent is StaticRootStep), false, "phase");#>
<#          if (bindUniverse.NeedsCompleteUpdate) { #>
            CompleteUpdate(phase);
<#          }#>
<#      }#>
        }
<#  }#>
<#  foreach (BindPathStep bindStep in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.IsIncludedInUpdate == true)) { #>
<#      if (bindStep.Parent != null && bindStep.BindStatus.HasFlag(BindStatus.HasFallbackValue)) { #>

        void UpdateFallback_<#=bindStep.CodeName#>(int phase)
        {
<#          foreach (BindPathStep childStep in bindStep.Children.Concat(bindStep.Dependents)) { #>
<#              if (childStep.BindStatus.HasFlag(BindStatus.HasFallbackValue)) { #>
            UpdateFallback_<#=childStep.CodeName#>(phase);
<#              } #>
<#          }#>
<#          foreach (int distinctPhase in bindStep.DistinctPhases)  { #>
<#              Output_Binding_Phased_Fallback_SetValue(distinctPhase, true, bindStep);#>
<#              Output_Binding_Phased_Fallback_SetValue(distinctPhase, false, bindStep);#>
<#          } #>
        }
<#      } #>
<#  } #>
<#  if (bindUniverse.NeedsBindingsTracking) { #>

        virtual void ReleaseAllListeners() override
        {
<#      foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(step => step.NeedsUpdateChildListeners)) { #>
<#          Output_UpdateChildListeners_Call(step, "nullptr");#>
<#      }#>
        }

        virtual void PropertyChanged(IInspectable const& sender, <#=Projection(KnownNamespaces.XamlData)#>::PropertyChangedEventArgs const& e) override
        {
<#      foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true)) { #>
<#          if (step.RequiresChildNotification && (step is PropertyStep || step is CastStep || step is RootStep || step is RootNamedElementStep || step is ArrayIndexStep || step is MapIndexStep) && step.ImplementsINPC) { #>
<#              string cacheName = "GetDataRoot()";#>
<#              if (step.RequiresChildNotification && !(step is RootStep)) { #>
<#                  cacheName="cachePC_" + step.CodeName;#>
<#              }#>
            if (<#=cacheName#> && <#=cacheName#> == sender)
            {
                auto propName = e.PropertyName();
                auto obj = sender.as<<#=step.ValueType#>>();
                if (propName.empty())
                {
<#              PushIndent(Indent.TwoTabs);#>
<#              Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps, false, "DATA_CHANGED");#>
<#              PopIndent();#>
                }
<#              foreach (string propertyName in step.TrackingSteps.OfType<PropertyStep>().Select(p => p.PropertyName).Distinct()) { #>
                else if (propName == L"<#=propertyName#>")
                {
<#                  PushIndent(Indent.TwoTabs); #>
<#                  foreach (var child in step.TrackingSteps.OfType<PropertyStep>().Where(p => p.PropertyName == propertyName)) { #>
<#                      Output_Update_DataChanged_Step(child); #>
<#                  } #>
<#                  PopIndent(); #>
                }
<#              } #>
<#              foreach (string functionName in step.TrackingSteps.OfType<FunctionStep>().Select(p => p.Method.MethodName).Distinct())#>
<#              {#>
                else if (propName == L"<#=functionName#>")
                {
<#                  PushIndent(Indent.TwoTabs);#>
<#                  Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps.OfType<FunctionStep>().Where(p => p.Method.MethodName == functionName), false, "DATA_CHANGED");#>
<#                  PopIndent();#>
                }
<#              }#>
            }
<#          }#>
<#      }#>
<#      if (bindUniverse.NeedsCompleteUpdate) { #>
            CompleteUpdate(DATA_CHANGED);
<#      }#>
        }

        void CollectionChanged(IInspectable const& sender, <#=Projection(KnownNamespaces.XamlInterop)#>::NotifyCollectionChangedEventArgs const& e) override
        {
<#  foreach (var step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true)) { #>
<#      if (step.RequiresChildNotification && (step is PropertyStep || step is CastStep || step is RootStep || step is RootNamedElementStep) && step.ImplementsINCC && !step.ImplementsIObservableVector && !step.ImplementsIObservableMap) { #>
<#          string cacheName = "GetDataRoot()"; #>
<#          if (step.RequiresChildNotification && !(step is RootStep)) { #>
<#              cacheName="cacheCC_" + step.CodeName; #>
<#          }#>
            if (<#=cacheName#> && <#=cacheName#> == sender)
            {
                <#=step.ValueType#> obj = sender.as<<#=step.ValueType#>>();
<#          PushIndent();#>
<#          Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps, false, "DATA_CHANGED");#>
<#          PopIndent();#>
            }
<#      }#>
<#  }#>
<#  if (bindUniverse.NeedsCompleteUpdate) { #>
            CompleteUpdate(DATA_CHANGED);
<#  }#>
        }

        void VectorChanged(IInspectable const& sender, <#=Projection(KnownNamespaces.WindowsFoundationCollections)#>::IVectorChangedEventArgs const& e) override
        {
<#      foreach (var step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true)) { #>
<#          if (step.RequiresChildNotification && (step is PropertyStep || step is CastStep || step is RootStep) && step.ImplementsIObservableVector) { #>
<#              string cacheName = "GetDataRoot()";#>
<#              if (step.RequiresChildNotification && !(step is RootStep)) { #>
<#                  cacheName="cacheVC_" + step.CodeName;#>
<#              }#>
            if (<#=cacheName#> && <#=cacheName#> == sender)
            {
                <#=step.ValueType#> obj = sender.as<<#=step.ValueType#>>();
<#              PushIndent();#>
<#              Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps, false, "DATA_CHANGED");#>
<#              PopIndent();#>
            }
<#          }#>
<#      }#>
<#      if (bindUniverse.NeedsCompleteUpdate) { #>
            CompleteUpdate(DATA_CHANGED);
<#      }#>
        }

        void MapChanged(IInspectable const& sender, <#=Projection(KnownNamespaces.WindowsFoundationCollections)#>::IMapChangedEventArgs<::winrt::hstring> const& e) override
        {
<#      foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true)) { #>
<#          if (step.RequiresChildNotification && (step is PropertyStep || step is CastStep || step is RootStep) && step.ImplementsIObservableMap) { #>
<#              string cacheName = "GetDataRoot()";#>
<#              if (step.RequiresChildNotification && !(step is RootStep)) { #>
<#                  cacheName="cacheMC_" + step.CodeName;#>
<#              }#>
            if (<#=cacheName#> && <#=cacheName#> == sender)
            {
                <#=step.ValueType#> obj = sender.as<<#=step.ValueType#>>();
<#              PushIndent();#>
<#              Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps, false, "DATA_CHANGED");#>
<#              PopIndent();#>
            }
<#          }#>
<#      }#>
<#      if (bindUniverse.NeedsCompleteUpdate) { #>
            CompleteUpdate(DATA_CHANGED);
<#      }#>
        }

        void DependencyPropertyChanged(DependencyObject const& sender, DependencyProperty const& prop) override
        {
            if (sender)
            {
<#      foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true)) { #>
<#          foreach (var child in step.TrackingSteps.OfType<DependencyPropertyStep>()) { #>
                if (sender == cacheDPC_<#=child.CodeName#><#= step is RootStep ? ".get()" : "" #> && <#=child.OwnerType.CppWinRTLocalElseRef()#>::<#=child.PropertyName#>Property() == prop)
                {
                    auto obj = sender.as<<#=step.ValueType#>>();
<#              PushIndent(Indent.TwoTabs);#>
<#              Output_Update_DataChanged_Step(child);#>
<#              PopIndent();#>
                }
<#          }#>
<#      }#>
<#      if (bindUniverse.HasFunctionBindings) { #>
                CompleteUpdate(DATA_CHANGED);
<#      }#>
            }
        }

<# if (ProjectInfo.IsInputValidationEnabled) {#>
        virtual void ErrorsChanged(IInspectable const& sender, <#=Projection(KnownNamespaces.XamlData)#>::DataErrorsChangedEventArgs const& e) override
        {
<#      foreach (BindPathStep step in bindUniverse.INDEIPathSteps)#>
<#      {#>
<#          string cacheName = "GetDataRoot()";#>
<#          if (!(step is RootStep))#>
<#          {#>
<#              cacheName="cacheEC_" + step.CodeName;#>
<#          }#>
            if (<#=cacheName#> != nullptr && <#=cacheName#> == sender)
            {
                auto errorInfo= sender.as<<#=Projection(KnownNamespaces.XamlData)#>::INotifyDataErrorInfo>();
                auto propertyName = e.PropertyName();
                if (propertyName.empty())
                {
<#         foreach (var child in step.TrackingSteps.OfType<PropertyStep>())#>
<#         {#>
<#              Output_UpdateErrorsCall(child);#>
<#         }#>
                }
<#      foreach (string propertyName in step.TrackingSteps.OfType<PropertyStep>().Select(p => p.PropertyName).Distinct())#>
<#      { #>
                else if (propertyName == L"<#=propertyName#>")
                {
<#          foreach (var child in step.TrackingSteps.OfType<PropertyStep>().Where(p => p.PropertyName == propertyName)) #>
<#          { #>
<#              Output_UpdateErrorsCall(child);#>
<#          } #>
                }
            }
<#  }#>
<# }#>
        }
<# void Output_UpdateErrorsCall(PropertyStep step) #>
<# { #>
<#      foreach (var ba in step.AssociatedBindAssignments.Where(ba => ba.IsTrackingTarget)) {#>
                    UpdateErrors(<#=(ba as BindAssignmentBase).ConnectionIdElement.ObjectCodeName #>, errorInfo, L"<#= step.PropertyName #>");
<#      }#>
<#  }#>
<# if (bindUniverse.INDEIPathSteps.Any()) { #>

        void UpdateErrors(<#=Projection(KnownNamespaces.XamlControls)#>::Control const& control, <#=Projection(KnownNamespaces.XamlData)#>::INotifyDataErrorInfo const& sender, ::winrt::hstring propertyName)
        {
            if (auto validationControl = control.try_as<#=Projection(KnownNamespaces.XamlControls)#>::IInputValidationControl>())
            {
                auto validationErrors =  validationControl.ValidationErrors();
                validationErrors.Clear();
                for (const auto& error : sender.GetErrors(propertyName))
                {
                    auto inputValidationError = ::winrt::unbox_value<<#=Projection(KnownNamespaces.XamlControls)#>::InputValidationError>(error);
                    if (inputValidationError == nullptr)
                    {
                        auto errorMessage = ::winrt::unbox_value<::winrt::hstring>(error);
                        if (errorMessage.empty())
                        {
                            if (auto stringable = ::winrt::unbox_value<<#=Projection(KnownNamespaces.WindowsFoundation)#>::IStringable>(error))
                            {
                                errorMessage = stringable.ToString();
                            }
                            else
                            {
                                errorMessage = ::winrt::get_class_name(error);
                            }
                        }
                        inputValidationError = <#=Projection(KnownNamespaces.XamlControls)#>::InputValidationError(errorMessage);
                    }
                    validationErrors.Append(inputValidationError);
                }
            }
        }
<# }#>
<# } #>
<#  } #>
<# Output_BindingSetters(bindUniverse); #>
    }; <# //End of bindings class #>

<#+ private void Output_ConnectionId_Case(ConnectionIdElement element)#>
<#+ {#>
<#+     if (element.BindUniverse.BoundElements.Contains(element)) { #>
<#+     Output_ApiInformationCall_Push(element.ApiInformation, Indent.ThreeTabs); #>
                    auto targetElement = target.as<<#=element.Type#>>();
                    <#=element.ObjectCodeName#> = targetElement;
<#+     foreach (BoundEventAssignment evt in element.BoundEventAssignments) { #>
<#+         Output_ApiInformationCall_Push(evt.ApiInformation, Indent.ThreeTabs); #>
                    targetElement.<#=evt.MemberName#>([this](<#=evt.Parameters.Declaration()#>)
                    {
<#+         if (!evt.PathStep.ValueType.IsDelegate()) { #>
                        <#=evt.PathStep.CodeGen().PathExpression#>;
<#+         } else { #>
                        <#=evt.PathStep.CodeGen().PathExpression#>(<#=evt.Parameters.ForCall()#>);
<#+         }#>
                    });
<#+         Output_ApiInformationCall_Pop(evt.ApiInformation, Indent.ThreeTabs); #>
<#+     }#>
<#+     if (element.CanBeInstantiatedLater && (element.HasBindAssignments || element.HasBoundEventAssignments))#>
<#+     {#>
<#+         // In Connect() we update non-load assignments first, #>
<#+         foreach (var ba in element.BindAssignments.Where(ba => !(ba is BoundLoadAssignment))) #>
<#+         { #>
<#+             PushIndent(Indent.TwoTabs); #>
<#+             Output_Binding_SetValue_Non_Function_Call(ba, ba.ObjectDeferredAssignmentCodeName.CppWinRTName(), false); #>
<#+             PopIndent(); #>
<#+         } #>
<#+     }#>
<#+     foreach (var ba in element.BindAssignments.Where(bindAssignment => bindAssignment.IsTrackingTarget)) { #>
<#+         PushIndent();#>
<#+         Output_Connect_TwoWayBinding(ba);#>
<#+         PopIndent();#>
<#+     }#>
<#+     Output_ApiInformationCall_Pop(element.ApiInformation, Indent.ThreeTabs); #>
<#+     } #>
<#+     if (!element.IsBindingRoot) #>
<#+     { #>
<#+         // Queue load assignments to be updated later, because they're not available yet. #>
<#+         foreach (var childElem in element.Children.Intersect(element.BindUniverse.ElementsWithBoundLoadAssignments)) #>
<#+         { #>
                if (std::find(UnloadedElementsToUpdate.begin(), UnloadedElementsToUpdate.end(), <#=childElem.ConnectionId#>) == UnloadedElementsToUpdate.end())
                {
                    UnloadedElementsToUpdate.push_back(<#=childElem.ConnectionId#>);
                }
<#+         } #>
<#+     } #>
<#+     if (element.CanBeInstantiatedLater && element.HasRootNamedElementStep) { #>
                    this->UnloadableBindingSourcesToUpdate.push_back([this]()
                    {
<#+         PushIndent(Indent.TwoTabs); #>
<#+         Output_Custom_Update_Call(element.RootNamedElementStep, element.RootNamedElementStep.CodeGen().PathExpression.CppWinRTName(), KnownStrings.NotPhased);#>
<#+         PopIndent(); #>
                    });
<#+     } #>
<#+    if (element.TryGetValidationContextStep(out PropertyStep validationStep) && ProjectInfo.IsInputValidationEnabled && ProjectInfo.EnableDefaultValidationContextGeneration) #>
<#+    { #>
<#+        Output_ApiInformationCall_Push(validationStep.ApiInformation, Indent.ThreeTabs); #>
                    <#=Projection(KnownNamespaces.XamlControls)#>::InputValidationContext context(L"<#=validationStep.PropertyName #>", <#=validationStep.IsValueRequired#>);
                    target.as<<#=Projection(KnownNamespaces.XamlControls)#>::IInputValidationControl>().ValidationContext(context);
<#+        Output_ApiInformationCall_Pop(validationStep.ApiInformation, Indent.ThreeTabs); #>
<#+    }#>
<#+  }#>

<#+     private void Output_Listener_Tracking_Fields(BindUniverse bindUniverse)#>
<#+     {#>
<#+         foreach(var cache in GetCacheDeclarations(bindUniverse)) { #>
        <#= cache #>
<#+         }#>
<#+         foreach(var token in GetTokenDeclarations(bindUniverse)) { #>
        <#= token #>
<#+         }#>
<#+     }#>

<#+ private void Output_Connect_TwoWayBinding(BindAssignment ba)#>
<#+ {#>
<#+     Output_ApiInformationCall_Push(ba.ApiInformation, Indent.None); #>
<#+     if (ba.NeedsLostFocusForTwoWay) { #>
                <#=ba.ConnectionIdElement.ReferenceExpression#>.LostFocus(
                    [this] (IInspectable const& sender, <#=Projection(KnownNamespaces.Xaml)#>::RoutedEventArgs const& e)
                    {
<#+     } else { #>
                <#=ba.ConnectionIdElement.ReferenceExpression#>.RegisterPropertyChangedCallback(<#=ba.MemberDeclaringType.CppWinRTLocalElseRef()#>::<#=ba.MemberName#>Property(),
                    [this] (DependencyObject const& sender, DependencyProperty const& prop)
                    {
<#+     } #>
                        if (IsInitialized())
                        {
                            // Update Two Way binding
<#+     MethodStep bindBackStep = ba.BindBackStep as MethodStep; #>
<#+     if (bindBackStep != null) { #>
<#+         var param = bindBackStep.Parameters[0]; #>
                            <#=ba.MemberType#> <#=param.Name#> = <#=ba.ReverseAssignmentExpression#>;
<#+                         Output_NullCheckedAssignment(bindBackStep, null);#>
<#+     } else { #>
<#+                         Output_NullCheckedAssignment(ba.PathStep, ba.ReverseAssignmentExpression);#>
<#+     }#>
                        }
                    });
<#+     Output_ApiInformationCall_Pop(ba.ApiInformation, Indent.None); #>
<#+ } #>

<#+ void  Output_NullCheckedAssignment(BindPathStep step, LanguageSpecificString value) #>
<#+ { #>
<#+     PushIndent(Indent.FourTabs);#>
<#+     foreach (var parent in step.Parents.Where(parent => parent.NeedsCheckForNull)) { #>
            if (<#=parent.CodeGen().PathExpression#> != nullptr)
            {
<#+         PushIndent(); #>
<#+     } #>
<#+     if (value != null) { #>
            <#=step.CodeGen().PathSetExpression(value)#>;
<#+     } else { #>
            <#=step.CodeGen().PathExpression#>;
<#+     } #>
<#+     foreach (var parent in step.Parents.Where(parent => parent.NeedsCheckForNull)) { #>
<#+         PopIndent(); #>
            }
<#+     } #>
<#+     PopIndent();#>
<#+ } #>

<#+     private void Output_UpdateChildListeners_Call(BindPathStep step, string parameter)#>
<#+     {#>
<#+         if (step.NeedsUpdateChildListeners)#>
<#+         {#>
<#+             Output_ApiInformationCall_Push(step.ApiInformation, Indent.OneTab); #>
<#+             if (step.ImplementsINPC) { #>
            _bindingsTracking->UpdatePropertyChangedListener(<#=parameter#>, cachePC_<#=step.CodeName#>, tokenPC_<#=step.CodeName#>);
<#+             }#>
<#+             if (step.ImplementsINDEI && ProjectInfo.IsInputValidationEnabled) { #>
            _bindingsTracking->UpdateErrorsChangedListener(<#=parameter#>, cacheEC_<#=step.CodeName#>, tokenEC_<#=step.CodeName#>);
<#+             }#>
<#+             if (step.ImplementsIObservableVector) { #>
            _bindingsTracking->UpdateVectorChangedListener_<#=step.ValueType.ItemType.MemberFriendlyName()#>(<#=parameter#>, cacheVC_<#=step.CodeName#>, tokenVC_<#=step.CodeName#>);
<#+             }#>
<#+             if (step.ImplementsIObservableMap) { #>
            _bindingsTracking->UpdateMapChangedListener_<#=step.ValueType.ItemType.MemberFriendlyName()#>(<#=parameter#>, cacheMC_<#=step.CodeName#>, tokenMC_<#=step.CodeName#>);
<#+             }#>
<#+             else if (step.ImplementsINCC) { #>
            _bindingsTracking->UpdateCollectionChangedListener(<#=parameter#>, cacheCC_<#=step.CodeName#>, tokenCC_<#=step.CodeName#>);
<#+             }#>
<#+             foreach (var child in step.TrackingSteps.OfType<DependencyPropertyStep>()) { #>
            _bindingsTracking->UpdateDependencyPropertyChangedListener(<#=parameter#>, <#=child.OwnerType.CppWinRTLocalElseRef()#>::<#=child.PropertyName#>Property(), cacheDPC_<#=child.CodeName#>, tokenDPC_<#=child.CodeName#>);
<#+             }#>
<#+             Output_ApiInformationCall_Pop(step.ApiInformation, Indent.OneTab); #>
<#+         }#>
<#+     }#>

<#+ private void Output_Binding_Phased_SetValue(int phase, bool isTracking, BindPathStep bindStep, bool isFunctionResult)#>
<#+ {#>
<#+     var matchingBindAssignments = from ba in bindStep.BindAssignments where ba.ComputedPhase == phase && ba.IsTrackingSource == isTracking select ba;#>
<#+     if (matchingBindAssignments.Count() > 0)#>
<#+     {#>
<#+         string condition =  GetDirectPhaseCondition(phase, isTracking); #>
            if(<#=condition#>)
            {
<#+         PushIndent();#>
<#+         foreach (BindAssignment bindAssignment in matchingBindAssignments)#>
<#+         {#>
<#+             Output_Binding_SetValue(bindAssignment, isFunctionResult);#>
<#+         }#>
<#+         PopIndent();#>
            }
<#+     }#>
<#+ }#>

<#+ private void Output_Binding_Phased_Fallback_SetValue(int phase, bool isTracking, BindPathStep bindStep)#>
<#+ {#>
<#+     var matchingBindAssignments = from ba in bindStep.BindAssignments where ba.ComputedPhase == phase && ba.IsTrackingSource == isTracking && ba.BindStatus.HasFlag(BindStatus.HasFallbackValue) select ba;#>
<#+     if (matchingBindAssignments.Count() > 0)#>
<#+     {#>
<#+         string condition =  GetDirectPhaseCondition(phase, isTracking); #>
            if(<#=condition#>)
            {
<#+         PushIndent();#>
<#+         foreach (BindAssignment bindAssignment in matchingBindAssignments)#>
<#+         {#>
<#+             Output_Binding_SetValue_Non_Function_Call(bindAssignment, bindAssignment.FallbackValueExpression.CppWinRTName(), true);#>
<#+         }#>
<#+         PopIndent();#>
            }
<#+     }#>
<#+ }#>

<#+ private void Output_Binding_SetValue(BindAssignment bindAssignment, bool isFunctionResult)#>
<#+ {#>
<#+         if (bindAssignment.PathStep is FunctionStep && !isFunctionResult)#>
<#+         {#>
            PendingFunctionBindings[L"<#=bindAssignment.PathStep.CodeName#>"] = std::bind(&<#=bindAssignment.BindUniverse.BindingsClassName#>::Invoke_<#=bindAssignment.PathStep.CodeName#>, this, std::placeholders::_1);
<#+         }#>
<#+         else#>
<#+         {#>
<#+             string value = bindAssignment.DirectAssignmentExpression(isFunctionResult ? "result" : "obj").CppWinRTName();#>
<#+             Output_Binding_SetValue_Non_Function_Call(bindAssignment, value, true);#>
<#+         }#>
<#+     }#>

<#+ private void Output_Binding_SetValue_Non_Function_Call(BindAssignment ba, String value, bool includeDeferredSet)#>
<#+ {#>
<#+     var element = ba.ConnectionIdElement;#>
            // <#=element.LineNumberAndXamlFile#>
<#+     Output_ApiInformationCall_Push(ba.ApiInformation, Indent.OneTab); #>
<#+     if (ba is BoundLoadAssignment) { #>
<#+         if (includeDeferredSet) { #>
            <#=ba.ObjectDeferredAssignmentCodeName#> = <#=value#>;

<#+     }#>
            if (<#=value#>)
            {
<#+         if (ba.BindUniverse.IsFileRoot) { #>
                GetDataRoot().FindName(L"<#=element.ElementName#>");
<#+         } else { #>
                <#=ba.BindUniverse.RootElement.ReferenceExpression#>.FindName(L"<#=element.ElementName#>");
<#+         }#>
            }
            else
            {
<#+         if (ba.BindUniverse.IsFileRoot) { #>
                ::winrt::get_self<<#=ba.BindUniverse.DataRootType.CppWinRTLocalElseRef()#>>(GetDataRoot())->UnloadObject(<#=element.ReferenceExpression#>);
<#+         } else { #>
                if (<#=element.ReferenceExpression#>) 
                {
                    <#=Projection(KnownNamespaces.XamlMarkup)#>::XamlMarkupHelper::UnloadObject(<#=element.ReferenceExpression#>);
                }
                DisconnectUnloadedObject(<#=element.ConnectionId#>);
<#+         }#>
            }
<#+     } else { #>
<#+         if (element.NeedsNullCheckBeforeSetValue) {#>
            if (<#=element.ObjectCodeName#>)
            {
<#+             PushIndent();#>
<#+         }#>
<#+         var potentiallyBoxedValue = ba.NeedsBox ? $"::winrt::box_value({value})" : value; #>
<#+         if (ba.MemberType.IsNullable) { #>
            Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(<#=element.ReferenceExpression#>, <#=potentiallyBoxedValue#>, <#=ba.TargetNullValueExpression#>);
<#+         } else {#>
            Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(<#=element.ReferenceExpression#>, <#=potentiallyBoxedValue#>);
<#+         }#>
<#+         if (element.NeedsNullCheckBeforeSetValue) {#>
<#+             PopIndent();#>
            }
<#+             if (includeDeferredSet && element.CanBeInstantiatedLater) { #>
            else
            {
                <#=ba.ObjectDeferredAssignmentCodeName#> = <#=value#>;
            }
<#+             }#>
<#+         }#>
<#+     }#>
<#+     Output_ApiInformationCall_Pop(ba.ApiInformation, Indent.OneTab); #>
<#+ }#>

<#+ private void Output_Update_DataChanged_Step( BindPathStep step)#>
<#+ {#>
<#+     if (step.Parent.ValueType.IsNullable) #>
<#+     {#>
            if (obj)
            {
<#+     }#>
<#+     Output_UpdateCall(step, KnownStrings.DataChanged); #>
<#+     if (step.Parent.ValueType.IsNullable) #>
<#+     {#>
            }
<#+     }#>
<#+     if (step.BindStatus.HasFlag(BindStatus.HasFallbackValue)) #>
<#+     {#>
            else
            {
                UpdateFallback_<#=step.CodeName#>(DATA_CHANGED);
            }
<#+     }#>
<#+ }#>

<#+ private void Output_Update_Steps(bool checkForNull, IEnumerable<BindPathStep> steps, bool checkPhaseCondition, string phaseParam)#>
<#+ {#>
<#+     if (steps.Count() > 0) #>
<#+     {#>
<#+         if (checkForNull) #>
<#+         {#>
            if (obj)
            {
<#+         }#>
<#+         List<BindPathStep> stepsWithFallback = new List<BindPathStep>();#>
<#+         string lastCondition = null;#>
<#+         foreach (BindPathStep childStep in (from step in steps where step.IsIncludedInUpdate orderby step.PhaseList select step))#>
<#+         {#>
<#+             if(checkPhaseCondition) #>
<#+             { #>
<#+                 string thisCondition = GetPhaseCondition(childStep);#>
<#+                 if (thisCondition != lastCondition)#>
<#+                 {#>
<#+                     if (lastCondition != null)#>
<#+                     {#>
                }
<#+                     }#>
<#+                     lastCondition = thisCondition;#>
                if (<#=thisCondition#>)
                {
<#+                 }#>
<#+                 PushIndent();#>
<#+                 Output_UpdateCall(childStep, phaseParam); #>
<#+                 PopIndent();#>
<#+             }#>
<#+             else#>
<#+             {#>
<#+                 if (lastCondition != null)#>
<#+                 {#>
                }
<#+                 }#>
<#+                 lastCondition = null;#>
<#+                 Output_UpdateCall(childStep, phaseParam); #>
<#+             } #>
<#+             if (childStep.BindStatus.HasFlag(BindStatus.HasFallbackValue)) #>
<#+             {#>
<#+               stepsWithFallback.Add(childStep);#>
<#+             }#>
<#+         }#>
<#+                 if (lastCondition != null)#>
<#+                 {#>
                }
<#+                 }#>
<#+         if (checkForNull) #>
<#+         {#>
            }
<#+             if (stepsWithFallback.Count > 0) #>
<#+             {#>
            else
            {
<#+                 foreach (BindPathStep childStep in stepsWithFallback)#>
<#+                 {#>
<#+                     if(checkPhaseCondition) #>
<#+                     { #>
                if (<#=GetPhaseCondition(childStep)#>)
                {
                    UpdateFallback_<#=childStep.CodeName#>(<#=phaseParam#>);
                }
<#+                     } #>
<#+                     else #>
<#+                     { #>
                UpdateFallback_<#=childStep.CodeName#>(<#=phaseParam#>);
<#+                     } #>
<#+                 }#>
            }
<#+             }#>
<#+         }#>
<#+     }#>
<#+ }#>

<#+ private void Output_Custom_Update_Call(BindPathStep step, string firstArgument, string phaseParam)#>
<#+ {#>
<#+     if (string.IsNullOrEmpty(firstArgument)) { #>
                Update_<#=step.CodeName#>(<#=phaseParam#>);
<#+     } else { #>
<#+         Output_ApiInformationCall_Push(step.ApiInformation, Indent.TwoTabs);#>
                Update_<#=step.CodeName#>(<#=firstArgument#>, <#=phaseParam#>);
<#+         Output_ApiInformationCall_Pop(step.ApiInformation, Indent.TwoTabs);#>
<#+     }#>
<#+ }#>

<#+ private void Output_UpdateCall(BindPathStep step, string phaseParam)#>
<#+ {#>
<#+     string firstArgument = step.CodeGen().UpdateCallParam.CppWinRTName(); #>
<#+     Output_Custom_Update_Call(step, firstArgument, phaseParam); #>
<#+ }#>

<#+ private void Output_CompleteUpdate(BindUniverse bindUniverse)#>
<#+ {#>
<#+     List<string> conditions = new List<string>();#>
<#+     bool needsLoop = bindUniverse.UnloadableBindingSourceElements.Any(); #>

        void CompleteUpdate(int phase)
        {
<#+     if (needsLoop) { #>
            do
            {
<#+         PushIndent(); #>
<#+     } #>
<#+     if (bindUniverse.HasFunctionBindings) { #>
        auto copiedBindings = std::move(PendingFunctionBindings);
        PendingFunctionBindings = std::map<::std::wstring, std::function<void (int)>>();

        for(auto& pair : copiedBindings)
        {
            pair.second(phase);
        }
<#+         conditions.Add("!this->PendingFunctionBindings.empty()"); #>
<#+     } #>
<#+     if (bindUniverse.UnloadableBindingSourceElements.Any()) {#>
            while (!this->UnloadableBindingSourcesToUpdate.empty())
            {
                this->UnloadableBindingSourcesToUpdate.front()();
                this->UnloadableBindingSourcesToUpdate.pop_front();
            }
<#+         conditions.Add("!this->UnloadableBindingSourcesToUpdate.empty()"); #>
<#+     } #>
<#+     if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) { #>
            while (!UnloadedElementsToUpdate.empty())
            {
                UpdateUnloadedElement(UnloadedElementsToUpdate.front());
                UnloadedElementsToUpdate.pop_front();
            }
<#+         conditions.Add("!this->UnloadedElementsToUpdate.empty()"); #>
<#+     } #>
<#+     if (needsLoop) { #>
<#+         PopIndent(); #>
            }
            while (<#=string.Join(" || ", conditions)#>);
<#+     } #>
        }
<#+ }#>

<#+ private void Output_FunctionBindings(BindUniverse bindUniverse)#>
<#+ {#>
        std::map<::std::wstring, std::function<void (int)>> PendingFunctionBindings;

<#+     foreach (FunctionStep functionStep in bindUniverse.BindPathSteps.Values.Where(s => s is FunctionStep))#>
<#+     {#>

        void Invoke_<#=functionStep.CodeName#>(int phase)
        {
<#+         foreach (var param in functionStep.Parameters.OrderBy(p => p.HasTryGetValue)) {#>
<#+             if (param.HasTryGetValue && functionStep.RequiresSafeParameterRetrieval) {#>
<#+                 if (param.AssignmentType.IsNullable) {#>
            <#=param.AssignmentType#> <#=param.Name#> = nullptr;
<#+                 } else { #>
            <#=param.AssignmentType#> <#=param.Name#>;
<#+                 }#>
            if (!<#=param.TryGetValueCodeName#>(<#=param.Name#>)) { return; }
<#+             } else {#>
            <#=param.ValueType#> <#=param.Name#> = <#=param.CodeGen().PathExpression#>;
<#+             }#>
<#+         }#>
            <#=functionStep.ValueType#> result = <#= functionStep.CodeGen().PathExpression #>;
<#+         foreach (int distinctPhase in functionStep.DistinctPhases) {#>
<#+             Output_Binding_Phased_SetValue(distinctPhase, true, functionStep, true);#>
<#+             Output_Binding_Phased_SetValue(distinctPhase, false, functionStep, true);#>
<#+         }#>
        }
<#+     }#>
<#+ }#>

<#+ private void Output_TryGetValueFunctions(BindUniverse bindUniverse)#>
<#+ {#>
<#+     foreach (BindPathStep step in bindUniverse.TryGetValueSteps)#>
<#+     {#>

        bool <#=step.TryGetValueCodeName#>(<#=step.ValueType#>& val)
        {
<#+         if (step is RootStep || !step.Parent.IsIncludedInUpdate) {#>
            val = <#=step.CodeGen().PathExpression#>;
            return true;
<#+         }#>
<#+         else {#>
<#+             if (step.Parent.ValueType.IsNullable) {#>
            <#=step.Parent.ValueType#> obj{nullptr};
            if (<#=step.Parent.TryGetValueCodeName#>(obj) && obj)
<#+             } else { #>
            <#=step.Parent.ValueType#> obj;
            if (<#=step.Parent.TryGetValueCodeName#>(obj))
<#+             } #>
            {
                val = <#=step.CodeGen().UpdateCallParam#>;
                return true;
            }
            else
            {
                return false;
            }
<#+         }#>
        }
<#+     }#>
<#+ }#>

<#+ private void Output_BindingSetValueFunction(BindAssignment ba)#>
<#+ {#>
<#+     if (ba.MemberType.IsNullable) { #>

        static void Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(<#=ba.MemberTargetType#> const& obj, <#=ba.MemberType#> value, std::optional<::winrt::hstring> const& targetNullValue)
        {
            if (!value && targetNullValue)
            {
                value = <#=ba.MemberType.GetStringToThing("targetNullValue.value()")#>;
            }
<#+     } else { #>

        static void Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(<#=ba.MemberTargetType#> const& obj, <#=ba.MemberType#> const& value)
        {
<#+     }#>
<#+     if (ba.IsAttachable) { #>
            <#=ba.MemberDeclaringType#>::Set<#=ba.MemberName#>(obj, value);
<#+     } else { #>
            obj.<#=ba.MemberName#>(value);
<#+     }#>
        }
<#+ }#>


<#+     private string GetCacheArgumentStatement(BindPathStep step, string prefix, BindPathStep child)#>
<#+     {#>
<#+         return String.Format("{0}{1}",  prefix, child.CodeName);#>
<#+     }#>

<#+ private void Output_BindingSetters(BindUniverse bu)
{
    var distinctAsignmentsByMember = from ba in bu.BindAssignments.Where(ba => ba.HasSetValueHelper) group ba by ba.MemberFullName;
    foreach (var item in distinctAsignmentsByMember) {
        Output_BindingSetValueFunction(item.First());
    }
}#>

<#+ private void Output_ApiInformationCall_Push(ApiInformation apiInformation, Indent indent)#>
<#+ {#>
<#+     if (apiInformation != null) { #>
<#+         PushIndent(indent); #>
        if (<#=Model.CodeInfo.ClassName.ShortName#>_<#= apiInformation.MemberFriendlyName #>)
        {
<#+         PopIndent(); #>
<#+         PushIndent(); #>
<#+     } #>
<#+ } #>

<#+ private void Output_ApiInformationCall_Pop(ApiInformation apiInformation, Indent indent)#>
<#+ {#>
<#+     if (apiInformation != null) { #>
<#+         PopIndent(); #>
<#+         PushIndent(indent); #>
        }
<#+         PopIndent(); #>
<#+     } #>
<#+ } #>