// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 17.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.UI.Xaml.Markup.Compiler.CodeGen
{
    using System.Collections.Generic;
    using System.Linq;
    using System.Xaml;
    using Microsoft.UI.Xaml.Markup.Compiler.Properties;
    using Microsoft.UI.Xaml.Markup.Compiler.Utilities;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
    internal partial class CppWinRT_PagePass2 : CppWinRT_CodeGenerator<PageDefinition>
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"
//------------------------------------------------------------------------------
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//------------------------------------------------------------------------------
");
  if(!String.IsNullOrEmpty(ProjectInfo.PrecompiledHeaderFile)) { 
            this.Write("#include \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(ProjectInfo.PrecompiledHeaderFile));
            this.Write("\"\r\n");
  }
  foreach (var includeFile in Model.NeededLocalXamlHeaderFiles) { 
            this.Write("#include \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(includeFile));
            this.Write("\"\r\n");
  }
            this.Write("\r\n#pragma warning(push)\r\n#pragma warning(disable: 4100) // unreferenced formal pa" +
                    "rameter\r\n\r\nnamespace winrt::");
            this.Write(this.ToStringHelper.ToStringWithCulture(Colonize(Model.CodeInfo.ClassName.Namespace)));
            this.Write("::implementation\r\n{\r\n\r\n");
  if (Model.CodeInfo.IsUsingCompiledBinding && Model.CodeInfo.BindUniverses.Any(bu => bu.BindAssignments.Any(ba => ba.HasSetValueHelper))) { 
      if (ProjectInfo.GenerateCppWinRTStaticAsserts) { 
            this.Write("\r\n    namespace ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Colonize(Model.CodeInfo.ClassName.ShortName)));
            this.Write("_staticasserts\r\n    {\r\n        template<typename, typename = void>\r\n        const" +
                    "expr bool is_type_complete_v = false;\r\n\r\n        template<typename T>\r\n        c" +
                    "onstexpr bool is_type_complete_v<T, std::void_t<decltype(sizeof(T))>> = true;\r\n\r" +
                    "\n");
          foreach (var bindUniverse in Model.CodeInfo.BindUniverses) { 
              var distinctAsignmentsByMember = from ba in bindUniverse.BindAssignments.Where(ba => ba.HasSetValueHelper) group ba by ba.MemberFullName; 
              foreach (var item in distinctAsignmentsByMember) { 
                  Output_StaticAssertTypeIsComplete(item.First().MemberType, Indent.TwoTabs); 
                  Output_StaticAssertTypeIsComplete(item.First().MemberDeclaringType, Indent.TwoTabs); 
              } 
          } 
            this.Write("\r\n    }\r\n\r\n");
      } 
  } 
            this.Write("\r\n    using Application = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.Xaml)));
            this.Write("::Application;\r\n    using ComponentResourceLocation = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlControlsPrimitives)));
            this.Write("::ComponentResourceLocation;\r\n    using DataTemplate = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.Xaml)));
            this.Write("::DataTemplate;\r\n    using DependencyObject = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.Xaml)));
            this.Write("::DependencyObject;\r\n    using DependencyProperty = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.Xaml)));
            this.Write("::DependencyProperty;\r\n    using IComponentConnector = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));
            this.Write("::IComponentConnector;\r\n    using Uri = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsFoundation)));
            this.Write("::Uri;\r\n    using XamlBindingHelper = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));
            this.Write("::XamlBindingHelper;\r\n\r\n");
  if (Model.ApiInformationDeclarations.Any()) { 
            this.Write("    // Api Information for conditional namespace declarations\r\n");
      foreach (var apiInformation in Model.ApiInformationDeclarations) { 
            this.Write("    bool ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));
            this.Write("_");
            this.Write(this.ToStringHelper.ToStringWithCulture(apiInformation.MemberFriendlyName));
            this.Write(";\r\n");
      } 
            this.Write("\r\n");
  } 
 Output_InitializeComponent(); 
            this.Write("\r\n");
 Output_ConnectMethod(); 
            this.Write("\r\n");
   if (Model.UnloadableFields.Count() > 0) { 
        Output_UnloadMethods(); 
   } else { 
        Output_EmptyUnloadMethods(); 
   } 
            this.Write("\r\n");
 if (Model.CodeInfo.BindStatus != BindStatus.None) { 
      Output_GetBindingConnectorMethod(); 
 } else { 
      Output_EmptyGetBindingConnectorMethod(); 
 } 
  if (Model.CodeInfo.IsUsingCompiledBinding) { 
      foreach (BindUniverse bindUniverse in Model.CodeInfo.BindUniverses) { 
          if (bindUniverse.NeedsCppBindingTrackingClass) { 
            this.Write("\r\n");
          IncludeTemplate<CppWinRT_PageBindingTracking>(Model, bindUniverse); 
          } 
            this.Write("\r\n");
          IncludeTemplate<CppWinRT_PageBinding>(Model, bindUniverse); 
      }
 } 
            this.Write("\r\n    template struct ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));
            this.Write("T<struct ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));
            this.Write(">;\r\n}\r\n\r\n");
 if (ProjectInfo.GenerateIncrementalTypeInfo) { 
            this.Write("\r\nnamespace winrt::");
            this.Write(this.ToStringHelper.ToStringWithCulture(Colonize(ProjectInfo.RootNamespace)));
            this.Write("::implementation\r\n{\r\n");
      foreach(var entry in Model.TypeInfos.Where(t => t.StandardName == Model.CodeInfo.ClassType.StandardName)) { 
        IncludeTemplate<CppWinRT_MetadataDelegates>(entry, false); 
      } 
            this.Write("}\r\n");
  } 
            this.Write("\r\n#pragma warning(pop)\r\n\r\n");
            return this.GenerationEnvironment.ToString();
        }
 private void Output_InitializeComponent() { 
     string defaultUri = Model.GetLoadComponentUri(Model.CodeInfo.PriIndexName, Model.CodeInfo.BaseApparentRelativePath);
     string loadType = !String.IsNullOrEmpty(Model.CodeInfo.XamlComponentResourceLocation) ? Model.CodeInfo.XamlComponentResourceLocation : (ProjectInfo.IsLibrary ? "Nested" : "Application"); 
this.Write("    template <typename D, typename ... I>\r\n    void ");

this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));

this.Write("T<D, I...>::InitializeComponent()\r\n    {\r\n");

     if(Model.CodeInfo.PerXamlFileInfo.Count > 1) { 
this.Write("        InitializeComponent(Uri(L\"");

this.Write(this.ToStringHelper.ToStringWithCulture(defaultUri));

this.Write("\"));\r\n    }\r\n\r\n    template <typename D, typename ... I>\r\n    void ");

this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));

this.Write("T<D, I...>::InitializeComponent(Uri const& resourceLocator)\r\n    {\r\n");

     }
this.Write("        if (!_contentLoaded)\r\n        {\r\n            _contentLoaded = true;\r\n");

     if (Model.ApiInformationDeclarations.Any()) { 
         foreach (var apiInformation in Model.ApiInformationDeclarations) { 
this.Write("            ");

this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));

this.Write("_");

this.Write(this.ToStringHelper.ToStringWithCulture(apiInformation.MemberFriendlyName));

this.Write(" = ");

this.Write(this.ToStringHelper.ToStringWithCulture(apiInformation.CodeGen().CallExpression));

this.Write(";\r\n");

         } 
this.Write(" \r\n");

     } 
     if(Model.CodeInfo.PerXamlFileInfo.Count <= 1) { 
this.Write("            ::winrt::Windows::Foundation::Uri resourceLocator{ L\"");

this.Write(this.ToStringHelper.ToStringWithCulture(defaultUri));

this.Write("\" };\r\n");

     } 
this.Write("            ");

this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.Xaml)));

this.Write("::Application::LoadComponent(*this, resourceLocator, ComponentResourceLocation::");

this.Write(this.ToStringHelper.ToStringWithCulture(loadType));

this.Write(");\r\n        }\r\n    }\r\n");

 } 
 private void Output_ConnectMethod()
 {
     if (Model.ConnectableElements.Any()) { 
this.Write("    template <typename D, typename ... I>\r\n    void ");

this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));

this.Write("T<D, I...>::Connect(int32_t connectionId, IInspectable const& target)\r\n    {\r\n");

         if(Model.ConnectableElements.Any()) { 
this.Write("        switch (connectionId)\r\n        {\r\n");

             foreach (var element in Model.ConnectableElements) { 
this.Write("        case ");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ConnectionId));

this.Write(":\r\n            {\r\n");

                 Output_ConnectionId_Case(element); 
this.Write("            }\r\n            break;\r\n");

             }
this.Write("        }\r\n");

         }
     } else { 
this.Write("    template <typename D, typename... I>\r\n    void ");

this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));

this.Write("T<D, I...>::Connect(int32_t, IInspectable const&)\r\n    {\r\n");

     } 
this.Write("        _contentLoaded = true;\r\n    }\r\n");

 }
 private void Output_EmptyUnloadMethods()
 {
this.Write("    template <typename D, typename ... I>\r\n    void ");

this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));

this.Write("T<D, I...>::DisconnectUnloadedObject(int32_t)\r\n    {\r\n        throw ::winrt::hres" +
        "ult_invalid_argument { L\"No unloadable objects to disconnect.\" };\r\n    }\r\n\r\n    " +
        "template <typename D, typename ... I>\r\n    void ");

this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));

this.Write("T<D, I...>::UnloadObject(DependencyObject const&)\r\n    {\r\n        throw ::winrt::" +
        "hresult_invalid_argument { L\"No unloadable objects.\" };\r\n    }\r\n");

 } 
 private void Output_UnloadMethods()
 {
this.Write("    template <typename D, typename ... I>\r\n    void ");

this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));

this.Write("T<D, I...>::UnloadObject(DependencyObject const& unloadableObject)\r\n    {\r\n      " +
        "  if (unloadableObject)\r\n        {\r\n");

         foreach (var element in Model.UnloadableFields) { 
this.Write("            // ");

this.Write(this.ToStringHelper.ToStringWithCulture(element.LineNumberAndXamlFile));

this.Write("\r\n");

             Output_ApiInformationCall_Push(element.ApiInformation, Indent.OneTab); 
this.Write("            if (unloadableObject == ");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ElementName));

this.Write("())\r\n            {\r\n                DisconnectUnloadedObject(");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ConnectionId));

this.Write(");\r\n            }\r\n");

             Output_ApiInformationCall_Pop(element.ApiInformation, Indent.OneTab); 
         } 
this.Write("            ");

this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));

this.Write("::XamlMarkupHelper::UnloadObject(unloadableObject);\r\n        }\r\n    }\r\n\r\n    temp" +
        "late <typename D, typename ... I>\r\n    void ");

this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));

this.Write("T<D, I...>::DisconnectUnloadedObject(int32_t connectionId)\r\n    {\r\n        switch" +
        "(connectionId)\r\n        {\r\n");

         foreach (var element in Model.DeferrableElements)
         {
this.Write("            case ");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ConnectionId));

this.Write(": // ");

this.Write(this.ToStringHelper.ToStringWithCulture(element.LineNumberAndXamlFile));

this.Write("\r\n            {\r\n");

             foreach (var childElem in element.Children) 
             {
                 if (childElem.HasFieldDefinition) 
                 {
this.Write("                DisconnectUnloadedObject(");

this.Write(this.ToStringHelper.ToStringWithCulture(childElem.ConnectionId));

this.Write(");\r\n");

                 }
                 if (childElem.HasBindAssignments || element.HasRootNamedElementStep) 
                 {
this.Write("                Bindings->DisconnectUnloadedObject(");

this.Write(this.ToStringHelper.ToStringWithCulture(childElem.ConnectionId));

this.Write(");\r\n");

                 }
             }
             if (element.HasBindAssignments || element.HasRootNamedElementStep) 
             {
this.Write("                Bindings->DisconnectUnloadedObject(");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ConnectionId));

this.Write(");\r\n");

             }
             FieldDefinition fieldInfo = element.FieldDefinition; 
             if(fieldInfo != null) 
             { 
                 Output_ApiInformationCall_Push(element.ApiInformation, Indent.TwoTabs); 
this.Write("                ");

this.Write(this.ToStringHelper.ToStringWithCulture(fieldInfo.FieldName));

this.Write("(nullptr);\r\n");

                 Output_ApiInformationCall_Pop(element.ApiInformation, Indent.TwoTabs); 
             } 
this.Write("                break;\r\n            }\r\n");

         }
this.Write("            default:\r\n            {\r\n                throw hresult_invalid_argume" +
        "nt(L\"Invalid connectionId.\");\r\n            }\r\n        }\r\n    }\r\n");

 }
 private void Output_ConnectionId_Case(ConnectionIdElement element)
 {
     string objectName = element.ElementCodeName;
     Output_PushDeprecated(element.Type.IsDeprecated()); 
     Output_ApiInformationCall_Push(element.ApiInformation, Indent.TwoTabs); 
this.Write("                auto targetElement = target.as<");

this.Write(this.ToStringHelper.ToStringWithCulture(element.Type));

this.Write(">();\r\n");

     if (element.HasFieldDefinition) {
         objectName = $"{element.FieldDefinition.FieldName}()"; 
this.Write("                this->");

this.Write(this.ToStringHelper.ToStringWithCulture(element.FieldDefinition.FieldName));

this.Write("(targetElement);\r\n");

     }
     if (element.EventAssignments.Any()) { 
this.Write("                auto weakThis = ::winrt::make_weak<class_type>(*this);\r\n");

     } 
     foreach (EventAssignment ev in element.EventAssignments) { 
         Output_ApiInformationCall_Push(ev.ApiInformation, Indent.TwoTabs); 
this.Write("                targetElement.");

this.Write(this.ToStringHelper.ToStringWithCulture(ev.EventName));

this.Write("([weakThis](");

this.Write(this.ToStringHelper.ToStringWithCulture(ev.Parameters.Declaration()));

this.Write("){\r\n                    if (auto t = weakThis.get())\r\n                    {\r\n    " +
        "                    ::winrt::get_self<D>(t)->");

this.Write(this.ToStringHelper.ToStringWithCulture(ev.HandlerName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(ev.Parameters.ForCall()));

this.Write(");\r\n                    }\r\n                });\r\n");

         Output_ApiInformationCall_Pop(ev.ApiInformation, Indent.TwoTabs); 
     } 
     Output_ApiInformationCall_Pop(element.ApiInformation, Indent.TwoTabs); 
     Output_PopDeprecated(element.Type.IsDeprecated()); 
 }
 private void Output_EmptyGetBindingConnectorMethod()
 {
this.Write("\r\n    template <typename D, typename... I>\r\n    IComponentConnector ");

this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));

this.Write("T<D, I...>::GetBindingConnector(int32_t, IInspectable const&)\r\n    {\r\n        ret" +
        "urn nullptr;\r\n    }\r\n");

 } 
 private void Output_GetBindingConnectorMethod()
 {
this.Write("    template <typename D, typename... I>\r\n    IComponentConnector ");

this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));

this.Write("T<D, I...>::GetBindingConnector(int32_t connectionId, IInspectable const& target)" +
        "\r\n    {\r\n        ::winrt::com_ptr<");

this.Write(this.ToStringHelper.ToStringWithCulture(Projection(ProjectInfo.RootNamespace)));

this.Write("::implementation::XamlBindings> bindings;\r\n        switch (connectionId)\r\n       " +
        " {\r\n");

     foreach (var element in Model.AllConnectionIdElements) { 
         if (element.IsBindingRoot) { 
this.Write("            case ");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ConnectionId));

this.Write(": // ");

this.Write(this.ToStringHelper.ToStringWithCulture(element.LineNumberAndXamlFile));

this.Write("\r\n                {\r\n");

             Output_PushDeprecated(element.Type.IsDeprecated());
                 if (element.Type.IsDerivedFromControlTemplate()) 
                 {
this.Write("                    if (auto ");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ElementTemplatedParentCodeName));

this.Write(" = target.try_as<");

this.Write(this.ToStringHelper.ToStringWithCulture(element.TemplatedParentType));

this.Write(">())\r\n                    {\r\n                        auto objBindings = std::make" +
        "_unique<");

this.Write(this.ToStringHelper.ToStringWithCulture(element.BindUniverse.BindingsClassName));

this.Write(">();\r\n                        objBindings->SetDataRoot(");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ElementTemplatedParentCodeName));

this.Write(");\r\n                        bindings = ::winrt::make_self<");

this.Write(this.ToStringHelper.ToStringWithCulture(Projection(ProjectInfo.RootNamespace)));

this.Write("::implementation::XamlBindings>(std::move(objBindings));\r\n                       " +
        " XamlBindingHelper::SetDataTemplateComponent(");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ElementTemplatedParentCodeName));

this.Write(", bindings.as<");

this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));

this.Write("::IDataTemplateComponent>());\r\n                    }\r\n");

                 } else {
this.Write("                    auto ");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ElementCodeName));

this.Write(" = target.as<");

this.Write(this.ToStringHelper.ToStringWithCulture(element.Type));

this.Write(">();\r\n                    auto objBindings = std::make_unique<");

this.Write(this.ToStringHelper.ToStringWithCulture(element.BindUniverse.BindingsClassName));

this.Write(">();\r\n                    objBindings->SetDataRoot(");

this.Write(this.ToStringHelper.ToStringWithCulture(element.IsBindingFileRoot ? "*this" : element.ElementCodeName + ".DataContext()"));

this.Write(");\r\n");

                     if (element.BindUniverse.DistinctConvertersUsed.Count() > 0) { 
this.Write("                    objBindings->SetConverterLookupRoot(*this);\r\n");

                     }
this.Write("                    bindings = ::winrt::make_self<");

this.Write(this.ToStringHelper.ToStringWithCulture(Projection(ProjectInfo.RootNamespace)));

this.Write("::implementation::XamlBindings>(std::move(objBindings));\r\n");

                     if (element.IsBindingFileRoot) { 
this.Write("                    Bindings = bindings;\r\n");

                         if (element.Type.IsDerivedFromWindow()) { 
this.Write("                    ");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ElementCodeName));

this.Write(".Activated({&*bindings, &");

this.Write(this.ToStringHelper.ToStringWithCulture(Projection(ProjectInfo.RootNamespace)));

this.Write("::implementation::XamlBindings::Activated});\r\n");

                         } 
                         else { 
this.Write("                    ");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ElementCodeName));

this.Write(".Loading({&*bindings, &");

this.Write(this.ToStringHelper.ToStringWithCulture(Projection(ProjectInfo.RootNamespace)));

this.Write("::implementation::XamlBindings::Loading});\r\n");

                         } 
                     } else { 
this.Write("                    bindings->SubscribeForDataContextChanged(");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ElementCodeName));

this.Write(");\r\n                    DataTemplate::SetExtensionInstance(");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ElementCodeName));

this.Write(", bindings.as<");

this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.Xaml)));

this.Write("::IDataTemplateExtension>());\r\n                    XamlBindingHelper::SetDataTemp" +
        "lateComponent(");

this.Write(this.ToStringHelper.ToStringWithCulture(element.ElementCodeName));

this.Write(", bindings.as<");

this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));

this.Write("::IDataTemplateComponent>());\r\n");

                     }
                 }
                 Output_PopDeprecated(element.Type.IsDeprecated()); 
this.Write("                }\r\n                break;\r\n");

             }
         }
this.Write("        }\r\n        return bindings ? bindings.as<");

this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));

this.Write("::IComponentConnector>() : nullptr;\r\n    }\r\n");

 }
     private void Output_PushDeprecated(bool isDeprecated)
     {
         if (isDeprecated) 
         { 
this.Write("#pragma warning( push )\r\n#pragma warning( disable : 4973 )\r\n");

         } 
     }
     private void Output_PopDeprecated(bool isDeprecated)
     {
         if (isDeprecated) 
         { 
this.Write("#pragma warning( pop )\r\n");

         } 
     }
 private void Output_ApiInformationCall_Push(ApiInformation apiInformation, Indent indent)
 {
     if (apiInformation != null) { 
         PushIndent(indent); 
this.Write("        if (");

this.Write(this.ToStringHelper.ToStringWithCulture(Model.CodeInfo.ClassName.ShortName));

this.Write("_");

this.Write(this.ToStringHelper.ToStringWithCulture(apiInformation.MemberFriendlyName));

this.Write(")\r\n        {\r\n");

         PopIndent(); 
         PushIndent(); 
     } 
 } 
 private void Output_ApiInformationCall_Pop(ApiInformation apiInformation, Indent indent)
 {
     if (apiInformation != null) { 
         PopIndent(); 
         PushIndent(indent); 
this.Write("        }\r\n");

         PopIndent(); 
     } 
 } 
 HashSet<XamlType> staticAssertTypes = new HashSet<XamlType>();
 private void Output_StaticAssertTypeIsComplete(XamlType type, Indent indent = Indent.None)
 {
     if(!XamlSchemaCodeInfo.IsProjectedPrimitiveCppType(type.ToString()) && !type.IsArray && !staticAssertTypes.Contains(type))
     {
         staticAssertTypes.Add(type);
         PushIndent(indent);
         if(!String.IsNullOrEmpty(ProjectInfo.PrecompiledHeaderFile))
         {
this.Write("static_assert( is_type_complete_v<");

this.Write(this.ToStringHelper.ToStringWithCulture(type));

this.Write(">, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(ResourceUtilities.FormatString(XamlCompilerResources.XamlCompiler_CodeGenStaticAssert_IncompleteType, this.ToStringHelper.ToStringWithCulture(type), ProjectInfo.PrecompiledHeaderFile)));

this.Write("\" );\r\n");

         }
         else
         {
this.Write("static_assert( is_type_complete_v<");

this.Write(this.ToStringHelper.ToStringWithCulture(type));

this.Write(">, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(ResourceUtilities.FormatString(XamlCompilerResources.XamlCompiler_CodeGenStaticAssert_IncompleteType_NoPch, this.ToStringHelper.ToStringWithCulture(type))));

this.Write("\" );\r\n");

         }
         PopIndent();
     }
 }
    }
}
