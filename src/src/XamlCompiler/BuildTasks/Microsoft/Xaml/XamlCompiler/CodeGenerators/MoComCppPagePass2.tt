<#@ template language="C#" inherits="CppCX_CodeGenerator<PageDefinition>" visibility="internal" linePragmas="false"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xaml" #>
//------------------------------------------------------------------------------
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//------------------------------------------------------------------------------
<#  if(!String.IsNullOrEmpty(ProjectInfo.PrecompiledHeaderFile)) { #>
#include "<#=ProjectInfo.PrecompiledHeaderFile#>"
<#  }#>

#pragma warning(push)
#pragma warning(disable: 4100) // unreferenced formal parameter

#if defined _DEBUG && !defined DISABLE_XAML_GENERATED_BINDING_DEBUG_OUTPUT
extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
#endif

<# foreach(string includeFile in Model.NeededLocalXamlHeaderFiles)#>
<# {#>
#include "<#=includeFile#>"
<# }#>
<# Output_ApiInformationDeclarations(); #>

<# Output_InitializeComponent(); #>

<# if (Model.CodeInfo.IsUsingCompiledBinding) #>
<# { #>
<#     Output_BindingsClasses();  #>

<# } #>
<# Output_ConnectMethod(); #>
<# Output_UnloadObjectMethod(); #>

<# Output_GetBindingConnectorMethod(); #>
<# Output_InitializeXProperties(); #>
<# if (ProjectInfo.GenerateIncrementalTypeInfo) { #>

<#      foreach(var entry in Model.TypeInfos.Where(t => t.StandardName == Model.CodeInfo.ClassType.StandardName)) { #>
<#        IncludeTemplate<CXMetadataDelegates>(entry, false); #>
<#      } #>
<#  } #>

#pragma warning(pop)

<#+ private void Output_InitializeComponent() #>
<#+ { #>
<#+         string defaultUri = Model.GetLoadComponentUri(Model.CodeInfo.PriIndexName, Model.CodeInfo.BaseApparentRelativePath);#>
void <#=Model.CodeInfo.ClassType.FullName#>::InitializeComponent()
{
<#+     if(Model.CodeInfo.PerXamlFileInfo.Count > 1)#>
<#+     {#>
    this->InitializeComponent(nullptr);
}

void <#=Model.CodeInfo.ClassType.FullName#>::InitializeComponent(::Windows::Foundation::Uri^ resourceLocator)
{
<#+     }#>
    if (_contentLoaded)
    {
        return;
    }
    _contentLoaded = true;
<#+         if (Model.XProperties.Any()) #>
<#+         { #>
    InitializeXProperties();
<#+         } #>
<#+ Output_ApiInformationInit(); #>
<#+     if(Model.CodeInfo.PerXamlFileInfo.Count > 1)#>
<#+     {#>
    if (resourceLocator == nullptr)
    {
        resourceLocator = ref new ::Windows::Foundation::Uri(L"<#=defaultUri#>");
    }
<#+     }#>
<#+     else#>
<#+     {#>
    ::Windows::Foundation::Uri^ resourceLocator = ref new ::Windows::Foundation::Uri(L"<#=defaultUri#>");
<#+     }#>
<#+     string loadType = (ProjectInfo.IsLibrary) ? "Nested" : "Application"; #>
<#+    if(!String.IsNullOrEmpty(Model.CodeInfo.XamlComponentResourceLocation)) #>
<#+    { #>
    <#=Projection(KnownNamespaces.Xaml)#>::Application::LoadComponent(this, resourceLocator, <#=Projection(KnownNamespaces.XamlControlsPrimitives)#>::ComponentResourceLocation::<#=Model.CodeInfo.XamlComponentResourceLocation#>);
<#+    } #>
<#+    else #>
<#+    { #>
    <#=Projection(KnownNamespaces.Xaml)#>::Application::LoadComponent(this, resourceLocator, <#=Projection(KnownNamespaces.XamlControlsPrimitives)#>::ComponentResourceLocation::<#=loadType#>);
<#+    } #>
}
<#+ } #>

<#+     private void Output_InitializeXProperties() #>
<#+     { #>
<#+         if (Model.XProperties.Any()) #>
<#+         { #>

void <#=Model.CodeInfo.ClassType.FullName#>::InitializeXProperties()
{
<#+             foreach (xProperty xProp in Model.XProperties) #>
<#+             { #>
<#+                 if (xProp.DefaultValueString != null) #>
<#+                 { #>
    _<#=xProp.Name#> = <#=xProp.PropertyType.GetStringToThing($"\"{xProp.DefaultValueString}\"")#>;
<#+                 } #>
<#+                 if (xProp.DefaultValueMarkup != null) #>
<#+                 { #>
    _<#=xProp.Name#> = (<#=xProp.PropertyType.CppCXName()#>)(<#=Projection(KnownNamespaces.XamlMarkup)#>::Load(<#=xProp.DefaultValueMarkup#>));
<#+                 } #>
<#+             } #>
        }
<#+         } #>
<#+     } #>
<#+ private void Output_ConnectMethod()#>
<#+ {#>
<#+     bool usedTarget = false;#>
void <#=Model.CodeInfo.ClassType.FullName#>::Connect(int __connectionId, ::Platform::Object^ __target)
{
<#+     if(Model.ConnectableElements.Any()) #>
<#+     {#>
    switch (__connectionId)
    {
<#+         foreach (ConnectionIdElement element in Model.ConnectableElements)#>
<#+         {#>
    case <#=element.ConnectionId#>:
        {
<#+             Output_ConnectionId_Case(element);#>
<#+             usedTarget= true;  #>
        }
        break;
<#+         }#>
    }
<#+     }#>
<#+     else #>
<#+     {#>
    __connectionId;         // unreferenced 
<#+     }#>
<#+     if (!usedTarget)#>
<#+     {#>
    __target;               // unreferenced
<#+     }#>
    _contentLoaded = true;
}
<#+ }#>

<#+ private void Output_UnloadObjectMethod()#>
<#+ {#>
<#+     if (Model.UnloadableFields.Count() > 0)#>
<#+     {#>

void <#=Model.CodeInfo.ClassType.FullName#>::UnloadObject(<#=Projection(KnownNamespaces.Xaml)#>::DependencyObject^ unloadableObject)
{
    if (unloadableObject != nullptr)
    {
<#+         foreach (var element in Model.UnloadableFields) { #>
        // <#=element.LineNumberAndXamlFile#>
<#+             Output_ApiInformationCall_Push(element.ApiInformation, Indent.OneTab); #>
        if (unloadableObject == this-><#=element.ElementName#>)
        {
            this->DisconnectUnloadedObject(<#=element.ConnectionId#>);
        }
<#+             Output_ApiInformationCall_Pop(element.ApiInformation, Indent.OneTab); #>
<#+         } #>
        <#=Projection(KnownNamespaces.XamlMarkup)#>::XamlMarkupHelper::UnloadObject(unloadableObject);
    }
}

void <#=Model.CodeInfo.ClassType.FullName#>::DisconnectUnloadedObject(int connectionId)
{
    switch(connectionId)
    {
<#+         foreach (var element in Model.DeferrableElements)#>
<#+         {#>
        case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
        {
<#+             foreach (var childElem in element.Children) #>
<#+             {#>
<#+                 if (childElem.HasFieldDefinition) #>
<#+                 {#>
            this->DisconnectUnloadedObject(<#=childElem.ConnectionId#>);
<#+                 }#>
<#+                 if (childElem.HasBindAssignments || element.HasRootNamedElementStep) #>
<#+                 {#>
            this->Bindings->DisconnectUnloadedObject(<#=childElem.ConnectionId#>);
<#+                 }#>
<#+             }#>
<#+             if (element.HasBindAssignments || element.HasRootNamedElementStep) #>
<#+             {#>
            this->Bindings->DisconnectUnloadedObject(<#=element.ConnectionId#>);
<#+             }#>
<#+             FieldDefinition fieldInfo = element.FieldDefinition; #>
<#+             if(fieldInfo != null) #>
<#+             { #>
<#+                 Output_ApiInformationCall_Push(element.ApiInformation, Indent.TwoTabs); #>
            this-><#=fieldInfo.FieldName#> = nullptr;
<#+                 Output_ApiInformationCall_Pop(element.ApiInformation, Indent.TwoTabs); #>
<#+             } #>
            break;
        }
<#+         }#>
        default:
        {
            throw ref new ::Platform::InvalidArgumentException("Invalid connectionId.");
        }
    }
}
<#+     }#>
<#+ }#>

<#+ private void Output_ConnectionId_Case(ConnectionIdElement element)#>
<#+ {#>
<#+     string objectName = element.ElementCodeName;#>
<#+     Output_PushDeprecated(element.Type.IsDeprecated()); #>
<#+     Output_ApiInformationCall_Push(element.ApiInformation, Indent.TwoTabs); #>
<#+     if (element.HasFieldDefinition)#>
<#+     {#>
<#+         objectName = "this->" + element.FieldDefinition.FieldName; #>
            <#=objectName#> = safe_cast<<#=element.Type#>>(__target);
<#+     }#>
<#+     else if (element.EventAssignments.Count > 0)#>
<#+     {#>
            <#=element.Type#> <#=objectName#> = safe_cast<<#=element.Type#>>(__target);
<#+     }#>
<#+     foreach (EventAssignment ev in element.EventAssignments) #>
<#+     { #>
<#+         Output_ApiInformationCall_Push(ev.ApiInformation, Indent.TwoTabs); #>
            (safe_cast<<#=element.Type#>>(<#=objectName#>))-><#=ev.EventName#> += ref new ::<#=ColonizeRef(ev)#>(this, (void (<#=Model.CodeInfo.ClassType.FullName#>::*)
                <#=ev.EventParamsForCppSignature#>)&<#=Model.CodeInfo.ClassName.ShortName#>::<#=ev.HandlerName#>);
<#+         Output_ApiInformationCall_Pop(ev.ApiInformation, Indent.TwoTabs); #>
<#+     } #>
<#+     Output_ApiInformationCall_Pop(element.ApiInformation, Indent.TwoTabs); #>
<#+     Output_PopDeprecated(element.Type.IsDeprecated()); #>
<#+ }#>

<#+     private void Output_GetBindingConnectorCaseBindingPropertiesSet(ConnectionIdElement element, bool isPageRoot) #>
<#+     { #>
<#+         if (element.BindUniverse.NeededForOuterScopeElement) #>
<#+         { #>
<#+             if (isPageRoot) #>
<#+             { #>
<#+                 if (Model.CodeInfo.IsResourceDictionary)#>
<#+                 {#>
                    objBindings->SetRootWeakReference(this);
<#+                 }#>
<#+                 else#>
<#+                 {#>
                    objBindings->SetRootWeakReference(this);
<#+                 }#>
<#+                 if (!element.BindUniverse.IsFileRoot) #>
<#+                 { #>
                    bindings->SetParent(this->Bindings);
<#+                 } #>
<#+             } #>
<#+             else #>
<#+             { #>
                    objBindings->SetRootWeakReference(this->GetRootWeakReference());
                    bindings->SetParent(owningXamlBindings.Resolve<::XamlBindingInfo::XamlBindings>());
<#+             } #>
<#+         } #>
<#+     } #>

<#+ private void Output_GetBindingConnectorCase(ConnectionIdElement element, bool isPageRoot) #>
<#+ {#>
        case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
            {
<#+     Output_PushDeprecated(element.Type.IsDeprecated());#>
<#+     if (element.Type.IsDerivedFromControlTemplate())#>
<#+     {#>
                if (auto <#=element.ElementTemplatedParentCodeName #> = dynamic_cast<<#=element.TemplatedParentType#>>(__target))
                {
                    auto objBindings = new <#=element.BindUniverse.BindingsClassName#>();
                    objBindings->SetDataRoot(<#=element.ElementTemplatedParentCodeName #>);
                    bindings = ref new ::XamlBindingInfo::XamlBindings(objBindings);
                    <#=Projection(KnownNamespaces.XamlMarkup)#>::XamlBindingHelper::SetDataTemplateComponent(<#=element.ElementTemplatedParentCodeName#>, bindings);
<#+         Output_GetBindingConnectorCaseBindingPropertiesSet(element, isPageRoot); #>
                }
<#+     } else { #>
                <#=element.Type#> <#=element.ElementCodeName#> = safe_cast<<#=element.Type#>>(__target);
                <#=element.BindUniverse.BindingsClassName#>* objBindings = new <#=element.BindUniverse.BindingsClassName#>();
                objBindings->SetDataRoot(<#=element.IsBindingFileRoot ? "this" : element.ElementCodeName + "->DataContext"#>);
<#+         if (element.BindUniverse.DistinctConvertersUsed.Count() > 0) #>
<#+         {#>
                objBindings->SetConverterLookupRoot(this);
<#+         }#>
                bindings = ref new ::XamlBindingInfo::XamlBindings(objBindings);
<#+         if (element.IsBindingFileRoot)#>
<#+         { #>
                this->Bindings = bindings;
                <#=element.ElementCodeName#>->Loading += ref new ::Windows::Foundation::TypedEventHandler<<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement^, ::Platform::Object^>(bindings, &::XamlBindingInfo::XamlBindings::Loading);
<#+         }#>
<#+         else#>
<#+         {#>
                bindings->SubscribeForDataContextChanged(<#=element.ElementCodeName#>);
                <#=Projection(KnownNamespaces.Xaml)#>::DataTemplate::SetExtensionInstance(<#=element.ElementCodeName#>, bindings);
<#+         }#>
<#+         if (ProjectInfo.ShouldGenerateDisableXBind || !element.IsBindingFileRoot) #>
<#+         {#>
                <#=Projection(KnownNamespaces.XamlMarkup)#>::XamlBindingHelper::SetDataTemplateComponent(<#=element.ElementCodeName#>, bindings);
<#+         }#>
<#+         Output_GetBindingConnectorCaseBindingPropertiesSet(element, isPageRoot); #>
<#+     }#>
<#+                 Output_PopDeprecated(element.Type.IsDeprecated()); #>
            }
            break;
<#+ }#>

<#+ private void Output_GetBindingConnectorMethod()#>
<#+ { #>
<#=Projection(KnownNamespaces.XamlMarkup)#>::IComponentConnector^ <#=Model.CodeInfo.ClassType.FullName#>::GetBindingConnector(int __connectionId, ::Platform::Object^ __target)
{
<#+ if (Model.CodeInfo.BindStatus != BindStatus.None) #>
<#+ { #>
    ::XamlBindingInfo::XamlBindings^ bindings = nullptr;
    switch (__connectionId)
    {
<#+         foreach (ConnectionIdElement element in Model.AllConnectionIdElements)#>
<#+         {#>
<#+             if (element.IsBindingRoot)#>
<#+             {#>
<#+                 Output_GetBindingConnectorCase(element, true); #>
<#+             }#>
<#+         }#>
    }
    return bindings;
<#+     } #>
<#+     else #>
<#+     { #>
    __connectionId;         // unreferenced
    __target;               // unreferenced
    return nullptr;
<#+     } #>
}
<#+ }#>

<#+     private void Output_PushDeprecated(bool isDeprecated)#>
<#+     {#>
<#+         if (isDeprecated) #>
<#+         { #>
#pragma warning( push )
#pragma warning( disable : 4973 )
<#+         } #>
<#+     }#>

<#+     private void Output_PopDeprecated(bool isDeprecated)#>
<#+     {#>
<#+         if (isDeprecated) #>
<#+         { #>
#pragma warning( pop )
<#+         } #>
<#+     }#>
<#+ #>
<#+     private void Output_BindingsClasses()#>
<#+     {#>
<#+         foreach (BindUniverse bindUniverse in Model.CodeInfo.BindUniverses)#>
<#+         { #>
<#+             if (bindUniverse.NeedsCppBindingTrackingClass) { #>

<#+                 Output_BindingTrackingClass(bindUniverse); #>
<#+             } #>

/// <summary>
/// Auto generated class for compiled bindings.
/// </summary>
class <#=GetBindingFullClassName(bindUniverse, Model.CodeInfo)#> 
    : public ::XamlBindingInfo::<#=bindUniverse.DataRootType.UnderlyingType.IsValueType ? "ValueTypeXamlBindings" : "ReferenceTypeXamlBindings"#><<#=bindUniverse.DataRootType.CppCXName(false)#>, <#=GetBindingTrackingFullClassName(bindUniverse, Model.CodeInfo)#>>
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>
    , public ::XamlBindingInfo::IXamlBindingTracking
<#+             }#>
{
<#+             if (bindUniverse.DistinctConvertersUsed.Count() > 0) #>
<#+             {#>
            <#=Projection(KnownNamespaces.Xaml)#>::ResourceDictionary^ localResources;
<#+                 if (!Model.CodeInfo.IsResourceDictionary)#>
<#+                 {#>
            ::Platform::WeakReference converterLookupRoot;
<#+                 }#>

<#+             }#>
public:
    <#=bindUniverse.BindingsClassName#>()
    {
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>
        InitializeTracking(this);
<#+             }#>
    }
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>

private:
    ~<#=bindUniverse.BindingsClassName#>()
    {
        ReleaseAllListeners();
    }

public:
<#+             }#>
<#+             if (bindUniverse.NeededForOuterScopeElement) #>
<#+             { #>
private:
    ::Platform::WeakReference rootWeakRef;
public:
<#+                 if (Model.CodeInfo.IsResourceDictionary)#>
<#+                 {#>
    void SetRootWeakReference(<#=Projection(KnownNamespaces.Xaml)#>::ResourceDictionary^ root)
    {
        rootWeakRef = root;
    }

    <#=Projection(KnownNamespaces.Xaml)#>::ResourceDictionary^ GetRootWeakReference()
    {
        return rootWeakRef.Resolve<<#=Projection(KnownNamespaces.Xaml)#>::ResourceDictionary>();
    }

<#+                 }#>
<#+                 else#>
<#+                 {#>
    void SetRootWeakReference(<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement^ root)
    {
        rootWeakRef = root;
    }

    <#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement^ GetRootWeakReference()
    {
        return rootWeakRef.Resolve<<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement>();
    }

<#+                 }#>
<#+             } #>

    void Connect(int __connectionId, ::Platform::Object^ __target)
    {
<#+ if (!bindUniverse.ElementsWithConnectCase.Any()) #>
<#+ { #>
                __connectionId;
                __target;
                return;
<#+ } #>
<#+ else #>
<#+ { #>
        switch(__connectionId)
        {
<#+ foreach (var element in bindUniverse.ElementsWithConnectCase)#>
<#+ {#>
            case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
<#+     if (element.Type.IsDerivedFromControlTemplate())#>
<#+     {#>
                this->Update(); // Template children have been connected, initialize bindings
<#+     } else {#>
<#+     if (bindUniverse.BoundElements.Contains(element)) { #>
<#+     Output_ApiInformationCall_Push(element.ApiInformation, Indent.ThreeTabs); #>
                this-><#=element.ObjectCodeName#> = safe_cast<<#=element.Type#>>(__target);
<#+         if (element.IsUsedByOtherScopes) #>
<#+         { #>
                elementWeakRefs->Insert(__connectionId, ref new ::XamlBindingInfo::WeakRefWrapper(__target));
                NotifyDependentScopes(__connectionId);
<#+         } #>
<#+     foreach (BoundEventAssignment evt in element.BoundEventAssignments)#>
<#+     {#>
<#+         Output_ApiInformationCall_Push(evt.ApiInformation, Indent.ThreeTabs); #>
                this-><#=evt.EventHandlerCodeName#> = (safe_cast<<#=element.Type#>>(__target))-><#=evt.MemberName#> += ref new <#=ColonizeRef(evt)#>([this] (<#=evt.Parameters.Declaration()#>)
                {
<#+         if (!evt.PathStep.ValueType.IsDelegate())#>
<#+         {#>
                    <#=evt.PathStep.CodeGen().PathExpression#>;
<#+         }#>
<#+         else#>
<#+         {#>
                    <#=evt.PathStep.CodeGen().PathExpression#>(<#=evt.Parameters.ForCall()#>);
<#+         }#>
                });
<#+         Output_ApiInformationCall_Pop(evt.ApiInformation, Indent.ThreeTabs); #>
<#+     }#>
<#+     if (element.CanBeInstantiatedLater && (element.HasBindAssignments || element.HasBoundEventAssignments))#>
<#+     {#>
<#+         // In Connect() we update non-load assignments first, #>
<#+         foreach (var ba in element.BindAssignments.Where(ba => !(ba is BoundLoadAssignment))) #>
<#+         { #>
<#+             PushIndent(Indent.TwoTabs); #>
<#+             Output_Binding_SetValue_Non_Function_Call(ba, "this->" + ba.ObjectDeferredAssignmentCodeName.CppCXName(), false); #>
<#+             PopIndent(); #>
<#+         } #>
<#+     }#>
<#+     foreach (var ba in element.BindAssignments.Where(bindAssignment => bindAssignment.IsTrackingTarget)) { #>
<#+         PushIndent();#>
<#+         Output_Connect_TwoWayBinding(ba);#>
<#+         PopIndent();#>
<#+     }#>
<#+     Output_ApiInformationCall_Pop(element.ApiInformation, Indent.ThreeTabs); #>
<#+     } #>
<#+     if (!element.IsBindingRoot) #>
<#+     { #>
<#+         // Queue load assignments to be updated later, because they're not available yet. #>
<#+         foreach (var childElem in element.Children.Intersect(bindUniverse.ElementsWithBoundLoadAssignments)) #>
<#+         { #>
            if (std::find(this->UnloadedElementsToUpdate.begin(), this->UnloadedElementsToUpdate.end(), <#=childElem.ConnectionId#>) == this->UnloadedElementsToUpdate.end())
            {
                this->UnloadedElementsToUpdate.push_back(<#=childElem.ConnectionId#>);
            }
<#+         } #>
<#+     } #>
<#+     if (element.CanBeInstantiatedLater && element.HasRootNamedElementStep) { #>
                this->UnloadableBindingSourcesToUpdate.push_back([this]()
                {
<#+         PushIndent(Indent.TwoTabs); #>
<#+         Output_Custom_Update_Call(element.RootNamedElementStep, element.RootNamedElementStep.CodeGen().PathExpression.CppCXName(), KnownStrings.NotPhased);#>
<#+         PopIndent(); #>
                });
<#+     } #>
<#+    if (element.TryGetValidationContextStep(out PropertyStep validationStep) && ProjectInfo.IsInputValidationEnabled && ProjectInfo.EnableDefaultValidationContextGeneration) #>
<#+    { #>
<#+        Output_ApiInformationCall_Push(validationStep.ApiInformation, Indent.ThreeTabs); #>
            safe_cast<<#=Projection(KnownNamespaces.XamlControls)#>::IInputValidationControl^>(__target)->ValidationContext = ref new <#=Projection(KnownNamespaces.XamlControls)#>::InputValidationContext("<#=validationStep.PropertyName #>", <#=validationStep.IsValueRequired#>);
<#+        Output_ApiInformationCall_Pop(validationStep.ApiInformation, Indent.ThreeTabs); #>
<#+    }#>
<#+     } #>
                break;
<#+ }#>
        }
<#+ } #>
    }
<#+     if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+     {#>

    void Disable(int lineNumber, int columnNumber)
    {
<#+         bool firstIfInDisable = true; #>
<#+         foreach (var element in bindUniverse.ElementsWithConnectCaseInLocalScope)#>
<#+         {#>
<#+             foreach (BindAssignment ba in element.BindAssignments)#>
<#+             {#>
<#+                 if (firstIfInDisable)#>
<#+                 {#>
<#+                     firstIfInDisable = false; #>
        if (lineNumber == <#=ba.LineNumber#> && columnNumber == <#=ba.ColumnNumber#>)
<#+                 } else {#>
        else if (lineNumber == <#=ba.LineNumber#> && columnNumber == <#=ba.ColumnNumber#>)
<#+                 }#>
        {
            <#=ba.DisableFlagName#> = true;
        }
<#+             }#>
<#+             foreach (BoundEventAssignment evt in element.BoundEventAssignments)#>
<#+             {#>
<#+                 if (firstIfInDisable)#>
<#+                 {#>
<#+                 firstIfInDisable = false; #>
        if (lineNumber == <#=evt.LineNumber#> && columnNumber == <#=evt.ColumnNumber#>)
<#+                  } else {#>
        else if (lineNumber == <#=evt.LineNumber#> && columnNumber == <#=evt.ColumnNumber#>)
<#+                 }#>
        {
<#+                 if (element.IsWeakRef)#>
<#+                 {#>
            if (<#=element.ReferenceExpression#> != nullptr)
            {
                <#=element.ReferenceExpression#>-><#=evt.MemberName#> -= <#=evt.EventHandlerCodeName#>;
            }
<#+                 } else {#>
            this-><#=element.ObjectCodeName#>-><#=evt.MemberName#> -= <#=evt.EventHandlerCodeName#>;
<#+                 }#>
        }
<#+             }#>
<#+         }#>
    }
<#+     }#>

    void DisconnectUnloadedObject(int connectionId)
    {
<#+         if(bindUniverse.ElementsWithDisconnectCase.Count() == 0) { #>
        throw ref new ::Platform::InvalidArgumentException("No unloadable elements to disconnect.");
<#+         } else { #>
        switch (connectionId)
        {
<#+             foreach (var element in bindUniverse.ElementsWithDisconnectCase)#>
<#+             {#>
            case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
            {
<#+                         if (bindUniverse.BoundElements.Contains(element)) { #>
<#+                 Output_ApiInformationCall_Push(element.ApiInformation, Indent.OneTab); #>
                if (this-><#=element.ObjectCodeName#> != nullptr)
                {
<#+                 foreach (BindAssignment bindAssignment in element.BindAssignments.Where(ba => ba.HasDeferredValueProxy))#>
<#+                 {#>
                    this-><#=bindAssignment.ObjectDeferredAssignmentCodeName#> = <#=element.GetMemberGetExpression(bindAssignment)#>;
<#+                 }#>
                    this-><#=element.ObjectCodeName#> = nullptr;
                }
<#+                 foreach (var childElem in element.Children.Where(c => bindUniverse.ElementsWithDisconnectCase.Contains(c))) {#>
                this->DisconnectUnloadedObject(<#=childElem.ConnectionId#>);
<#+                 }#>
<#+                 Output_ApiInformationCall_Pop(element.ApiInformation, Indent.OneTab); #>
<#+                 } #>
<#+                 if (element.HasRootNamedElementStep) { #>
                this->UnloadableBindingSourcesToUpdate.push_back([this]()
                {
<#+                     PushIndent(Indent.TwoTabs); #>
<#+                     Output_Custom_Update_Call(element.RootNamedElementStep, "nullptr", KnownStrings.NotPhased);#>
<#+                     PopIndent(); #>
                        });
<#+                 } #>
                break;
            }
<#+             }#>
            default:
            {
                throw ref new ::Platform::InvalidArgumentException("Invalid connectionId.");
            }
        }
<#+         } #>
    }
<#+         if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) #>
<#+         { #>

    void UpdateUnloadedElement(int connectionId)
    {
        switch (connectionId)
        {
<#+             foreach (var element in bindUniverse.ElementsWithBoundLoadAssignments)#>
<#+             {#>
            case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
            {
<#+                 foreach (var ba in element.BindAssignments.OfType<BoundLoadAssignment>()) #>
<#+                 { #>
<#+                     PushIndent(Indent.TwoTabs); #>
<#+                     Output_Binding_SetValue_Non_Function_Call(ba, "this->" + ba.ObjectDeferredAssignmentCodeName.CppCXName(), false); #>
<#+                     PopIndent(); #>
<#+                 } #>
                break;
            }
<#+             }#>
            default:
            {
                throw ref new ::Platform::InvalidArgumentException("Invalid connectionId.");
            }
        }
    }
<#+         }#>
<#+         if (bindUniverse.NeededForOuterScopeElement) { #>
    virtual <#=Projection(KnownNamespaces.XamlMarkup)#>::IComponentConnector^ GetBindingConnector(int __connectionId, ::Platform::Object^ __target) override
    {
<#+             if (bindUniverse.Children.Any()) #>
<#+             { #>
        ::XamlBindingInfo::XamlBindings^ bindings = nullptr;
        switch (__connectionId)
        {
<#+                 foreach (BindUniverse childUniverse in bindUniverse.Children)#>
<#+                 {#>
<#+                     ConnectionIdElement element = childUniverse.RootElement;#>
<#+                     if (element.IsBindingRoot)#>
<#+                     {#>
<#+                         PushIndent(Indent.OneTab); #>
<#+                         Output_GetBindingConnectorCase(element, false); #>
<#+                         PopIndent(); #>
<#+                     }#>
<#+                 }#>
        }
        return bindings;
<#+             } #>
<#+             else #>
<#+             { #>
        __connectionId;         // unreferenced
        __target;               // unreferenced
        return nullptr;
<#+             } #>
    }

    virtual void SetParent(::XamlBindingInfo::XamlBindings^ __parent) override
    {
        if (__parent != nullptr && GetParent() != __parent)
        {
            _parent = __parent;
            RegisterDependenciesOnParents();
        }
    }

    virtual ::XamlBindingInfo::XamlBindings^ GetParent() override
    {
        return _parent.Resolve<::XamlBindingInfo::XamlBindings>();
    }

private:
   ::Platform::Collections::Map<int, ::Windows::Foundation::Collections::IVector<::XamlBindingInfo::WeakRefWrapper^>^>^ dependentBindings =
                ref new ::Platform::Collections::Map<int, ::Windows::Foundation::Collections::IVector<::XamlBindingInfo::WeakRefWrapper^>^>();
   ::Platform::Collections::Map<int, ::XamlBindingInfo::WeakRefWrapper^>^ elementWeakRefs =
                ref new ::Platform::Collections::Map<int, ::XamlBindingInfo::WeakRefWrapper^>();

    ::Platform::WeakReference _parent;

    void NotifyDependentScopes(int __connectionId)
    {
        if (dependentBindings->HasKey(__connectionId))
        {
            auto dependentsList = dependentBindings->Lookup(__connectionId);
            for (auto iter = dependentsList->First(); iter->HasCurrent; iter->MoveNext())
            {
                ::XamlBindingInfo::WeakRefWrapper^ refWrapper = iter->Current;
                auto obj = refWrapper->Resolve();
                if (obj != nullptr)
                {
                    <#=Projection(KnownNamespaces.XamlMarkup)#>::IComponentConnector^ connector = safe_cast<<#=Projection(KnownNamespaces.XamlMarkup)#>::IComponentConnector^>(obj);
                    NotifyDependentScope(__connectionId, connector);
                }
            }
        }
    }

    void NotifyDependentScope(int __connectionId, <#=Projection(KnownNamespaces.XamlMarkup)#>::IComponentConnector^ __connector)
    {
        if (elementWeakRefs->HasKey(__connectionId) && elementWeakRefs->Lookup(__connectionId)->Resolve() != nullptr)
        {
            __connector->Connect(__connectionId, elementWeakRefs->Lookup(__connectionId)->Resolve());
        }
    }

    void RegisterDependenciesOnParents()
    {
        ::XamlBindingInfo::XamlBindings^ currentParent = GetParent();
        ::Platform::Collections::Vector<int>^ unresolvedDependencies = ref new ::Platform::Collections::Vector<int>;
<#+                 foreach (var element in bindUniverse.OuterScopeBoundElements)#>
<#+                 {#>
        unresolvedDependencies->Append(<#=element.ConnectionId#>);
<#+                 }#>

        while (unresolvedDependencies->Size > 0 && currentParent != nullptr)
        {
            for (unsigned int i = unresolvedDependencies->Size; i >= 1; i--)
            {
                int unresolvedDependency = unresolvedDependencies->GetAt(i - 1);
                if (currentParent->ContainsElement(unresolvedDependency))
                {
                    currentParent->RegisterForElementConnection(unresolvedDependency, owningXamlBindings.Resolve<::XamlBindingInfo::XamlBindings>());
                    unresolvedDependencies->RemoveAt(i - 1);
                }
            }

            currentParent = currentParent->GetParent();
        }
    }
public:

    virtual bool ContainsElement(int connectionId) override
    {
<#+             var localElements = bindUniverse.ElementsWithConnectCaseInLocalScope.Where(c => c.IsUsedByOtherScopes); #>
<#+             if (!localElements.Any()) {#>
        return false;
<#+             } else { #>
        switch (connectionId)
        {
<#+                 foreach (var element in localElements)#>
<#+                 {#>
            case <#=element.ConnectionId#>:
                return true;
<#+                 }#>
            default:
                return false;
        }
<#+             } #>
    }

    virtual void RegisterForElementConnection(int connectionId, ::XamlBindingInfo::XamlBindings^ connector) override
    {
        ::Windows::Foundation::Collections::IVector<::XamlBindingInfo::WeakRefWrapper^>^ dependentsList;
        if (!dependentBindings->HasKey(connectionId))
        {
            dependentsList = ref new ::Platform::Collections::Vector<::XamlBindingInfo::WeakRefWrapper^>();
            dependentBindings->Insert(connectionId, dependentsList);
        }
        else
        {
            dependentsList = dependentBindings->Lookup(connectionId);
        }

        dependentsList->Append(ref new ::XamlBindingInfo::WeakRefWrapper(connector));

        NotifyDependentScope(connectionId, connector);
    }
<#+         } #>
<#+ if (bindUniverse.NeedsIDataTemplateExtension) #>
<#+ {#>

    void Recycle()
    {
<#+    if (bindUniverse.NeedsBindingsTracking)#>
<#+    {#>
        ReleaseAllListeners();
<#+    } #>
<#+ foreach(KeyValuePair<int, List<PhaseAssignment>> kvp in bindUniverse.PhaseAssignments.Where(kvp => kvp.Key != 0).OrderBy(kvp => kvp.Key)) #>
<#+ { #>
<#+     foreach(PhaseAssignment phase in kvp.Value) #>
<#+     { #>
<#+         if (phase.ConnectionIdElement.CanBeInstantiatedLater)#>
<#+         {#>
        if (<#=phase.ConnectionIdElement.ReferenceExpression#> != nullptr)
        {
<#+             PushIndent();#>
<#+         }#>
        <#=Projection(KnownNamespaces.XamlMarkup)#>::XamlBindingHelper::SuspendRendering(<#=phase.ConnectionIdElement.ReferenceExpression#>);
<#+         if (phase.ConnectionIdElement.CanBeInstantiatedLater)#>
<#+         {#>
<#+             PopIndent();#>
        }
<#+         }#>
<#+     } #>
<#+ } #>
    }

    void ProcessBindings(::Platform::Object^ item, int itemIndex, int phase, int* nextPhase)
    {
        switch (phase)
        {
            case 0:
                *nextPhase = <#=bindUniverse.GetNextPhase(0)#>;
                this->SetDataRoot(static_cast<<#=bindUniverse.DataRootType#>>(item));
                if (this->_dataContextChangedToken.Value != 0)
                {
                    <#=bindUniverse.RootElement.ReferenceExpression#>->DataContextChanged -= this->_dataContextChangedToken;
                    this->_dataContextChangedToken.Value = 0;
                }
                this->_isInitialized = true;
                break;
<#+     foreach(KeyValuePair<int, List<PhaseAssignment>> kvp in bindUniverse.PhaseAssignments.Where(kvp => kvp.Key != 0).OrderBy(kvp => kvp.Key)) #>
<#+     { #>
            case <#=kvp.Key#>:
<#+             foreach(PhaseAssignment phase in kvp.Value) #>
<#+             { #>
<#+                 if (phase.ConnectionIdElement.CanBeInstantiatedLater)#>
<#+                 {#>
                if (<#=phase.ConnectionIdElement.ReferenceExpression#> != nullptr)
                {
<#+                     PushIndent();#>
<#+                 }#>
                <#=Projection(KnownNamespaces.XamlMarkup)#>::XamlBindingHelper::ResumeRendering(<#=phase.ConnectionIdElement.ReferenceExpression#>);
<#+             if (phase.ConnectionIdElement.CanBeInstantiatedLater)#>
<#+                 {#>
<#+                     PopIndent();#>
                }
<#+         }#>
<#+             } #>
                *nextPhase = <#=bindUniverse.GetNextPhase(kvp.Key)#>;
                break;
<#+     } #>
            default:
                *nextPhase = -1;
                break;
        }
        this->Update_((<#=bindUniverse.RootStep.ValueType#>) item, 1 << phase);
    }
<#+ } else if (bindUniverse.NeedsIDataTemplateComponent || ProjectInfo.ShouldGenerateDisableXBind)#>
<#+ {#>

    void Recycle()
    {
        return;
    }

    void ProcessBindings(::Platform::Object^ item, int itemIndex, int phase, int* nextPhase)
    {
        *nextPhase = -1;
    }
<#+ }#>
<#+ if (bindUniverse.DistinctConvertersUsed.Count() > 0) #>
<#+ {#>
<#+     if (Model.CodeInfo.IsResourceDictionary)#>
<#+     {#>

    void SetConverterLookupRoot(<#=Projection(KnownNamespaces.Xaml)#>::ResourceDictionary^ resources)
    {
        this->localResources = resources;
    }
<#+     }#>
<#+     else#>
<#+     {#>

    void SetConverterLookupRoot(<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement^ rootElement)
    {
        this->converterLookupRoot = rootElement;
    }
<#+     }#>

    <#=Projection(KnownNamespaces.XamlData)#>::IValueConverter^ LookupConverter(::Platform::String^ key)
    {
<#+     if (!Model.CodeInfo.IsResourceDictionary)#>
<#+     {#>
        if (this->localResources == nullptr)
        {
            this->localResources = this->converterLookupRoot.Resolve<<#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement>()->Resources;
            this->converterLookupRoot = nullptr;
            }
<#+     }#>
        return safe_cast<<#=Projection(KnownNamespaces.XamlData)#>::IValueConverter^>(this->localResources->HasKey(key) ? this->localResources->Lookup(key) : <#=Projection(KnownNamespaces.Xaml)#>::Application::Current->Resources->Lookup(key));
    }
<#+ }#>

private:
<#+             if (bindUniverse.BoundElements != null && bindUniverse.BoundElements.Count > 0)#>
<#+             {#>
    // Fields for each control that has bindings.
<#+             }#>
<#+             foreach (ConnectionIdElement bindElement in bindUniverse.BoundElements)#>
<#+             {#>
<#+                 if (bindElement.IsWeakRef) #>
<#+                 {#>
    ::Platform::WeakReference <#=bindElement.ObjectCodeName#>;
<#+                 }#>
<#+                 else if (!bindElement.Type.IsDerivedFromControlTemplate()) #>
<#+                 {#>
    <#=bindElement.Type#> <#=bindElement.ObjectCodeName#>;
<#+                 }#>
<#+                 if (bindElement.CanBeInstantiatedLater)#>
<#+                 {#>
<#+                     foreach (var bindAssignment in bindElement.BindAssignments)#>
<#+                     {#>
    <#=bindAssignment.MemberType#> <#=bindAssignment.ObjectDeferredAssignmentCodeName#>;
<#+                     }#>
<#+                 }#>
<#+             }#>
<#+             if (bindUniverse.UnloadableBindingSourceElements.Any()) { #>
    std::list<std::function<void ()>> UnloadableBindingSourcesToUpdate;
<#+             } #>
<#+             if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) { #>
    std::list<int> UnloadedElementsToUpdate;
<#+             } #>
<#+         if (bindUniverse.ElementsWithConnectCase.Where(e => e.BoundEventAssignments.Count > 0).Count() > 0)#>
<#+             {#>

            // Fields for each event bindings event handler.
<#+             }#>
<#+             foreach (var element in bindUniverse.ElementsWithConnectCase)#>
<#+             {#>
<#+                 foreach (BoundEventAssignment evt in element.BoundEventAssignments)#>
<#+                 {#>
    ::Windows::Foundation::EventRegistrationToken <#=evt.EventHandlerCodeName#>;
<#+                 }#>
<#+             }#>
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>

    // Static fields for each binding's enabled/disabled state
<#+                 foreach (ConnectionIdElement bindElement in bindUniverse.ElementsWithConnectCaseInLocalScope)#>
<#+                 {#>
<#+                     foreach (BindAssignment ba in bindElement.BindAssignments)#>
<#+                     {#>
    static bool <#=ba.DisableFlagName#>;
<#+                     }#>
<#+                 }#>
<#+             }#>
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>
    
    // Fields for binding tracking.
<#+             Output_Listener_Tracking_Fields(bindUniverse);#>
<#+             }#>
<#+             if (bindUniverse.HasBindings)#>
<#+             {#>
<#+                 if (bindUniverse.HasFunctionBindings) {#>
<#+                     Output_TryGetValueFunctions(bindUniverse);#>
<#+                     Output_FunctionBindings(bindUniverse);#>
<#+                 }#>
<#+                 if (bindUniverse.NeedsCompleteUpdate)#>
<#+                 {#>
<#+                     Output_CompleteUpdate(bindUniverse);#>
<#+                 }#>

    // Update methods for each path node used in binding steps.
<#+             }#>
<#+             // Update generators #>
<#+             foreach (BindPathStep bindStep in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.IsIncludedInUpdate == true))#>
<#+             {#>
    void Update_<#=bindStep.CodeName#>(<#=GetUpdateParams(bindStep)#>)
    {
<#+                 Output_UpdateChildListeners_Call(bindStep, "obj");#>
<#+                 Output_Update_Steps(bindStep.ValueType.IsNullable, bindStep.Children, true, "phase");#>
<#+                 Output_Update_Steps(bindStep.ValueType.IsNullable, bindStep.Dependents, false, "phase");#>
<#+                 foreach (int distinctPhase in bindStep.DistinctPhases)#>
<#+                 {#>
<#+                     Output_Binding_Phased_SetValue(distinctPhase, true, bindStep, false);#>
<#+                     Output_Binding_Phased_SetValue(distinctPhase, false, bindStep, false);#>
<#+                 }#>
<#+                 if (bindStep is RootStep) { #>
<#+                     Output_Update_Steps(false, bindUniverse.BindPathSteps.Values.Where(s => s.Parent is StaticRootStep), false, "phase");#>
<#+                     if (bindUniverse.ElementRootStep != null) #>
<#+                     { #>
<#+                         Output_Update_Steps(false, bindUniverse.BindPathSteps.Values.Where(s => s.Parent == bindUniverse.ElementRootStep), false, "phase");#>
<#+                     } #>
<#+                     if (bindUniverse.NeedsCompleteUpdate) { #>
        this->CompleteUpdate(phase);
<#+                     }#>
<#+                 }#>
    }
<#+             }#>
<#+             // UpdateFallback generators #>
<#+             foreach (BindPathStep bindStep in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.IsIncludedInUpdate == true))#>
<#+             {#>
<#+                 if (bindStep.Parent != null && bindStep.BindStatus.HasFlag(BindStatus.HasFallbackValue))#>
<#+                 {#>

    void UpdateFallback_<#=bindStep.CodeName#>(int phase)
    {
<#+                     foreach (BindPathStep childStep in bindStep.Children.Concat(bindStep.Dependents))#>
<#+                     {#>
<#+                         if (childStep.BindStatus.HasFlag(BindStatus.HasFallbackValue))#>
<#+                         {#>
        this->UpdateFallback_<#=childStep.CodeName#>(phase);
<#+                         }#>
<#+                     }#>
<#+                     foreach (int distinctPhase in bindStep.DistinctPhases) #>
<#+                     {#>
<#+                         Output_Binding_Phased_Fallback_SetValue(distinctPhase, true, bindStep);#>
<#+                         Output_Binding_Phased_Fallback_SetValue(distinctPhase, false, bindStep);#>
<#+                     }#>
    }
<#+                 }#>
<#+             }#>
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>

    virtual void ReleaseAllListeners() override
    {
<#+                 foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(step => step.NeedsUpdateChildListeners))#>
<#+                 {#>
<#+                     Output_UpdateChildListeners_Call(step, "nullptr");#>
<#+                 }#>
    }

    virtual void PropertyChanged(Platform::Object^ sender, <#=Projection(KnownNamespaces.XamlData)#>::PropertyChangedEventArgs^ e) override
    {
<#+                 foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true))#>
<#+                 {#>
<#+                     if (step.RequiresChildNotification && (step is PropertyStep || step is CastStep || step is RootStep || step is RootNamedElementStep || step is ArrayIndexStep || step is MapIndexStep) && step.ImplementsINPC)#>
<#+                     {#>
<#+                         string cacheName = "this->GetDataRoot()";#>
<#+                         if (step.RequiresChildNotification && !(step is RootStep))#>
<#+                         {#>
<#+                             cacheName="cachePC_" + step.CodeName;#>
<#+                         }#>
        if (<#=cacheName#> != nullptr && <#=cacheName#>->Equals(sender))
        {
            ::Platform::String^ propName = e->PropertyName;
            <#=step.ValueType#> obj = safe_cast<<#=step.ValueType#>>(sender);
            if (propName == nullptr || propName->IsEmpty())
            {
<#+                         PushIndent(Indent.TwoTabs);#>
<#+                         Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps, false, "DATA_CHANGED");#>
<#+                         PopIndent();#>
            }
<#+                         foreach (string propertyName in step.TrackingSteps.OfType<PropertyStep>().Select(p => p.PropertyName).Distinct())#>
<#+                         {#>
            else if (propName == "<#=propertyName#>")
            {
<#+             PushIndent(Indent.TwoTabs);#>
<#+             foreach (var child in step.TrackingSteps.OfType<PropertyStep>().Where(p => p.PropertyName == propertyName)) { #>
<#+                 Output_Update_DataChanged_Step(child);#>
<#+             } #>
<#+             PopIndent();#>
            }
<#+                         }#>
<#+                         foreach (string functionName in step.TrackingSteps.OfType<FunctionStep>().Select(p => p.Method.MethodName).Distinct())#>
<#+                         {#>
            else if (propName == "<#=functionName#>")
            {
<#+                             PushIndent(Indent.TwoTabs);#>
<#+                             Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps.OfType<FunctionStep>().Where(p => p.Method.MethodName == functionName), false, "DATA_CHANGED");#>
<#+                             PopIndent();#>
            }
<#+                         }#>
        }
<#+                     }#>
<#+                 }#>
<#+                 if (bindUniverse.NeedsCompleteUpdate) { #>
        this->CompleteUpdate(DATA_CHANGED);
<#+                 }#>
    }

    void CollectionChanged(::Platform::Object^ sender, <#=Projection(KnownNamespaces.XamlInterop)#>::NotifyCollectionChangedEventArgs^ e)
    {
<#+                 foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true))#>
<#+                 {#>
<#+                     if (step.RequiresChildNotification && (step is PropertyStep || step is CastStep || step is RootStep || step is RootNamedElementStep) && step.ImplementsINCC && !step.ImplementsIObservableVector && !step.ImplementsIObservableMap)#>
<#+                     {#>
<#+                         string cacheName = "this->GetDataRoot()";#>
<#+                         if (step.RequiresChildNotification && !(step is RootStep))#>
<#+                         {#>
<#+                             cacheName="cacheCC_" + step.CodeName;#>
<#+                         }#>
        if (<#=cacheName#> != nullptr && <#=cacheName#>->Equals(sender))
        {
            <#=step.ValueType#> obj = safe_cast<<#=step.ValueType#>>(sender);
<#+                         PushIndent();#>
<#+                         Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps, false, "DATA_CHANGED");#>
<#+                         PopIndent();#>
        }
<#+                     }#>
<#+                 }#>
<#+                 if (bindUniverse.NeedsCompleteUpdate) { #>
        this->CompleteUpdate(DATA_CHANGED);
<#+                 }#>
    }

    void VectorChanged(::Platform::Object^ sender, ::Windows::Foundation::Collections::IVectorChangedEventArgs^ e)
    {
<#+                 foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true))#>
<#+                 {#>
<#+                     if (step.RequiresChildNotification && (step is PropertyStep || step is CastStep || step is RootStep) && step.ImplementsIObservableVector)#>
<#+                     {#>
<#+                         string cacheName = "this->GetDataRoot()";#>
<#+                         if (step.RequiresChildNotification && !(step is RootStep))#>
<#+                         {#>
<#+                             cacheName="cacheVC_" + step.CodeName;#>
<#+                         }#>
        if (<#=cacheName#> != nullptr && <#=cacheName#>->Equals(sender))
        {
            <#=step.ValueType#> obj = safe_cast<<#=step.ValueType#>>(sender);
<#+                         PushIndent();#>
<#+                         Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps, false, "DATA_CHANGED");#>
<#+                         PopIndent();#>
        }
<#+                     }#>
<#+                 }#>
<#+                 if (bindUniverse.NeedsCompleteUpdate) { #>
        this->CompleteUpdate(DATA_CHANGED);
<#+                 }#>
    }

    void MapChanged(::Platform::Object^ sender, ::Windows::Foundation::Collections::IMapChangedEventArgs<::Platform::String^>^ e)
    {
<#+                 foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true))#>
<#+                 {#>
<#+                     if (step.RequiresChildNotification && (step is PropertyStep || step is CastStep || step is RootStep) && step.ImplementsIObservableMap)#>
<#+                     {#>
<#+                         string cacheName = "this->GetDataRoot()";#>
<#+                         if (step.RequiresChildNotification && !(step is RootStep))#>
<#+                         {#>
<#+                             cacheName="cacheMC_" + step.CodeName;#>
<#+                         }#>
        if (<#=cacheName#> != nullptr && <#=cacheName#>->Equals(sender))
        {
            <#=step.ValueType#> obj = safe_cast<<#=step.ValueType#>>(sender);
<#+                         PushIndent();#>
<#+                         Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps, false, "DATA_CHANGED");#>
<#+                         PopIndent();#>
        }
<#+                     }#>
<#+                 }#>
<#+                 if (bindUniverse.NeedsCompleteUpdate) { #>
        this->CompleteUpdate(DATA_CHANGED);
<#+                 }#>
    }

    void DependencyPropertyChanged(<#=Projection(KnownNamespaces.Xaml)#>::DependencyObject^ sender, <#=Projection(KnownNamespaces.Xaml)#>::DependencyProperty^ prop)
    {
        if (sender != nullptr)
        {
<#+                 foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true))#>
<#+                 {#>
<#+                     foreach (DependencyPropertyStep child in step.TrackingSteps.OfType<DependencyPropertyStep>())#>
<#+                     {#>
            if (sender->Equals(<#=GetCacheResolveStatement(step, "cacheDPC_", child)#>) && <#=child.OwnerType.CppCXName(false)#>::<#=child.PropertyName#>Property->Equals(prop))
            {
                <#=step.ValueType#> obj = safe_cast<<#=step.ValueType#>>(sender);
<#+                         PushIndent(Indent.TwoTabs);#>
<#+                         Output_Update_DataChanged_Step(child);#>
<#+                         PopIndent();#>
            }
<#+                     }#>
<#+                 }#>
<#+                 if (bindUniverse.HasFunctionBindings) { #>
            this->CompleteUpdate(DATA_CHANGED);
<#+                 }#>
        }
    }

<#+ if (ProjectInfo.IsInputValidationEnabled) { #>
    void ErrorsChanged(::Platform::Object^ sender, <#=Projection(KnownNamespaces.XamlData)#>::DataErrorsChangedEventArgs^ e)
    {
<#+     foreach (BindPathStep step in bindUniverse.INDEIPathSteps)#>
<#+     {#>
<#+         string cacheName = "this->GetDataRoot()";#>
<#+         if (!(step is RootStep))#>
<#+         {#>
<#+             cacheName="cacheEC_" + step.CodeName;#>
<#+         }#>
        if (<#=cacheName#> != nullptr && <#=cacheName#>->Equals(sender))
        {
            ::Platform::String^ propertyName = e->PropertyName;
            auto errorInfo = safe_cast<<#=Projection(KnownNamespaces.XamlData)#>::INotifyDataErrorInfo^>(sender);
            if (propertyName == nullptr || propertyName->IsEmpty())
            {
<#+           foreach(var child in step.TrackingSteps.OfType<PropertyStep>()) {#>
<#+              Output_UpdateErrorsCall(child);#>
<#+           } #>
            }
<#+       foreach (string propertyName in step.TrackingSteps.OfType<PropertyStep>().Select(p => p.PropertyName).Distinct())#>
<#+       {#>
            else if (propertyName == "<#=propertyName#>")
            {
<#+           foreach (var child in step.TrackingSteps.OfType<PropertyStep>().Where(p => p.PropertyName == propertyName)) #>
<#+           { #>
<#+              Output_UpdateErrorsCall(child);#>
<#+           } #>
            }
<#+       } #>
        }
<#+ }#>
    }

<#+ void Output_UpdateErrorsCall(PropertyStep step) #>
<#+ { #>
<#+  foreach (var ba in step.AssociatedBindAssignments.Where(ba => ba.IsTrackingTarget)) {#>
                UpdateErrors(<#=(ba as BindAssignmentBase).ConnectionIdElement.ObjectCodeName #>, errorInfo, "<#= step.PropertyName #>");
<#+  }#>
<#+  }#>

<#+ if (bindUniverse.INDEIPathSteps.Any()) { #>
    void UpdateErrors(<#=Projection(KnownNamespaces.XamlControls)#>::Control^ control, <#=Projection(KnownNamespaces.XamlData)#>::INotifyDataErrorInfo^ sender, ::Platform::String^ propertyName)
    {
        if (auto validationControl = dynamic_cast<<#=Projection(KnownNamespaces.XamlControls)#>::IInputValidationControl^>(control))
        {
            auto validationErrors =  validationControl->ValidationErrors;
            validationErrors->Clear();
            for (auto error : sender->GetErrors(propertyName))
            {
                auto inputValidationError = dynamic_cast<<#=Projection(KnownNamespaces.XamlControls)#>::InputValidationError^>(error);
                if (inputValidationError == nullptr)
                {
                    inputValidationError = ref new <#=Projection(KnownNamespaces.XamlControls)#>::InputValidationError(error->ToString());
                }
                validationErrors->Append(inputValidationError);
            }
        }
    }

<#+ }#>
<#+} #>
<#+             }#>
<#+ Output_BindingSetters(bindUniverse); #>
<#+ //End of bindings class #>
};
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>

    // Initializing static fields for each binding's enabled/disabled state
<#+                 foreach (ConnectionIdElement bindElement in bindUniverse.ElementsWithConnectCaseInLocalScope)#>
<#+                 {#>
<#+                     foreach (BindAssignment ba in bindElement.BindAssignments)#>
<#+                     {#>
bool <#=GetBindingFullClassName(bindUniverse, Model.CodeInfo)#>::<#=ba.DisableFlagName#> = false;
<#+                     }#>
<#+                 }#>
<#+             }#>
<#+         }#>
<#+     }#>

<#+     private string GetCacheArgumentStatement(BindPathStep step, string prefix, BindPathStep child)#>
<#+     {#>
<#+         return String.Format("{0}this->{1}{2}", step is RootStep ? "" : "&", prefix, child.CodeName);#>
<#+     }#>

<#+     private string GetCacheResolveStatement(BindPathStep step, string prefix, BindPathStep child)#>
<#+     {#>
<#+         if (step is RootStep)#>
<#+         {#>
<#+             Debug.Assert(child is DependencyPropertyStep);#>
<#+             string resolveAs = child is DependencyPropertyStep ? $"{Projection(KnownNamespaces.Xaml)}::DependencyObject" : "error";#>
<#+             return String.Format("this->{0}{1}.Resolve<{2}>()", prefix, child.CodeName, resolveAs);#>
<#+         }#>
<#+         else#>
<#+         {#>
<#+             return String.Format("this->{0}{1}", prefix, child.CodeName);#>
<#+         }#>
<#+     }#>

<#+ #>
<#+     private void Output_Listener_Tracking_Fields(BindUniverse bindUniverse)#>
<#+     {#>
<#+         Queue<string> cacheSteps = new Queue<string>();#>
<#+         Queue<string> eventTokenSteps = new Queue<string>();#>
<#+         Queue<string> dpTokenSteps = new Queue<string>();#>
<#+         foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true))#>
<#+         {#>
<#+             if (step.NeedsUpdateChildListeners)#>
<#+             {#>
<#+                if (step.ImplementsINPC)#>
<#+                {#>
<#+                     if (step.RequiresChildNotification)#>
<#+                     {#>
<#+                         if (step is RootStep)#>
<#+                         {#>
<#+                             cacheSteps.Enqueue("::Platform::WeakReference cachePC_" + step.CodeName + ";");#>
<#+                         }#>
<#+                         else#>
<#+                         {#>
<#+                             cacheSteps.Enqueue(Projection(KnownNamespaces.XamlData) + "::INotifyPropertyChanged^ cachePC_" + step.CodeName + " = nullptr;");#>
<#+                         }#>
<#+                     }#>
<#+                     eventTokenSteps.Enqueue("::Windows::Foundation::EventRegistrationToken tokenPC_" + step.CodeName + ";");#>
<#+                 }#>
<#+                 if (step.ImplementsINDEI && ProjectInfo.IsInputValidationEnabled)#>
<#+                 {#>
<#+                     if (step.RequiresChildNotification)#>
<#+                     {#>
<#+                         cacheSteps.Enqueue(Projection(KnownNamespaces.XamlData) + "::INotifyDataErrorInfo^ cacheEC_" + step.CodeName + " = nullptr;");#>
<#+                     }#>
<#+                     eventTokenSteps.Enqueue("::Windows::Foundation::EventRegistrationToken tokenEC_" + step.CodeName + ";");#>
<#+                 }#>
<#+                 if (step.ImplementsIObservableVector)#>
<#+                 {#>
<#+                     if (step.RequiresChildNotification)#>
<#+                     {#>
<#+                         cacheSteps.Enqueue(step.ValueType.CppCXName() + " cacheVC_" + step.CodeName + " = nullptr;");#>
<#+                     }#>
<#+                     eventTokenSteps.Enqueue("::Windows::Foundation::EventRegistrationToken tokenVC_" + step.CodeName + ";");#>
<#+                 }#>
<#+                 if (step.ImplementsIObservableMap)#>
<#+                 {#>
<#+                     if (step.RequiresChildNotification)#>
<#+                     {#>
<#+                         cacheSteps.Enqueue(step.ValueType.CppCXName() + " cacheMC_" + step.CodeName + " = nullptr;");#>
<#+                     }#>
<#+                     eventTokenSteps.Enqueue("::Windows::Foundation::EventRegistrationToken tokenMC_" + step.CodeName + ";");#>
<#+                 }#>
<#+                 else if (step.ImplementsINCC)#>
<#+                 {#>
<#+                     if (step.RequiresChildNotification)#>
<#+                     {#>
<#+                         cacheSteps.Enqueue(Projection(KnownNamespaces.XamlInterop) + "::INotifyCollectionChanged^ cacheCC_" + step.CodeName + " = nullptr;");#>
<#+                     }#>
<#+                     eventTokenSteps.Enqueue("::Windows::Foundation::EventRegistrationToken tokenCC_" + step.CodeName + ";");#>
<#+                 }#>
<#+                 foreach (DependencyPropertyStep child in step.TrackingSteps.OfType<DependencyPropertyStep>())#>
<#+                 {#>
<#+                     if (step is RootStep)#>
<#+                     {#>
<#+                         cacheSteps.Enqueue("::Platform::WeakReference cacheDPC_" + child.CodeName + ";");#>
<#+                     }#>
<#+                     else#>
<#+                     {#>
<#+                         cacheSteps.Enqueue(Projection(KnownNamespaces.Xaml) + "::DependencyObject^ cacheDPC_" + child.CodeName + " = nullptr;");#>
<#+                     }#>
<#+                     dpTokenSteps.Enqueue("__int64 tokenDPC_" + child.CodeName + " = 0;");#>
<#+                 }#>
<#+             }#>
<#+         }#>
<#+         while (cacheSteps.Count > 0)#>
<#+         {#>
    <#=cacheSteps.Dequeue()#>
<#+         }#>
<#+         while (eventTokenSteps.Count > 0)#>
<#+         {#>
    <#=eventTokenSteps.Dequeue()#>
<#+         }#>
<#+         while (dpTokenSteps.Count > 0)#>
<#+         {#>
    <#=dpTokenSteps.Dequeue()#>
<#+         }#>
<#+     }#>

<#+ private void Output_Connect_TwoWayBinding(BindAssignment ba)#>
<#+ {#>
<#+     Output_ApiInformationCall_Push(ba.ApiInformation, Indent.TwoTabs); #>
<#+     if (ba.NeedsLostFocusForTwoWay)#>
<#+     {#>
            <#=ba.ConnectionIdElement.ReferenceExpression#>->LostFocus += ref new <#=Projection(KnownNamespaces.Xaml)#>::RoutedEventHandler(
                    [this] (::Platform::Object^ sender, <#=Projection(KnownNamespaces.Xaml)#>::RoutedEventArgs^ e)
                    {
<#+     }#>
<#+     else#>
<#+     {#>
            <#=ba.ConnectionIdElement.ReferenceExpression#>->RegisterPropertyChangedCallback(<#=ba.MemberDeclaringType.CppCXName(false)#>::<#=ba.MemberName#>Property,
                ref new <#=Projection(KnownNamespaces.Xaml)#>::DependencyPropertyChangedCallback( 
                    [this] (<#=Projection(KnownNamespaces.Xaml)#>::DependencyObject^ sender, <#=Projection(KnownNamespaces.Xaml)#>::DependencyProperty^ prop)
                    {
<#+     }#>
                        if (this->IsInitialized())
                        {
                            // Update Two Way binding
<#+                     MethodStep bindBackStep = ba.BindBackStep as MethodStep; #>
<#+                     if (bindBackStep != null)#>
<#+                     {#>
<#+                         var param = bindBackStep.Parameters[0]; #>
                            <#=ba.MemberType#> <#=param.Name#> = <#=ba.ReverseAssignmentExpression#>;
<#+                         Output_NullCheckedAssignment(bindBackStep, null);#>
<#+                     }#>
<#+                     else#>
<#+                     {#>
<#+                         Output_NullCheckedAssignment(ba.PathStep, ba.ReverseAssignmentExpression);#>
<#+                     }#>
                        }
                    })<#=ba.NeedsLostFocusForTwoWay ? ";" : ");" #>
<#+     Output_ApiInformationCall_Pop(ba.ApiInformation, Indent.TwoTabs); #>
<#+ } #>

<#+ void  Output_NullCheckedAssignment(BindPathStep step, LanguageSpecificString value) #>
<#+ { #>
<#+     PushIndent(Indent.FourTabs);#>
<#+     foreach (var parent in step.Parents.Where(parent => parent.NeedsCheckForNull)) { #>
            if (<#=parent.CodeGen().PathExpression#> != nullptr)
            {
<#+         PushIndent(); #>
<#+     } #>
<#+     if (value != null) { #>
            <#=step.CodeGen().PathSetExpression(value)#>;
<#+     } else { #>
            <#=step.CodeGen().PathExpression#>;
<#+     } #>
<#+     foreach (var parent in step.Parents.Where(parent => parent.NeedsCheckForNull)) { #>
<#+         PopIndent(); #>
            }
<#+     } #>
<#+     PopIndent();#>
<#+ } #>

<#+     private void Output_UpdateChildListeners_Call(BindPathStep step, string parameter)#>
<#+     {#>
<#+         if (step.NeedsUpdateChildListeners)#>
<#+         {#>
<#+             Output_ApiInformationCall_Push(step.ApiInformation, Indent.OneTab); #>
<#+             if (step.ImplementsINPC)#>
<#+             {#>
        this->_bindingsTracking->UpdatePropertyChangedListener(<#=parameter#>, <#=GetCacheArgumentStatement(step, "cachePC_", step)#>, &tokenPC_<#=step.CodeName#>);
<#+             }#>
<#+             if (step.ImplementsINDEI && ProjectInfo.IsInputValidationEnabled)#>
<#+             {#>
        this->_bindingsTracking->UpdateErrorsChangedListener(<#=parameter#>, <#=GetCacheArgumentStatement(step, "cacheEC_", step)#>, &tokenEC_<#=step.CodeName#>);
<#+             }#>
<#+             if (step.ImplementsIObservableVector)#>
<#+             {#>
        this->_bindingsTracking->UpdateVectorChangedListener_<#=step.ValueType.ItemType.MemberFriendlyName()#>(<#=parameter#>, &cacheVC_<#=step.CodeName#>, &tokenVC_<#=step.CodeName#>);
<#+             }#>
<#+             if (step.ImplementsIObservableMap)#>
<#+             {#>
        this->_bindingsTracking->UpdateMapChangedListener_<#=step.ValueType.ItemType.MemberFriendlyName()#>(<#=parameter#>, &cacheMC_<#=step.CodeName#>, &tokenMC_<#=step.CodeName#>);
<#+             }#>
<#+             else if (step.ImplementsINCC)#>
<#+             {#>
        this->_bindingsTracking->UpdateCollectionChangedListener(<#=parameter#>, &cacheCC_<#=step.CodeName#>, &tokenCC_<#=step.CodeName#>);
<#+             }#>
<#+             foreach (DependencyPropertyStep child in step.TrackingSteps.OfType<DependencyPropertyStep>())#>
<#+             {#>
        this->_bindingsTracking->UpdateDependencyPropertyChangedListener(<#=parameter#>, <#=child.OwnerType.CppCXName(false)#>::<#=child.PropertyName#>Property, <#=GetCacheArgumentStatement(step, "cacheDPC_", child)#>, &this->tokenDPC_<#=child.CodeName#>);
<#+             }#>
<#+             Output_ApiInformationCall_Pop(step.ApiInformation, Indent.OneTab); #>
<#+         }#>
<#+     }#>

<#+ private void Output_Binding_Phased_SetValue(int phase, bool isTracking, BindPathStep bindStep, bool isFunctionResult)#>
<#+ {#>
<#+     var matchingBindAssignments = from ba in bindStep.BindAssignments where ba.ComputedPhase == phase && ba.IsTrackingSource == isTracking select ba;#>
<#+     if (matchingBindAssignments.Count() > 0)#>
<#+     {#>
<#+         string condition =  GetDirectPhaseCondition(phase, isTracking); #>
        if (<#=condition#>)
        {
<#+         PushIndent();#>
<#+         foreach (BindAssignment bindAssignment in matchingBindAssignments)#>
<#+         {#>
<#+             Output_Binding_SetValue(bindAssignment, isFunctionResult);#>
<#+         }#>
<#+         PopIndent();#>
        }
<#+     }#>
<#+ }#>

<#+ private void Output_Binding_Phased_Fallback_SetValue(int phase, bool isTracking, BindPathStep bindStep)#>
<#+ {#>
<#+     var matchingBindAssignments = from ba in bindStep.BindAssignments where ba.ComputedPhase == phase && ba.IsTrackingSource == isTracking && ba.BindStatus.HasFlag(BindStatus.HasFallbackValue) select ba;#>
<#+     if (matchingBindAssignments.Count() > 0)#>
<#+     {#>
<#+         string condition =  GetDirectPhaseCondition(phase, isTracking); #>
        if (<#=condition#>)
        {
<#+         PushIndent();#>
<#+         foreach (BindAssignment bindAssignment in matchingBindAssignments)#>
<#+         {#>
<#+             Output_Binding_SetValue_Non_Function_Call(bindAssignment, bindAssignment.FallbackValueExpression.CppCXName(), true);#>
<#+         }#>
<#+         PopIndent();#>
        }
<#+     }#>
<#+ }#>

<#+ private void Output_Binding_SetValue(BindAssignment bindAssignment, bool isFunctionResult)#>
<#+ {#>
<#+         if (bindAssignment.PathStep is FunctionStep && !isFunctionResult)#>
<#+         {#>
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>
        if (!<#=bindAssignment.DisableFlagName#>)
        {
<#+                 PushIndent();#>
<#+             }#>
        this->PendingFunctionBindings["<#=bindAssignment.PathStep.CodeName#>"] = std::bind(&<#=GetBindingFullClassName(bindAssignment.BindUniverse, Model.CodeInfo)#>::Invoke_<#=bindAssignment.PathStep.CodeName#>, this, std::placeholders::_1);
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>
<#+                 PopIndent();#>
        }
<#+             }#>
<#+         }#>
<#+         else#>
<#+         {#>
<#+             string value = bindAssignment.DirectAssignmentExpression(isFunctionResult ? "result" : "obj").CppCXName();#>
<#+             Output_Binding_SetValue_Non_Function_Call(bindAssignment, value, true);#>
<#+         }#>
<#+     }#>

<#+ private void Output_Binding_SetValue_Non_Function_Call(BindAssignment bindAssignment, String value, bool includeDeferredSet)#>
<#+ {#>
<#+     var element = bindAssignment.ConnectionIdElement;#>
        // <#=element.LineNumberAndXamlFile#>
<#+     if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+     {#>
        if (!<#=bindAssignment.DisableFlagName#>)
        {
<#+         PushIndent();#>
<#+     }#>
<#+     Output_ApiInformationCall_Push(bindAssignment.ApiInformation, Indent.OneTab); #>
<#+     if (bindAssignment is BoundLoadAssignment) { #>
<#+         if (includeDeferredSet) { #>
        this-><#=bindAssignment.ObjectDeferredAssignmentCodeName#> = <#=value#>;

<#+     }#>
        if (<#=value#>)
        {
<#+         if (bindAssignment.BindUniverse.IsFileRoot) { #>
            this->GetDataRoot()->FindName("<#=element.ElementName#>");
<#+         } else { #>
            <#=bindAssignment.BindUniverse.RootElement.ReferenceExpression#>->FindName("<#=element.ElementName#>");
<#+         }#>
        }
        else
        {
<#+         if (bindAssignment.BindUniverse.IsFileRoot) { #>
            this->GetDataRoot()->UnloadObject(<#=element.ReferenceExpression#>);
<#+         } else { #>
            if (<#=element.ReferenceExpression#> != nullptr) 
            {
                <#=Projection(KnownNamespaces.XamlMarkup)#>::XamlMarkupHelper::UnloadObject(<#=element.ReferenceExpression#>);
            }
            this->DisconnectUnloadedObject(<#=element.ConnectionId#>);
<#+         }#>
        }
<#+     } else { #>
<#+         if (element.NeedsNullCheckBeforeSetValue) {#>
        if (this-><#=element.ObjectCodeName#> != nullptr)
        {
<#+             PushIndent();#>
<#+         }#>
<#+         if (bindAssignment.MemberType.IsNullable)#>
<#+         {#>
        Set_<#=bindAssignment.MemberDeclaringType.MemberFriendlyName()#>_<#=bindAssignment.MemberName#>(<#=element.ReferenceExpression#>, <#=value#>, <#=bindAssignment.TargetNullValueExpression#>);
<#+         } else {#>
        Set_<#=bindAssignment.MemberDeclaringType.MemberFriendlyName()#>_<#=bindAssignment.MemberName#>(<#=element.ReferenceExpression#>, <#=value#>);
<#+         }#>
<#+         if (element.NeedsNullCheckBeforeSetValue) {#>
<#+             PopIndent();#>
        }
<#+             if (includeDeferredSet && element.CanBeInstantiatedLater) { #>
        else
        {
            this-><#=bindAssignment.ObjectDeferredAssignmentCodeName#> = <#=value#>;
        }
<#+             }#>
<#+         }#>
<#+     }#>
<#+     Output_ApiInformationCall_Pop(bindAssignment.ApiInformation, Indent.OneTab); #>
<#+     if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+     {#>
<#+         PopIndent();#>
        }
<#+     }#>
<#+ }#>

<#+ private void Output_Update_DataChanged_Step( BindPathStep step)#>
<#+ {#>
<#+     if (step.Parent.ValueType.IsNullable) #>
<#+     {#>
        if (obj != nullptr)
        {
<#+     }#>
<#+     Output_UpdateCall(step, KnownStrings.DataChanged); #>
<#+     if (step.Parent.ValueType.IsNullable) #>
<#+     {#>
        }
<#+     }#>
<#+     if (step.BindStatus.HasFlag(BindStatus.HasFallbackValue)) #>
<#+     {#>
        else
        {
            this->UpdateFallback_<#=step.CodeName#>(DATA_CHANGED);
        }
<#+     }#>
<#+ }#>

<#+ private void Output_Update_Steps(bool checkForNull, IEnumerable<BindPathStep> steps, bool checkPhaseCondition, string phaseParam)#>
<#+ {#>
<#+     if (steps.Count() > 0) #>
<#+     {#>
<#+         if (checkForNull) #>
<#+         {#>
        if (obj != nullptr)
        {
<#+         }#>
<#+         List<BindPathStep> stepsWithFallback = new List<BindPathStep>();#>
<#+         string lastCondition = null;#>
<#+         foreach (BindPathStep childStep in (from step in steps where step.IsIncludedInUpdate orderby step.PhaseList select step))#>
<#+         {#>
<#+             if(checkPhaseCondition) #>
<#+             { #>
<#+                 string thisCondition = GetPhaseCondition(childStep);#>
<#+                 if (thisCondition != lastCondition)#>
<#+                 {#>
<#+                     if (lastCondition != null)#>
<#+                     {#>
            }
<#+                     }#>
<#+                     lastCondition = thisCondition;#>
            if (<#=thisCondition#>)
            {
<#+                 }#>
<#+                 PushIndent();#>
<#+                 Output_UpdateCall(childStep, phaseParam); #>
<#+                 PopIndent();#>
<#+             }#>
<#+             else#>
<#+             {#>
<#+                 if (lastCondition != null)#>
<#+                 {#>
            }
<#+                 }#>
<#+                 lastCondition = null;#>
<#+                 Output_UpdateCall(childStep, phaseParam); #>
<#+             } #>
<#+             if (childStep.BindStatus.HasFlag(BindStatus.HasFallbackValue)) #>
<#+             {#>
<#+               stepsWithFallback.Add(childStep);#>
<#+             }#>
<#+         }#>
<#+                 if (lastCondition != null)#>
<#+                 {#>
            }
<#+                 }#>
<#+         if (checkForNull) #>
<#+         {#>
        }
<#+             if (stepsWithFallback.Count > 0) #>
<#+             {#>
        else
        {
<#+                 foreach (BindPathStep childStep in stepsWithFallback)#>
<#+                 {#>
<#+                     if(checkPhaseCondition) #>
<#+                     { #>
            if (<#=GetPhaseCondition(childStep)#>)
            {
                this->UpdateFallback_<#=childStep.CodeName#>(<#=phaseParam#>);
            }
<#+                     } #>
<#+                     else #>
<#+                     { #>
            this->UpdateFallback_<#=childStep.CodeName#>(<#=phaseParam#>);
<#+                     } #>
<#+                 }#>
        }
<#+             }#>
<#+         }#>
<#+     }#>
<#+ }#>

<#+ private void Output_Custom_Update_Call(BindPathStep step, string firstArgument, string phaseParam)#>
<#+ {#>
<#+     if (string.IsNullOrEmpty(firstArgument))#>
<#+     {#>
            this->Update_<#=step.CodeName#>(<#=phaseParam#>);
<#+     }#>
<#+     else#>
<#+     {#>
<#+         Output_ApiInformationCall_Push(step.ApiInformation, Indent.TwoTabs);#>
            this->Update_<#=step.CodeName#>(<#=firstArgument#>, <#=phaseParam#>);
<#+         Output_ApiInformationCall_Pop(step.ApiInformation, Indent.TwoTabs);#>
<#+     }#>
<#+ }#>

<#+ private void Output_UpdateCall(BindPathStep step, string phaseParam)#>
<#+ {#>
<#+     string firstArgument = step.CodeGen().UpdateCallParam.CppCXName(); #>
<#+     Output_Custom_Update_Call(step, firstArgument, phaseParam); #>
<#+ }#>

<#+ private string GetMemberAccessOperator(BindPathStep bindStep)#>
<#+ {#>
<#+     return bindStep.ValueType.UnderlyingType.IsValueType ? "." : "->"; #>
<#+ }#>

<#+ private string GetUpdateParams(BindPathStep bindStep)#>
<#+ {#>
<#+     if (bindStep is FunctionStep)#>
<#+     {#>
<#+         return "int phase";#>
<#+     }#>
<#+     else#>
<#+     {#>
<#+         return bindStep.ValueType.CppCXName() + " obj, int phase";#>
<#+     }#>
<#+ }#>


<#+ private void Output_CompleteUpdate(BindUniverse bindUniverse)#>
<#+ {#>
<#+     List<string> conditions = new List<string>();#>
<#+     bool needsLoop = bindUniverse.UnloadableBindingSourceElements.Any(); #>

    void CompleteUpdate(int phase)
    {
<#+     if (needsLoop) { #>
        do
        {
<#+         PushIndent(); #>
<#+     } #>
<#+     if (bindUniverse.HasFunctionBindings) { #>
        auto copiedBindings = std::move(this->PendingFunctionBindings);
        this->PendingFunctionBindings = std::map<::Platform::String^, std::function<void (int)>>();

        for(auto& pair : copiedBindings)
        {
            pair.second(phase);
        }
<#+         conditions.Add("!this->PendingFunctionBindings.empty()"); #>
<#+     } #>
<#+     if (bindUniverse.UnloadableBindingSourceElements.Any()) {#>
        while (!this->UnloadableBindingSourcesToUpdate.empty())
        {
            this->UnloadableBindingSourcesToUpdate.front()();
            this->UnloadableBindingSourcesToUpdate.pop_front();
        }
<#+         conditions.Add("!this->UnloadableBindingSourcesToUpdate.empty()"); #>
<#+     } #>
<#+     if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) { #>
        while (!this->UnloadedElementsToUpdate.empty())
        {
            this->UpdateUnloadedElement(this->UnloadedElementsToUpdate.front());
            this->UnloadedElementsToUpdate.pop_front();
        }
<#+         conditions.Add("!this->UnloadedElementsToUpdate.empty()"); #>
<#+     } #>
<#+     if (needsLoop) { #>
<#+         PopIndent(); #>
        }
        while (<#=string.Join(" || ", conditions)#>);
<#+     } #>
    }
<#+ }#>

<#+ private void Output_FunctionBindings(BindUniverse bindUniverse)#>
<#+ {#>
    std::map<::Platform::String^, std::function<void (int)>> PendingFunctionBindings;

<#+     foreach (FunctionStep functionStep in bindUniverse.BindPathSteps.Values.Where(s => s is FunctionStep))#>
<#+     {#>

    void Invoke_<#=functionStep.CodeName#>(int phase)
    {
<#+         foreach (var param in functionStep.Parameters.OrderBy(p => p.HasTryGetValue)) {#>
<#+             if (param.HasTryGetValue && functionStep.RequiresSafeParameterRetrieval) {#>
        <#=param.AssignmentType#> <#=param.Name#>;
        if (!<#=param.TryGetValueCodeName#>(<#=param.Name#>)) { return; }
<#+             } else {#>
        <#=param.ValueType#> <#=param.Name#> = <#=param.CodeGen().PathExpression#>;
<#+             }#>
<#+         }#>
        <#=functionStep.ValueType#> result = <#= functionStep.CodeGen().PathExpression #>;
<#+         foreach (int distinctPhase in functionStep.DistinctPhases) {#>
<#+             Output_Binding_Phased_SetValue(distinctPhase, true, functionStep, true);#>
<#+             Output_Binding_Phased_SetValue(distinctPhase, false, functionStep, true);#>
<#+         }#>
    }
<#+     }#>
<#+ }#>

<#+ private void Output_TryGetValueFunctions(BindUniverse bindUniverse)#>
<#+ {#>
<#+     foreach (BindPathStep step in bindUniverse.TryGetValueSteps)#>
<#+     {#>

    bool <#=step.TryGetValueCodeName#>(<#=step.ValueType#>& val)
    {
<#+         if (step is RootStep || !step.Parent.IsIncludedInUpdate) {#>
        val = <#=step.CodeGen().PathExpression#>;
        return true;
<#+         }#>
<#+         else {#>
        <#=step.Parent.ValueType#> obj;
<#+             if (step.Parent.ValueType.IsNullable) {#>
        if (<#=step.Parent.TryGetValueCodeName#>(obj) && obj != nullptr)
<#+             } else { #>
        if (<#=step.Parent.TryGetValueCodeName#>(obj))
<#+             } #>
        {
            val = <#=step.CodeGen().UpdateCallParam#>;
            return true;
        }
        else
        {
            return false;
        }
<#+         }#>
    }
<#+     }#>
<#+ }#>

<#+ private void Output_ApiInformationCall_Push(ApiInformation apiInformation, Indent indent)#>
<#+ {#>
<#+     if (apiInformation != null) { #>
<#+         PushIndent(indent); #>
    if (<#=Model.CodeInfo.ClassName.ShortName#>_<#= apiInformation.MemberFriendlyName #>)
    {
<#+         PopIndent(); #>
<#+         PushIndent(); #>
<#+     } #>
<#+ } #>

<#+ private void Output_ApiInformationCall_Pop(ApiInformation apiInformation, Indent indent)#>
<#+ {#>
<#+     if (apiInformation != null) { #>
<#+         PopIndent(); #>
<#+         PushIndent(indent); #>
    }
<#+         PopIndent(); #>
<#+     } #>
<#+ } #>

<#+ private void Output_ApiInformationDeclarations()#>
<#+ {#>
<#+     if (Model.ApiInformationDeclarations.Any()) { #>

<#= Model.CodeInfo.ClassName.Namespace.AsNamespaceDeclarationBegin() #>
{
    // Api Information for conditional namespace declarations
<#+     foreach (var apiInformation in Model.ApiInformationDeclarations) { #>
    bool <#=Model.CodeInfo.ClassName.ShortName#>_<#= apiInformation.MemberFriendlyName #>;
<#+     } #>
} <#= Model.CodeInfo.ClassName.Namespace.AsNamespaceDeclarationEnd() #>
<#+     } #>
<#+ } #>

<#+ private void Output_ApiInformationInit()#>
<#+ {#>
<#+     if (Model.ApiInformationDeclarations.Any()) { #>

    // Api Information for conditional namespace declarations
<#+         foreach (var apiInformation in Model.ApiInformationDeclarations) { #>
    <#=Model.CodeInfo.ClassName.ShortName#>_<#= apiInformation.MemberFriendlyName #> = <#= apiInformation.CodeGen().CallExpression #>;
<#+         } #> 
<#+     } #>
<#+ } #>

<#+ private void Output_BindingSetValueFunction(BindAssignment ba)#>
<#+ {#>
<#+     if (ba.MemberType.IsNullable)#>
<#+     {#>
    static void Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(<#=ba.MemberTargetType#> obj, <#=ba.MemberType#> value, ::Platform::String^ targetNullValue)
    {
        if (value == nullptr && targetNullValue != nullptr)
        {
<#+             if (ba.MemberType.IsString())#>
<#+             {#>
            value = targetNullValue;
<#+             }#>
<#+             else#>
<#+             {#>
            value = <#=ba.MemberType.GetStringToThing("targetNullValue")#>;
<#+             }#>
        }
<#+     }#>
<#+     else#>
<#+     {#>
    static void Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(<#=ba.MemberTargetType#> obj, <#=ba.MemberType#> value)
    {
<#+     }#>
<#+         if (ba.IsAttachable)#>
<#+         {#>
        <#=ba.MemberDeclaringType.CppCXName(false)#>::Set<#=ba.MemberName#>(obj, value);
<#+         }#>
<#+         else#>
<#+         {#>
        obj-><#=ba.MemberName#> = value;
<#+         }#>
    }
<#+ }#>

<#+ private void Output_BindingSetters(BindUniverse bu)
{
    var distinctAsignmentsByMember = from ba in bu.BindAssignments.Where(ba => ba.HasSetValueHelper) group ba by ba.MemberFullName;
    foreach (var item in distinctAsignmentsByMember) {
        Output_BindingSetValueFunction(item.First());
    }
}#>

<#+ private void Output_BindingTrackingClass(BindUniverse bu) { #>
/// <summary>
/// Auto generated class for compiled bindings.
/// </summary>
<#+  foreach(string ns in Model.CodeInfo.ClassName.Namespace.Split('.')) { #>
namespace <#=ns#> {
<#+  }  #>
    ref class <#=bu.BindingsTrackingClassName#> sealed : ::XamlBindingInfo::XamlBindingTrackingBase
    {
    internal:
        <#=bu.BindingsTrackingClassName#>()
        {
        }

        // Event handlers
<#+ IEnumerable<XamlType>  observableVectorTypes = bu.BindPathSteps.Values.Where(s => s.ValueType.ImplementsIObservableVector()).Select(s => s.ValueType.ItemType).Distinct();#>
<#+ IEnumerable<XamlType>  observableMapTypes = bu.BindPathSteps.Values.Where(s => s.ValueType.ImplementsIObservableMap()).Select(s => s.ValueType.ItemType).Distinct();#>
<#+ foreach (XamlType type in observableVectorTypes)#>
<#+ { #>

        void VectorChanged_<#=type.MemberFriendlyName()#>(::Windows::Foundation::Collections::IObservableVector<<#=type#>>^ sender, ::Windows::Foundation::Collections::IVectorChangedEventArgs^ e)
        {
            VectorChanged(sender, e);
        }
<#+ } #>
<#+ #>
<#+ foreach (XamlType type in observableMapTypes)#>
<#+ { #>

        void MapChanged_<#=type.MemberFriendlyName()#>(::Windows::Foundation::Collections::IObservableMap<::Platform::String^, <#=type#>>^ sender, ::Windows::Foundation::Collections::IMapChangedEventArgs<::Platform::String^>^ e)
        {
            MapChanged(sender, e);
        }
<#+ } #>

        // Listener update functions
<#+ #>
<#+ foreach (XamlType type in observableVectorTypes)#>
<#+ { #>

        void UpdateVectorChangedListener_<#=type.MemberFriendlyName()#>(::Windows::Foundation::Collections::IObservableVector<<#=type#>>^ obj, ::Windows::Foundation::Collections::IObservableVector<<#=type#>>^* pCache, ::Windows::Foundation::EventRegistrationToken* pToken)
        {
            if (*pCache != nullptr && !(*pCache)->Equals(obj))
            {
                (*pCache)->VectorChanged -= *pToken;
                *pCache = nullptr;
            }

            if (*pCache == nullptr && obj != nullptr)
            {
                *pCache = obj;
                *pToken = obj->VectorChanged += ref new ::Windows::Foundation::Collections::VectorChangedEventHandler<<#=type#>>(
                    this, &<#=GetBindingTrackingFullClassName(bu, Model.CodeInfo)#>::VectorChanged_<#=type.MemberFriendlyName()#>);
            }
        }
<#+ } #>
<#+ #>
<#+ foreach (XamlType type in observableMapTypes)#>
<#+ { #>

        void UpdateMapChangedListener_<#=type.MemberFriendlyName()#>(::Windows::Foundation::Collections::IObservableMap<::Platform::String^, <#=type#>>^ obj, ::Windows::Foundation::Collections::IObservableMap<::Platform::String^, <#=type#>>^* pCache, ::Windows::Foundation::EventRegistrationToken* pToken)
        {
            if (*pCache != nullptr && !(*pCache)->Equals(obj))
            {
                (*pCache)->MapChanged -= *pToken;
                *pCache = nullptr;
            }

            if (*pCache == nullptr && obj != nullptr)
            {
                *pCache = obj;
                *pToken = obj->MapChanged += ref new ::Windows::Foundation::Collections::MapChangedEventHandler<::Platform::String^, <#=type#>>(
                    this, &<#=GetBindingTrackingFullClassName(bu, Model.CodeInfo)#>::MapChanged_<#=type.MemberFriendlyName()#>);
            }
        }
<#+ } #>
    };
<#+  foreach(string ns in Model.CodeInfo.ClassName.Namespace.Split('.')) { #>
}
<#+  }  #>
<#+ }#>
