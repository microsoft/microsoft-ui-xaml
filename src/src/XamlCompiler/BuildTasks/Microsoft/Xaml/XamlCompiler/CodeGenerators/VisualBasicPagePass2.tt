<#@ template language="C#" inherits="VB_CodeGenerator<PageDefinition>" visibility="internal" linePragmas="false"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#  foreach(var pair in Model.XamlFileFullPathAndCheckSums) #>
<#  {   #>
#ExternalChecksum("<#=pair.FileName#>", "<#=Model.ChecksumAlgorithmGuid#>", "<#=pair.Checksum#>")
<#  }   #>
'------------------------------------------------------------------------------
' <auto-generated>
'     This code was generated by a tool.
'
'     Changes to this file may cause incorrect behavior and will be lost if
'     the code is regenerated.
' </auto-generated>
'------------------------------------------------------------------------------

Option Strict Off
Option Explicit On

Namespace <#=Globalize(Model.CodeInfo.ClassName.Namespace)#>

    Partial Class <#=Model.CodeInfo.ClassName.ShortName#>
<# if (!Model.CodeInfo.IsApplication)#>
<# {#>
        Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector

<#      if (Model.CodeInfo.HasBindingSetters) #>
<#      { #>
        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        Friend Class XamlBindingSetters
<#      var bindingSetters = new HashSet<String>();#>
<#      foreach (ConnectionIdElement connectionId in Model.AllConnectionIdElements)#>
<#      {#>
<#          foreach (BindPathStep step in connectionId.BindUniverse.BindPathSteps.Values)#>
<#          {#>
<#              foreach (BindAssignment bindAssignment in step.BindAssignments.Where(ba => ba.HasSetValueHelper))#>
<#              {#>
<#                  if (!bindingSetters.Contains(bindAssignment.MemberFullName))#>
<#                  {#>
<#                      Output_Binding_SetValue_Function(bindAssignment);#>
<#                      bindingSetters.Add(bindAssignment.MemberFullName);#>
<#                  }#>
<#              }#>
<#          }#>
<#      }#>
<# #>
        End Class
<#      } #>
<#      if (Model.CodeInfo.IsUsingCompiledBinding) #>
<#      { #>

<#          Output_BindingsClasses();  #>
<#      } #>

<#      Output_ConnectMethod();  #>
<#      Output_UnloadObjectMethod(); #>

<#      Output_GetBindingConnectorMethod();  #>
<#      Output_ApiInformationDeclarations();  #>
<#      Output_InitializeXProperties(); #>
<# }#>
    End Class

End Namespace

<#+     private void Output_InitializeXProperties() #>
<#+     { #>
<#+         if (Model.XProperties.Any()) #>
<#+         { #>

        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        Private Sub InitializeXProperties()
<#+             foreach (xProperty xProp in Model.XProperties) #>
<#+             { #>
<#+                 if (xProp.DefaultValueString != null) #>
<#+                 { #>
            _<#=xProp.Name#> = <#=xProp.PropertyType.GetStringToThing($"\"{xProp.DefaultValueString}\"")#>
<#+                 } #>
<#+                 if (xProp.DefaultValueMarkup != null) #>
<#+                 { #>
            _<#=xProp.Name#> = DirectCast(<#=Globalize(KnownNamespaces.XamlMarkup)#>.XamlReader.Load(<#=xProp.DefaultValueMarkup#>), <#=xProp.PropertyType.VBName()#>)
<#+                 } #>
<#+             } #>
        End Sub
<#+         } #>
<#+     } #>
<#+     private void Output_ConnectMethod()#>
<#+     {#>
        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        Public Sub Connect(ByVal connectionId As Integer, ByVal target As Global.System.Object) Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector.Connect
<#+         if(Model.ConnectableElements.Any()) #>
<#+         {#>
            Select Case connectionId
<#+             foreach (ConnectionIdElement element in Model.ConnectableElements)#>
<#+             {#>
            Case <#=element.ConnectionId#> ' <#=element.LineNumberAndXamlFile#>
<#+                 FieldDefinition fieldInfo = element.FieldDefinition; #>
<#+                 string objectInitName; #>
<#+                 string objectName; #>
<#+                 if(fieldInfo == null) #>
<#+                 { #>
<#+                     objectInitName = "Dim " + element.ElementCodeName + " As " + element.Type.VBName(); #>
<#+                     objectName = element.ElementCodeName; #>
<#+                 } #>
<#+                 else #>
<#+                 { #>
<#+                     objectInitName = "Me." + fieldInfo.FieldName; #>
<#+                     objectName = "Me." + fieldInfo.FieldName; #>
<#+                 } #>
<#+                 Output_PushDeprecated(element.Type.IsDeprecated()); #>
<#+                 Output_ApiInformationCall_Push(element.ApiInformation, Indent.TwoTabs); #>
                    <#=objectInitName#> = CType(target, <#=element.Type#>)
<#+                 foreach (EventAssignment ev in element.EventAssignments)#>
<#+                 {#>
<#+                     Output_ApiInformationCall_Push(ev.ApiInformation, Indent.TwoTabs); #>
                AddHandler DirectCast(<#=objectName#>, <#=element.Type#>).<#=ev.EventName#>, AddressOf Me.<#=ev.HandlerName#>
<#+                     Output_ApiInformationCall_Pop(ev.ApiInformation, Indent.TwoTabs); #>
<#+                 }#>
<#+                 Output_PopDeprecated(element.Type.IsDeprecated()); #>
<#+                 Output_ApiInformationCall_Pop(element.ApiInformation, Indent.TwoTabs); #>
                    Exit Select
<#+             }#>
                    Case Else
                        Exit Select
            End Select
<#+         }#>
                Me._contentLoaded = true
        End Sub
<#+     }#>

<#+     private void Output_UnloadObjectMethod()#>
<#+     {#>
<#+         if (Model.UnloadableFields.Count() > 0)#>
<#+         {#>

        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        Private Sub UnloadObject(unloadableObject As <#=Globalize(KnownNamespaces.Xaml)#>.DependencyObject)
            If unloadableObject IsNot Nothing Then
<#+             foreach (var element in Model.UnloadableFields) { #>
                ' <#=element.LineNumberAndXamlFile#>
<#+                 Output_ApiInformationCall_Push(element.ApiInformation, Indent.OneTab); #>
                If unloadableObject Is Me.<#=element.ElementName#> Then
                    Me.DisconnectUnloadedObject(<#=element.ConnectionId#>)
                End If
<#+                 Output_ApiInformationCall_Pop(element.ApiInformation, Indent.OneTab); #>
<#+             } #>
                <#=Globalize(KnownNamespaces.XamlMarkup)#>.XamlMarkupHelper.UnloadObject(unloadableObject)
            End If
        End Sub

        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        Private Sub DisconnectUnloadedObject(connectionId As Integer)
            Select Case connectionId
<#+             foreach (var element in Model.DeferrableElements)#>
<#+             {#>
                Case <#=element.ConnectionId#>: ' <#=element.LineNumberAndXamlFile#>
<#+                 foreach (var childElem in element.Children) #>
<#+                 {#>
<#+                     if (childElem.HasFieldDefinition) #>
<#+                     {#>
                    Me.DisconnectUnloadedObject(<#=childElem.ConnectionId#>)
<#+                     }#>
<#+                     if (childElem.HasBindAssignments || element.HasRootNamedElementStep) #>
<#+                     {#>
                    Me.Bindings.DisconnectUnloadedObject(<#=childElem.ConnectionId#>)
<#+                     }#>
<#+                 }#>
<#+                 if (element.HasBindAssignments || element.HasRootNamedElementStep) #>
<#+                 {#>
                    Me.Bindings.DisconnectUnloadedObject(<#=element.ConnectionId#>)
<#+                 }#>
<#+                 FieldDefinition fieldInfo = element.FieldDefinition; #>
<#+                 if(fieldInfo != null) #>
<#+                 { #>
                    Me.<#=fieldInfo.FieldName#> = Nothing
<#+                 } #>
                    Exit Select
<#+             }#>
                Case Else
                    Throw New Global.System.ArgumentException("Invalid connectionId.")
            End Select
        End Sub
<#+         } #>
<#+     }#>
<#+     private void Output_GetBindingConnectorCaseBindingPropertiesSet(ConnectionIdElement element, bool isPageRoot) #>
<#+     { #>
<#+         if (element.BindUniverse.NeededForOuterScopeElement) #>
<#+         { #>
<#+             if (isPageRoot) #>
<#+             { #>
<#+                 if (Model.CodeInfo.IsResourceDictionary)#>
<#+                 {#>
                    bindings.RootWeakReference = New Global.System.WeakReference(Of <#=Globalize(KnownNamespaces.Xaml)#>.ResourceDictionary)(Me)
<#+                 }#>
<#+                 else#>
<#+                 {#>
                    bindings.RootWeakReference = New Global.System.WeakReference(Of <#=Globalize(KnownNamespaces.Xaml)#>.FrameworkElement)(Me)
<#+                 }#>
<#+                 if (!element.BindUniverse.IsFileRoot) #>
<#+                 { #>
                    bindings.Parent = New Global.System.WeakReference(Me.Bindings)
<#+                 } #>
<#+             } #>
<#+             else #>
<#+             { #>
                    bindings.RootWeakReference = Me.RootWeakReference
                    bindings.Parent = New Global.System.WeakReference(Me)
<#+             } #>
<#+         } #>
<#+     } #>

<#+     private void Output_GetBindingConnectorCase(ConnectionIdElement element, bool isPageRoot) #>
<#+     {#>
               Case <#=element.ConnectionId#>: ' <#=element.LineNumberAndXamlFile#>
<#+         Output_PushDeprecated(element.Type.IsDeprecated());#>
<#+         if (element.Type.IsDerivedFromControlTemplate())#>
<#+         {#>
                    Dim <#=element.ElementTemplatedParentCodeName#> As <#=element.TemplatedParentType#> = TryCast(target, <#=element.TemplatedParentType#>)
                    If <#=element.ElementTemplatedParentCodeName#> IsNot Nothing Then
                        Dim bindings As <#=element.BindUniverse.BindingsClassName#> = New <#=element.BindUniverse.BindingsClassName#>()
                        returnValue = bindings
                        bindings.SetDataRoot(<#=element.ElementTemplatedParentCodeName #>)
                        <#=Globalize(KnownNamespaces.XamlMarkup)#>.XamlBindingHelper.SetDataTemplateComponent(<#=element.ElementTemplatedParentCodeName#>, bindings)
<#+             PushIndent(Indent.TwoTabs); #>
<#+             Output_GetBindingConnectorCaseBindingPropertiesSet(element, isPageRoot); #>
<#+             PopIndent(); #>
                    End If
<#+         } else {#>
                    Dim <#=element.ElementCodeName#> As <#=element.Type#> = CType(target, <#=element.Type#>)
                    Dim bindings As <#=element.BindUniverse.BindingsClassName#> = New <#=element.BindUniverse.BindingsClassName#>()
                    returnValue = bindings
                    bindings.SetDataRoot(<#=element.IsBindingFileRoot ? "Me" : element.ElementCodeName + ".DataContext" #>)
<#+             if (element.BindUniverse.DistinctConvertersUsed.Count() > 0) #>
<#+             {#>
<#+                 if (isPageRoot) #>
<#+                 { #>
                    bindings.SetConverterLookupRoot(Me)
<#+                 } #>
<#+                 else #>
<#+                 { #>
<#+                     if (Model.CodeInfo.IsResourceDictionary)#>
<#+                     {#>
                    Dim rootReference As <#=Globalize(KnownNamespaces.Xaml)#>.ResourceDictionary
<#+                     }#>
<#+                     else#>
<#+                     {#>
                    Dim rootReference As <#=Globalize(KnownNamespaces.Xaml)#>.FrameworkElement
<#+                     }#>
                    Me.RootWeakReference.TryGetTarget(rootReference)
                    bindings.SetConverterLookupRoot(rootReference)
<#+                 } #>
<#+             }#>
<#+             if (element.IsBindingFileRoot)#>
<#+             { #>
                    Me.Bindings = bindings
                    AddHandler <#=element.ElementCodeName#>.Loading, AddressOf bindings.Loading
<#+             }#>
<#+             else#>
<#+             {#>
                    AddHandler <#=element.ElementCodeName#>.DataContextChanged, AddressOf bindings.DataContextChangedHandler
                    <#=Globalize(KnownNamespaces.Xaml)#>.DataTemplate.SetExtensionInstance(<#=element.ElementCodeName#>, bindings)
<#+             }#>
<#+             if (ProjectInfo.ShouldGenerateDisableXBind || !element.IsBindingFileRoot) #>
<#+             {#>
                    <#=Globalize(KnownNamespaces.XamlMarkup)#>.XamlBindingHelper.SetDataTemplateComponent(<#=element.ElementCodeName#>, bindings)
<#+             }#>
<#+             Output_GetBindingConnectorCaseBindingPropertiesSet(element, isPageRoot); #>
<#+         }#>
<#+         Output_PopDeprecated(element.Type.IsDeprecated()); #>
                    Exit Select
<#+     }#>

<#+     private void Output_GetBindingConnectorMethod()#>
<#+     {#>
        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        Public Function GetBindingConnector(connectionId As Integer, target As Object) As <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector.GetBindingConnector
            Dim returnValue As <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector = Nothing
<#+         if (Model.CodeInfo.BindStatus != BindStatus.None) #>
<#+         { #>
            Select Case connectionId
<#+             foreach (ConnectionIdElement element in Model.AllConnectionIdElements)#>
<#+             {#>
<#+                 if (element.IsBindingRoot)#>
<#+                 {#>
<#+                     Output_GetBindingConnectorCase(element, true); #>
<#+                 }#>
<#+             }#>
            End Select
<#+       } #>
            Return returnValue
        End Function
<#+     }#>
<#+ #>
<#+     private void Output_PushDeprecated(bool isDeprecated)#>
<#+     {#>
<#+         if (isDeprecated) #>
<#+         { #>
#Disable Warning BC40000  ' Warning on Deprecated usage
<#+         } #>
<#+     }#>

<#+     private void Output_PopDeprecated(bool isDeprecated)#>
<#+     {#>
<#+         if (isDeprecated) #>
<#+         { #>
#Enable Warning BC40000
<#+         } #>
<#+     }#>

<#+     private void Output_BindingsClasses()#>
<#+     {#>
<#+         foreach (BindUniverse bindUniverse in Model.CodeInfo.BindUniverses)#>
<#+         {#>

        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        Private Class <#=bindUniverse.BindingsClassName#>
<#+             if (bindUniverse.NeedsIDataTemplateExtension) #>
<#+             {#>
            Implements <#=Globalize(KnownNamespaces.Xaml)#>.IDataTemplateExtension
<#+             }#>
<#+             if (bindUniverse.NeedsIDataTemplateExtension || ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>
            Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IDataTemplateComponent
<#+             }#>
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>
            Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IXamlBindScopeDiagnostics
<#+             }#>
<#+             if (bindUniverse.NeededForOuterScopeElement) { #>
            Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector
            Implements I<#=Model.CodeInfo.ClassName.ShortName#>_BindingsScopeConnector
<#+             }#>
            Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector
            Implements I<#=Model.CodeInfo.ClassName.ShortName#>_Bindings

            Private dataRoot As <#=bindUniverse.DataRootType#>
<#+             if (bindUniverse.NeededForOuterScopeElement) #>
<#+             { #>
<#+                 if (Model.CodeInfo.IsResourceDictionary)#>
<#+                 {#>
            Public Property RootWeakReference As Global.System.WeakReference(Of <#=Globalize(KnownNamespaces.Xaml)#>.ResourceDictionary)
<#+                 }#>
<#+                 else#>
<#+                 {#>
            Public Property RootWeakReference As Global.System.WeakReference(Of <#=Globalize(KnownNamespaces.Xaml)#>.FrameworkElement)
<#+                 }#>
<#+             } #>
            Private initialized As Boolean = False
            Private Const NOT_PHASED As Integer = 1 << 31
            Private Const DATA_CHANGED As Integer = 1 << 30
<#+             if (bindUniverse.DistinctConvertersUsed.Count() > 0) #>
<#+             {#>
            Private localResources As <#=Globalize(KnownNamespaces.Xaml)#>.ResourceDictionary
<#+                 if (!Model.CodeInfo.IsResourceDictionary)#>
<#+                 {#>
            Private converterLookupRoot As Global.System.WeakReference(Of <#=Globalize(KnownNamespaces.Xaml)#>.FrameworkElement)
<#+                 }#>
<#+             }#>
<#+             if (bindUniverse.NeedsIDataTemplateExtension) #>
<#+             { #>
            Private removedDataContextHandler As Boolean = False
<#+             } #>

            ' Fields for each control that has bindings.
<#+             foreach (ConnectionIdElement bindElement in bindUniverse.BoundElements)#>
<#+             {#>
<#+                 if (bindElement.IsWeakRef) #>
<#+                 {#>
            Private <#=bindElement.ObjectCodeName#> As Global.System.WeakReference
<#+                 }#>
<#+                 else if (!bindElement.Type.IsDerivedFromControlTemplate()) #>
<#+                 {#>
            Private <#=bindElement.ObjectCodeName#> As <#=bindElement.Type#>
<#+                 }#>
<#+                 if (bindElement.CanBeInstantiatedLater)#>
<#+                 {#>
<#+                     foreach (var bindAssignment in bindElement.BindAssignments)#>
<#+                     {#>
            Private <#=bindAssignment.ObjectDeferredAssignmentCodeName#> As <#=bindAssignment.MemberType#>
<#+                     }#>
<#+                 }#>
<#+             }#>
<#+             if (bindUniverse.UnloadableBindingSourceElements.Any()) { #>
            Private UnloadableBindingSourcesToUpdate As Global.System.Collections.Generic.Queue(Of Global.System.Action) = new Global.System.Collections.Generic.Queue(Of Global.System.Action)()
<#+             } #>
<#+             if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) { #>
            Private UnloadedElementsToUpdate As Global.System.Collections.Generic.Queue(Of Global.System.Int32)  = new Global.System.Collections.Generic.Queue(Of Global.System.Int32)()
<#+             } #>
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>

            Private bindingsTracking As <#=Model.CodeInfo.ClassName.ShortName#>_obj<#=bindUniverse.RootElement.ConnectionId#>_BindingsTracking
<#+             }#>
<#+         if (bindUniverse.ElementsWithConnectCase.Where(e => e.BoundEventAssignments.Count > 0).Count() > 0)#>
<#+             {#>

            ' Subs for each event bindings event handler.
<#+             }#>
<#+             foreach (ConnectionIdElement element in bindUniverse.ElementsWithConnectCase)#>
<#+             {#>
<#+                 foreach (BoundEventAssignment evt in element.BoundEventAssignments)#>
<#+                 {#>

            Private Sub <#=evt.EventHandlerCodeName#>(<#=evt.Parameters.Declaration()#>)
<#+                     if (!evt.PathStep.ValueType.IsDelegate())#>
<#+                     {#>
                <#=evt.PathStep.CodeGen().PathExpression#>
<#+                     }#>
<#+                     else#>
<#+                     {#>
                <#=evt.PathStep.CodeGen().PathExpression#>(<#=evt.Parameters.ForCall()#>);
<#+                     }#>
            End Sub
<#+                 }#>
<#+             }#>

            ' Static fields for each binding's enabled/disabled state
<#+                 foreach (ConnectionIdElement bindElement in bindUniverse.ElementsWithConnectCaseInLocalScope)#>
<#+                 {#>
<#+                     foreach (BindAssignment ba in bindElement.BindAssignments)#>
<#+                     {#>
            Private Shared <#=ba.DisableFlagName#> As Boolean = False
<#+                     }#>
<#+                 }#>

            Public Sub New()
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>
                Me.bindingsTracking = New <#=bindUniverse.BindingsClassName#>Tracking(Me)
<#+             }#>
            End Sub
            
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>
            Public Sub Disable(lineNumber As Integer, columnNumber As Integer) Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IXamlBindScopeDiagnostics.Disable
<#+                 bool firstIfInDisable = true; #>
<#+                 foreach (var element in bindUniverse.ElementsWithConnectCaseInLocalScope)#>
<#+                 {#>
<#+                     foreach (BindAssignment ba in element.BindAssignments)#>
<#+                     {#>
<#+                         if (firstIfInDisable)#>
<#+                         {#>
<#+                         firstIfInDisable = false; #>
                If (lineNumber = <#=ba.LineNumber#> And columnNumber = <#=ba.ColumnNumber#>) Then
<#+                         } else {#>
                ElseIf (lineNumber = <#=ba.LineNumber#> And columnNumber = <#=ba.ColumnNumber#>) Then
<#+                         }#>
                    <#=ba.DisableFlagName#> = True
<#+                     }#>
<#+                     foreach (BoundEventAssignment evt in element.BoundEventAssignments)#>
<#+                     {#>
<#+                         if (firstIfInDisable)#>
<#+                         {#>
<#+                         firstIfInDisable = false; #>
                If (lineNumber = <#=evt.LineNumber#> And columnNumber = <#=evt.ColumnNumber#>) Then
<#+                         } else {#>
                ElseIf (lineNumber = <#=evt.LineNumber#> And columnNumber = <#=evt.ColumnNumber#>) Then
<#+                         }#>
<#+                         if (element.IsWeakRef)#>
<#+                         {#>
                    If (Me.<#=element.ObjectCodeName#>.IsAlive) Then
                        RemoveHandler DirectCast(Me.<#=element.ObjectCodeName#>.Target, <#=element.Type#>).<#=evt.MemberName#>, AddressOf <#=evt.EventHandlerCodeName#>
                    End If
<#+                         } else {#>
                    RemoveHandler Me.<#=element.ObjectCodeName#>.<#=evt.MemberName#>, AddressOf <#=evt.EventHandlerCodeName#>
<#+                         }#>
<#+                     }#>
<#+                 }#>
<#+                 if (!firstIfInDisable)#>
<#+                 {#>
                End If
<#+                 }#>
            End Sub
<#+             }#>

            ' IComponentConnector

            Public Sub Connect(connectionId As Integer, target As Global.System.Object) Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector.Connect
<#+             if (!bindUniverse.ElementsWithConnectCase.Any()) #>
<#+             { #>
                Exit Sub
<#+             } #>
<#+             else #>
<#+             { #>
                Select Case connectionId
<#+             foreach (ConnectionIdElement element in bindUniverse.ElementsWithConnectCase)#>
<#+             {#>
                    Case <#=element.ConnectionId#>: ' <#=element.LineNumberAndXamlFile#>                        
<#+                 if (bindUniverse.BoundElements.Contains(element)) { #>
<#+                 Output_ApiInformationCall_Push(element.ApiInformation, Indent.ThreeTabs); #>
<#+                 if (element.IsWeakRef)#>
<#+                 {#>
                        Me.<#=element.ObjectCodeName#> = New Global.System.WeakReference(DirectCast(target, <#=element.Type#>))
<#+                 }#>
<#+                 else if (element.Type.IsDerivedFromControlTemplate()) #>
<#+                 {#>
                        Me.Update() ' Template children have been connected, initialize bindings
<#+                 }#>
<#+                 else#>
<#+                 {#>
                        Me.<#=element.ObjectCodeName#> = DirectCast(target, <#=element.Type#>)
<#+                 }#>
<#+                 if (element.IsUsedByOtherScopes) #>
<#+                 { #>
                        elementWeakRefs(connectionId) = New Global.System.WeakReference(target)
                        NotifyDependentScopes(connectionId)
<#+                 } #>
<#+                 foreach (BoundEventAssignment evt in element.BoundEventAssignments)#>
<#+                 {#>
<#+                     Output_ApiInformationCall_Push(evt.ApiInformation, Indent.ThreeTabs); #>
                        AddHandler DirectCast(target, <#=element.Type#>).<#=evt.MemberName#>, AddressOf <#=evt.EventHandlerCodeName#>
<#+                     Output_ApiInformationCall_Pop(evt.ApiInformation, Indent.ThreeTabs); #>
<#+                 }#>
<#+                 if (element.CanBeInstantiatedLater && (element.HasBindAssignments || element.HasBoundEventAssignments))#>
<#+                 {#>
<#+                     // In Connect() we update non-load assignments first, #>
<#+                     foreach (var ba in element.BindAssignments.Where(ba => !(ba is BoundLoadAssignment))) #>
<#+                     { #>
<#+                         PushIndent(Indent.TwoTabs); #>
<#+                         Output_Binding_SetValue_Non_Function_Call(ba, "Me." + ba.ObjectDeferredAssignmentCodeName.VBName(), false); #>
<#+                         PopIndent(); #>
<#+                     } #>
<#+                 }#>
<#+                 foreach (var ba in element.BindAssignments.Where(bindAssignment => bindAssignment.IsTrackingTarget)) { #>
<#+                     if (element.TwoWayBindAssignments.Any()) { #>
                        Me.bindingsTracking.RegisterTwoWayListener_<#=element.ConnectionId#>(<#=element.ReferenceExpression#>)
<#+                     }#>
<#+                 }#>
<#+                 Output_ApiInformationCall_Pop(element.ApiInformation, Indent.ThreeTabs); #>
<#+                 } #>
<#+                 if (!element.IsBindingRoot) #>
<#+                 { #>
<#+                     // Queue load assignments to be updated later, because they're not available yet. #>
<#+                     foreach (var childElem in element.Children.Intersect(bindUniverse.ElementsWithBoundLoadAssignments)) #>
<#+                     { #>
                        If Not Me.UnloadedElementsToUpdate.Contains(<#=childElem.ConnectionId#>) Then
                            Me.UnloadedElementsToUpdate.Enqueue(<#=childElem.ConnectionId#>)
                        End If
<#+                     } #>
<#+                 } #>
<#+                 if (element.CanBeInstantiatedLater && element.HasRootNamedElementStep) { #>
                        Me.UnloadableBindingSourcesToUpdate.Enqueue(new Global.System.Action(
                        Sub()
<#+                     PushIndent(Indent.FourTabs); #>
<#+                     Output_Custom_Update_Call("Me", element.RootNamedElementStep, element.RootNamedElementStep.CodeGen().PathExpression.VBName(), KnownStrings.NotPhased);#>
<#+                     PopIndent(); #>
                        End Sub
                        ))
<#+                 } #>
<#+                 if (element.TryGetValidationContextStep(out PropertyStep validationStep) && ProjectInfo.IsInputValidationEnabled && ProjectInfo.EnableDefaultValidationContextGeneration) #>
<#+                 { #>
<#+                     Output_ApiInformationCall_Push(validationStep.ApiInformation, Indent.ThreeTabs); #>
                        Dim validationControl As <#=Globalize(KnownNamespaces.XamlControls)#>.IInputValidationControl = DirectCast(target, <#=Globalize(KnownNamespaces.XamlControls)#>.IInputValidationControl)
                        validationControl.ValidationContext = New <#=Globalize(KnownNamespaces.XamlControls)#>.InputValidationContext("<#=validationStep.PropertyName #>", <#=validationStep.IsValueRequired#>)
<#+                     Output_ApiInformationCall_Pop(validationStep.ApiInformation, Indent.ThreeTabs); #>
<#+                 }#>
                        Exit Select
<#+             }#>
                    Case Else
                        Exit Select
                End Select
<#+             } #>
            End Sub
<#+         if (bindUniverse.NeededForOuterScopeElement) { #>

            ' IComponentConnector

            <#=GeneratedCodeAttribute#>
            <#=DebuggerNonUserCodeAttribute#>
            Public Function GetBindingConnector(connectionId As Integer, target As Object) As <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector.GetBindingConnector
            
                Dim returnValue As <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector = Nothing
<#+             if (bindUniverse.Children.Any()) #>
<#+             { #>
                Select Case connectionId
<#+                 foreach (BindUniverse childUniverse in bindUniverse.Children)#>
<#+                 {#>
<#+                     ConnectionIdElement element = childUniverse.RootElement;#>
<#+                     if (element.IsBindingRoot)#>
<#+                     {#>
<#+                         PushIndent(Indent.OneTab); #>
<#+                         Output_GetBindingConnectorCase(element, false); #>
<#+                         PopIndent(); #>
<#+                     }#>
<#+                 }#>
                End Select
<#+             } #>
                Return returnValue
            End Function

            Private dependentBindings As Global.System.Collections.Generic.Dictionary(Of Integer, Global.System.Collections.Generic.List(Of Global.System.WeakReference)) = New Global.System.Collections.Generic.Dictionary(Of Integer, Global.System.Collections.Generic.List(Of Global.System.WeakReference))()
            Private elementWeakRefs As Global.System.Collections.Generic.Dictionary(Of Integer, Global.System.WeakReference) = New Global.System.Collections.Generic.Dictionary(Of Integer, Global.System.WeakReference)()

            ' I<#=Model.CodeInfo.ClassName.ShortName#>_BindingsScopeConnector

            Private _parent As Global.System.WeakReference
            Property Parent() As Global.System.WeakReference Implements I<#=Model.CodeInfo.ClassName.ShortName#>_BindingsScopeConnector.Parent
                Get
                    Return _parent
                End Get
                Set(value As Global.System.WeakReference)
                    If _parent IsNot value Then
                        _parent = value
                        RegisterDependenciesOnParents()
                    End If
                End Set            
            End Property

            Public Function ContainsElement(connectionId As Integer) As Boolean Implements I<#=Model.CodeInfo.ClassName.ShortName#>_BindingsScopeConnector.ContainsElement
                Select Case connectionId
<#+             foreach (var element in bindUniverse.ElementsWithConnectCaseInLocalScope)#>
<#+             {#>
<#+                 if (element.IsUsedByOtherScopes) #>
<#+                 {#>
                    Case <#=element.ConnectionId#>
                        Return True
<#+                 }#>
<#+             }#>
                    Case Else
                        Return False
                End Select
            End Function

            Public Sub RegisterForElementConnection(connectionId As Integer, connector As <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector) Implements I<#=Model.CodeInfo.ClassName.ShortName#>_BindingsScopeConnector.RegisterForElementConnection
                Dim dependentsList As Global.System.Collections.Generic.List(Of Global.System.WeakReference) = Nothing
                If Not dependentBindings.TryGetValue(connectionId, dependentsList)
                    dependentsList = New Global.System.Collections.Generic.List(Of Global.System.WeakReference)()
                    dependentBindings.Add(connectionId, dependentsList)
                End If

                dependentsList.Add(New Global.System.WeakReference(connector))

                NotifyDependentScope(connectionId, DirectCast(connector, <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector))
            End Sub

            Private Sub NotifyDependentScopes(connectionId As Integer)
                If dependentBindings.ContainsKey(connectionId) Then
                    Dim dependentsList As Global.System.Collections.Generic.List(Of Global.System.WeakReference) = dependentBindings(connectionId)
                    For Each dependent As Global.System.WeakReference In dependentsList
                        If dependent.IsAlive Then
                            NotifyDependentScope(connectionId, DirectCast(dependent.Target, <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector))
                        End If
                    Next
                End If
            End Sub

            Private Sub NotifyDependentScope(connectionId As Integer, connector As <#=Globalize(KnownNamespaces.XamlMarkup)#>.IComponentConnector)
                If elementWeakRefs.ContainsKey(connectionId) And elementWeakRefs(connectionId).IsAlive Then
                    connector.Connect(connectionId, elementWeakRefs(connectionId).Target)
                End If
            End Sub

            Private Sub RegisterDependenciesOnParents()
                Dim currentParent As Global.System.WeakReference = _parent
                Dim unresolvedDependencies As Global.System.Collections.Generic.List(Of Integer) = New Global.System.Collections.Generic.List(Of Integer)()
<#+                 foreach (var element in bindUniverse.OuterScopeBoundElements)#>
<#+                 {#>
                unresolvedDependencies.Add(<#=element.ConnectionId#>)
<#+                 }#>

                While unresolvedDependencies.Count > 0 And Not currentParent Is Nothing And currentParent.IsAlive
                    Dim parentBindings As I<#=Model.CodeInfo.ClassName.ShortName#>_BindingsScopeConnector = DirectCast(currentParent.Target, I<#=Model.CodeInfo.ClassName.ShortName#>_BindingsScopeConnector)
                    For i As Integer= unresolvedDependencies.Count - 1 To 0 Step -1
                        Dim unresolvedDependency As Integer = unresolvedDependencies(i)
                        If parentBindings.ContainsElement(unresolvedDependency) Then
                            parentBindings.RegisterForElementConnection(unresolvedDependency, Me)
                            unresolvedDependencies.RemoveAt(i)
                        End If
                    Next

                    currentParent = parentBindings.Parent
                End While
            End Sub

<#+         } #>
<#+             if (bindUniverse.NeedsIDataTemplateExtension) #>
<#+             {#>

            Public Sub DataContextChangedHandler(sender As <#=Globalize(KnownNamespaces.Xaml)#>.FrameworkElement, args As <#=Globalize(KnownNamespaces.Xaml)#>.DataContextChangedEventArgs)
                If Me.SetDataRoot(args.NewValue) Then
                    Me.Update()
                End If
            End Sub

            ' IDataTemplateExtension

            Public Function ProcessBinding(phase As UInteger) As Boolean Implements <#=Globalize(KnownNamespaces.Xaml)#>.IDataTemplateExtension.ProcessBinding
                Throw New Global.System.NotImplementedException()
            End Function

            Public Function ProcessBindings(args As ContainerContentChangingEventArgs) As Integer Implements <#=Globalize(KnownNamespaces.Xaml)#>.IDataTemplateExtension.ProcessBindings
                Dim nextPhase As Integer = -1
                ProcessBindings(args.Item, args.ItemIndex, CInt(args.Phase), nextPhase)
                Return nextPhase
            End Function 

            Public Sub ResetTemplate() Implements <#=Globalize(KnownNamespaces.Xaml)#>.IDataTemplateExtension.ResetTemplate
                Recycle()
            End Sub

            ' IDataTemplateComponent

            Public Sub ProcessBindings(item As Global.System.Object, itemIndex As Integer, phase As Integer, ByRef nextPhase As Integer) Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IDataTemplateComponent.ProcessBindings
                nextPhase = -1
                Select Case phase
                    Case 0:
                        nextPhase = <#=bindUniverse.GetNextPhase(0)#>
                        Me.SetDataRoot(item)
                        If Not removedDataContextHandler Then
                            removedDataContextHandler = True
                            RemoveHandler <#=bindUniverse.RootElement.ReferenceExpression#>.DataContextChanged, AddressOf Me.DataContextChangedHandler
                        End If
                        Me.initialized = True
                        Exit Select
<#+                     foreach(KeyValuePair<int, List<PhaseAssignment>> kvp in bindUniverse.PhaseAssignments.Where(kvp => kvp.Key != 0).OrderBy(kvp => kvp.Key)) #>
<#+                     { #>
                    Case <#=kvp.Key#>:
<#+                         foreach(PhaseAssignment phase in kvp.Value) #>
<#+                         { #>
<#+                             if (phase.ConnectionIdElement.CanBeInstantiatedLater)#>
<#+                             {#>
                        If <#=phase.ConnectionIdElement.ReferenceExpression#> IsNot Nothing
<#+                             }#>
                        <#=Globalize(KnownNamespaces.XamlMarkup)#>.XamlBindingHelper.ResumeRendering(<#=phase.ConnectionIdElement.ReferenceExpression#>)
<#+                             if (phase.ConnectionIdElement.CanBeInstantiatedLater)#>
<#+                             {#>
                        End If
<#+                             }#>
<#+                         } #>
                        nextPhase = <#=bindUniverse.GetNextPhase(kvp.Key)#>
                        Exit Select
<#+                     } #>
                End Select
                Me.Update_(DirectCast(item, <#=bindUniverse.RootStep.ValueType#>) , 1 << phase)
            End Sub

            Public Sub Recycle() Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IDataTemplateComponent.Recycle
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>
                Me.bindingsTracking.ReleaseAllListeners()
<#+             }#>
<#+ foreach(KeyValuePair<int, List<PhaseAssignment>> kvp in bindUniverse.PhaseAssignments.Where(kvp => kvp.Key != 0).OrderBy(kvp => kvp.Key)) #>
<#+ { #>
<#+     foreach(PhaseAssignment phase in kvp.Value) #>
<#+     { #>
<#+         if (phase.ConnectionIdElement.CanBeInstantiatedLater)#>
<#+         {#>
                If <#=phase.ConnectionIdElement.ReferenceExpression#> IsNot Nothing
<#+                 PushIndent();#>
<#+         }#>
                <#=Globalize(KnownNamespaces.XamlMarkup)#>.XamlBindingHelper.SuspendRendering(<#=phase.ConnectionIdElement.ReferenceExpression#>)
<#+         if (phase.ConnectionIdElement.CanBeInstantiatedLater)#>
<#+         {#>
<#+             PopIndent();#>
                End If
<#+         }#>
<#+     } #>
<#+ } #>
            End Sub
<#+             } else if (bindUniverse.NeedsIDataTemplateComponent || ProjectInfo.ShouldGenerateDisableXBind){#>

            ' IDataTemplateComponent

            Public Sub ProcessBindings(item As Global.System.Object, itemIndex As Integer, phase As Integer, ByRef nextPhase As Integer) Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IDataTemplateComponent.ProcessBindings
                nextPhase = -1
            End Sub
            
            Public Sub Recycle() Implements <#=Globalize(KnownNamespaces.XamlMarkup)#>.IDataTemplateComponent.Recycle
                Exit Sub
            End Sub
<#+             } #>

            ' I<#=Model.CodeInfo.ClassName.ShortName#>_Bindings
            Public Sub Initialize() Implements I<#=Model.CodeInfo.ClassName.ShortName#>_Bindings.Initialize
                If Not Me.initialized Then
                    Me.Update()
                End If
            End Sub
            
            Public Sub Update() Implements I<#=Model.CodeInfo.ClassName.ShortName#>_Bindings.Update
<#+             if (bindUniverse.HasBindings)#>
<#+             {#>
                Me.Update_<#=bindUniverse.RootStep.CodeName#>(Me.dataRoot, NOT_PHASED)
<#+             }#>
                Me.initialized = True
            End Sub

            Public Sub StopTracking() Implements I<#=Model.CodeInfo.ClassName.ShortName#>_Bindings.StopTracking
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>
                Me.bindingsTracking.ReleaseAllListeners()
<#+             }#>
                Me.initialized = False
            End Sub

            Public Sub DisconnectUnloadedObject(connectionId As Integer) Implements I<#=Model.CodeInfo.ClassName.ShortName#>_Bindings.DisconnectUnloadedObject
<#+                 if(bindUniverse.ElementsWithDisconnectCase.Count() == 0) { #>
                Throw New Global.System.ArgumentException("No unloadable elements to disconnect.")
<#+                 } else { #>
                Select Case connectionId
<#+                     foreach (var element in bindUniverse.ElementsWithDisconnectCase)#>
<#+                     {#>
                    Case <#=element.ConnectionId#>: ' <#=element.LineNumberAndXamlFile#>
<#+                         if (bindUniverse.BoundElements.Contains(element)) { #>
<#+                         Output_ApiInformationCall_Push(element.ApiInformation, Indent.OneTab); #>
                        If (Me.<#=element.ObjectCodeName#> IsNot Nothing) Then
<#+                         foreach (BindAssignment bindAssignment in element.BindAssignments.Where(ba => ba.HasDeferredValueProxy))#>
<#+                         {#>
                            Me.<#=bindAssignment.ObjectDeferredAssignmentCodeName#> = <#=element.GetMemberGetExpression(bindAssignment)#>
<#+                         }#>
                            Me.<#=element.ObjectCodeName#> = Nothing
                        End If
<#+                         foreach (var childElem in element.Children.Where(c => bindUniverse.ElementsWithDisconnectCase.Contains(c))) #>
<#+                         {#>
                        Me.DisconnectUnloadedObject(<#=childElem.ConnectionId#>)
<#+                         }#>
<#+                         Output_ApiInformationCall_Pop(element.ApiInformation, Indent.OneTab); #>
<#+                         } #>
<#+                         if (element.HasRootNamedElementStep) { #>
                        Me.UnloadableBindingSourcesToUpdate.Enqueue(new Global.System.Action(
                        Sub()
<#+                             PushIndent(Indent.FourTabs); #>
<#+                             Output_Custom_Update_Call("Me", element.RootNamedElementStep, "Nothing", KnownStrings.NotPhased);#>
<#+                             PopIndent(); #>
                        End Sub
                        ))
<#+                         } #>
                        Exit Select
<#+                     }#>
                    Case Else
                        Throw New Global.System.ArgumentException("Invalid connectionId.")
                End Select
<#+                 }#>
            End Sub
<#+         if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) #>
<#+         { #>

            Private Sub UpdateUnloadedElement(connectionId as Integer)
                Select Case connectionId
<#+             foreach (var element in bindUniverse.ElementsWithBoundLoadAssignments)#>
<#+             {#>
                    Case <#=element.ConnectionId#>: ' <#=element.LineNumberAndXamlFile#>
<#+                 Output_ApiInformationCall_Push(element.ApiInformation, Indent.OneTab); #>
<#+                 // The union below is so that BoundLoadAssignments are generated first #>
<#+                 foreach (var ba in element.BindAssignments.OfType<BoundLoadAssignment>()) #>
<#+                 { #>
<#+                     PushIndent(Indent.TwoTabs); #>
<#+                     Output_Binding_SetValue_Non_Function_Call(ba, "Me." + ba.ObjectDeferredAssignmentCodeName.VBName(), false); #>
<#+                     PopIndent(); #>
<#+                 } #>
<#+                 Output_ApiInformationCall_Pop(element.ApiInformation, Indent.OneTab); #>
                        Exit Select
<#+             }#>
                    Case Else
                        Throw New Global.System.ArgumentException("Invalid connectionId.")
                End Select
            End Sub
<#+         }#>

            Public Function SetDataRoot(newDataRoot As Global.System.Object)
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>
                Me.bindingsTracking.ReleaseAllListeners()
<#+             }#>
                If Not newDataRoot Is Nothing Then
                    Me.dataRoot = DirectCast(newDataRoot, <#=bindUniverse.DataRootType#>)
                    Return True
                End If
                Return False
            End Function
<#+             if (bindUniverse.RootElement.IsBindingFileRoot)#>
<#+             {#>

            Public Sub Loading(src As <#=Globalize(KnownNamespaces.Xaml)#>.FrameworkElement, data As object)
                Me.Initialize()
            End Sub
<#+             }#>
<#+             if (bindUniverse.DistinctConvertersUsed.Count() > 0) #>
<#+             {#>

<#+                 if (Model.CodeInfo.IsResourceDictionary)#>
<#+                 {#>
            Public Sub SetConverterLookupRoot(resources As <#=Globalize(KnownNamespaces.Xaml)#>.ResourceDictionary)
                Me.localResources = resources
            End Sub
<#+             }#>
<#+             else#>
<#+             {#>
            Public Sub SetConverterLookupRoot(rootElement As <#=Globalize(KnownNamespaces.Xaml)#>.FrameworkElement)
                Me.converterLookupRoot = New Global.System.WeakReference(Of <#=Globalize(KnownNamespaces.Xaml)#>.FrameworkElement)(rootElement)
            End Sub
<#+             }#>

            Public Function LookupConverter(key As string) As <#=Globalize(KnownNamespaces.XamlData)#>.IValueConverter
<#+             if (!Model.CodeInfo.IsResourceDictionary)#>
<#+             {#>
                If (Me.localResources Is Nothing)
                    Dim rootElement As <#=Globalize(KnownNamespaces.Xaml)#>.FrameworkElement = Nothing
                    Me.converterLookupRoot.TryGetTarget(rootElement)
                    Me.localResources = rootElement.Resources
                    Me.converterLookupRoot = Nothing
                End If
<#+             }#>
                Return DirectCast( If( Me.localResources.ContainsKey(key), Me.localResources(key), <#=Globalize(KnownNamespaces.Xaml)#>.Application.Current.Resources(key)), <#=Globalize(KnownNamespaces.XamlData)#>.IValueConverter)
            End Function
<#+             }#>
<#+             if (bindUniverse.HasBindings)#>
<#+             {#>
<#+                 if (bindUniverse.HasFunctionBindings)#>
<#+                 {#>
<#+                     Output_TryGetValueFunctions(bindUniverse);#>
<#+                     Output_FunctionBindings(bindUniverse);#>
<#+                 }#>
<#+                 if (bindUniverse.NeedsCompleteUpdate)#>
<#+                 {#>
<#+                     Output_CompleteUpdate(bindUniverse);#>
<#+                 }#>

            ' Update methods for each path node used in binding steps.
<#+             }#>
<#+             foreach (BindPathStep bindStep in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.IsIncludedInUpdate == true))#>
<#+             {#>
            Private Sub Update_<#=bindStep.CodeName#>(<#=GetUpdateParams(bindStep)#>)
<#+                 if (bindStep.UpdateNeedsBindingsVariable || (bindStep is RootStep && bindUniverse.ElementRootStep != null)) { #>
                Dim bindings As <#=bindUniverse.BindingsClassName#> = Me
<#+                 }#>
<#+                 if (bindStep.RequiresChildNotification && (bindStep is PropertyStep || bindStep is CastStep || bindStep is RootStep || bindStep is RootNamedElementStep || bindStep is ArrayIndexStep || bindStep is MapIndexStep))#>
<#+                 {#>
                Me.bindingsTracking.UpdateChildListeners_<#=bindStep.CodeName#>(obj)
<#+                 }#>
<#+                 Output_Update_Steps(bindStep.ValueType.IsNullable, "Me", bindStep.Children, true, "phase");#>
<#+                 Output_Update_Steps(bindStep.ValueType.IsNullable, "Me", bindStep.Dependents, false, "phase");#>
<#+                 foreach (int distinctPhase in bindStep.DistinctPhases)#>
<#+                 {#>
<#+                     Output_Binding_Phased_SetValue(distinctPhase, true, bindStep, false);#>
<#+                     Output_Binding_Phased_SetValue(distinctPhase, false, bindStep, false);#>
<#+                 }#>
<#+                 if (bindStep is RootStep) { #>
<#+                     Output_Update_Steps(false, "Me", bindUniverse.BindPathSteps.Values.Where(s => s.Parent is StaticRootStep), false, "phase");#>
<#+                     if (bindUniverse.ElementRootStep != null) #>
<#+                     { #>
<#+                         Output_Update_Steps(false, "Me", bindUniverse.BindPathSteps.Values.Where(s => s.Parent == bindUniverse.ElementRootStep), false, "phase");#>
<#+                     } #>
<#+                     if (bindUniverse.NeedsCompleteUpdate) { #>
                Me.CompleteUpdate(phase)
<#+                     }#>
<#+                 }#>
            End Sub
<#+             }#>
<#+             // UpdateFallback generators #>
<#+             foreach (BindPathStep bindStep in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.IsIncludedInUpdate == true))#>
<#+             {#>
<#+                 if (bindStep.Parent != null && bindStep.BindStatus.HasFlag(BindStatus.HasFallbackValue))#>
<#+                 {#>

            Private Sub UpdateFallback_<#=bindStep.CodeName#>(phase As Integer)
<#+                     foreach (BindPathStep childStep in bindStep.Children.Concat(bindStep.Dependents))#>
<#+                     {#>
<#+                         if (childStep.BindStatus.HasFlag(BindStatus.HasFallbackValue))#>
<#+                         {#>
                Me.UpdateFallback_<#=childStep.CodeName#>(phase)
<#+                         }#>
<#+                     }#>
<#+                     foreach (int distinctPhase in bindStep.DistinctPhases) #>
<#+                     {#>
<#+                         Output_Binding_Phased_Fallback_SetValue(distinctPhase, true, bindStep);#>
<#+                         Output_Binding_Phased_Fallback_SetValue(distinctPhase, false, bindStep);#>
<#+                     }#>
            End Sub
<#+                 }#>
<#+             }#>
<#+             // UpdateTwoWay generators #>
<#+             foreach (var ba in bindUniverse.BindAssignments.Where(ba => ba.IsTrackingTarget)) { #>
<#+                 Output_UpdateTwoWay(ba); #>
<#+             } #>
<#+ if (ProjectInfo.IsInputValidationEnabled) {#>
<#+             Output_UpdateErrors(bindUniverse); #>
<#+ } #>
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>

            <#=GeneratedCodeAttribute#>
            <#=DebuggerNonUserCodeAttribute#>
            Private Class <#=bindUniverse.BindingsClassName#>Tracking
                Private weakRefToBindingObj As Global.System.WeakReference(Of <#=bindUniverse.BindingsClassName#>) = Nothing

                Public Sub New(obj As <#=bindUniverse.BindingsClassName#>)
                    weakRefToBindingObj = New Global.System.WeakReference(Of <#=bindUniverse.BindingsClassName#>)(obj)
                End Sub

                Private Function TryGetBindingObject() As <#=bindUniverse.BindingsClassName#>
                    Dim bindingObject As <#=bindUniverse.BindingsClassName#> = Nothing
                    if weakRefToBindingObj IsNot Nothing Then
                        weakRefToBindingObj.TryGetTarget(bindingObject)
                        If bindingObject Is Nothing Then
                            weakRefToBindingObj = Nothing
                            ReleaseAllListeners()
                        End If
                    End If
                    return bindingObject
                End Function

                Public Sub ReleaseAllListeners()
<#+                 foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.NeedsUpdateChildListeners))#>
<#+                 {#>
<#+                     Output_ApiInformationCall_Push(step.ApiInformation, Indent.TwoTabs); #>
                    UpdateChildListeners_<#=step.CodeName#>(Nothing)
<#+                     Output_ApiInformationCall_Pop(step.ApiInformation, Indent.TwoTabs); #>
<#+                 }#>
                End Sub

<#+                 foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.IsIncludedInUpdate == true))#>
<#+                 {#>
<#+                     if (step.IsTrackingSource && step.ImplementsINPC && (step is PropertyStep || step is CastStep || step is RootStep || step is RootNamedElementStep || step is ArrayIndexStep || step is MapIndexStep))#>
<#+                     {#>
                Public Sub PropertyChanged_<#=step.CodeName#>(sender As object, e As <#=PropertyChangedEventArgName(step)#>)
                    Dim bindings As <#=bindUniverse.BindingsClassName#> = TryGetBindingObject()
                    If bindings IsNot Nothing Then
                        Dim propName As String = e.PropertyName
                        Dim obj As <#=step.ValueType#> = TryCast(sender, <#=step.ValueType#>)
                        If Global.System.String.IsNullOrEmpty(propName) Then
<#+                         PushIndent(Indent.ThreeTabs);#>
<#+                         Output_Update_Steps(step.ValueType.IsNullable, "bindings",step.TrackingSteps, false, "DATA_CHANGED");#>
<#+                         PopIndent();#>
                        Else
                            Select Case propName
<#+                         foreach (string propertyName in step.TrackingSteps.OfType<PropertyStep>().Select(p => p.PropertyName).Distinct())#>
<#+                         {#>
                                Case "<#=propertyName#>":
<#+                                 PushIndent(Indent.SevenTabs);#>
<#+                                 foreach (var child in step.TrackingSteps.OfType<PropertyStep>().Where(p => p.PropertyName == propertyName)) { #>
<#+                                     Output_Update_DataChanged_Step("bindings", child);#>
<#+                                 } #>
<#+                                 PopIndent();#>
                                    Exit Select
<#+                         }#>
<#+                         foreach (string functionName in step.TrackingSteps.OfType<FunctionStep>().Select(p => p.Method.MethodName).Distinct())#>
<#+                         {#>
                                Case "<#=functionName#>":
<#+                                 PushIndent(Indent.FiveTabs);#>
<#+                                 Output_Update_Steps(step.ValueType.IsNullable, "bindings", step.TrackingSteps.OfType<FunctionStep>().Where(p => p.Method.MethodName == functionName), false, "DATA_CHANGED");#>
<#+                                 PopIndent();#>
                                    Exit Select
<#+                         }#>
                                Case Else
                                    Exit Select
                            End Select
                        End If
<#+                         if (bindUniverse.NeedsCompleteUpdate) { #>
                        bindings.CompleteUpdate(DATA_CHANGED)
<#+                         }#>
                    End If
                End Sub
<#+                     }#>
<#+                     if (step.IsTrackingSource && (step is PropertyStep || step is CastStep || step is RootStep || step is RootNamedElementStep) && step.ImplementsINCC && !step.ImplementsIObservableVector && !step.ImplementsIObservableMap)#>
<#+                     {#>
                Public Sub CollectionChanged_<#=step.CodeName#>(sender As object, e As <#=NotifyCollectionChangedEventArgName(step)#>)
                    Dim bindings As <#=bindUniverse.BindingsClassName#> = TryGetBindingObject()
                    If bindings IsNot Nothing Then
                        Dim obj As <#=step.ValueType#> = TryCast(sender, <#=step.ValueType#>)
<#+                     Output_Update_Steps(step.ValueType.IsNullable, "bindings", step.TrackingSteps, false, "DATA_CHANGED");#>
<#+                     if (bindUniverse.NeedsCompleteUpdate) { #>
                        bindings.CompleteUpdate(DATA_CHANGED)
<#+                     }#>
                    End If
                End Sub
<#+                     }#>

<#+                     if (step.IsTrackingSource && (step is PropertyStep || step is CastStep || step is RootStep) && step.ImplementsIObservableVector)#>
<#+                     {#>
                Public Sub VectorChanged_<#=step.CodeName#>(sender As Global.Windows.Foundation.Collections.IObservableVector(Of <#=step.ValueType.ItemType#>), e As Global.Windows.Foundation.Collections.IVectorChangedEventArgs)
                    Dim bindings As <#=bindUniverse.BindingsClassName#> = Nothing
                    If bindings IsNot Nothing Then
                        Dim obj As <#=step.ValueType#> = TryCast(sender, <#=step.ValueType#>)
<#+                         Output_Update_Steps(step.ValueType.IsNullable, "bindings", step.TrackingSteps, false, "DATA_CHANGED");#>
<#+                         if (bindUniverse.NeedsCompleteUpdate) { #>
                        bindings.CompleteUpdate(DATA_CHANGED)
<#+                         }#>
                    End If
                End Sub
<#+                     }#>

<#+                     if (step.IsTrackingSource && (step is PropertyStep || step is CastStep || step is RootStep) && step.ImplementsIObservableMap)#>
<#+                     {#>
                Public Sub MapChanged_<#=step.CodeName#>(sender As Global.Windows.Foundation.Collections.IObservableMap(Of String, <#=step.ValueType.ItemType#>), e As Global.Windows.Foundation.Collections.IMapChangedEventArgs(Of String))
                    Dim bindings As <#=bindUniverse.BindingsClassName#> = TryGetBindingObject()
                    If bindings IsNot Nothing Then
                        Dim obj As <#=step.ValueType#> = TryCast(sender, <#=step.ValueType#>)
<#+                         Output_Update_Steps(step.ValueType.IsNullable, "bindings", step.TrackingSteps, false, "DATA_CHANGED");#>
<#+                         if (bindUniverse.NeedsCompleteUpdate) { #>
                        bindings.CompleteUpdate(DATA_CHANGED)
<#+                         }#>
                    End If
                End Sub
<#+                     }#>

<#+                     foreach (DependencyPropertyStep child in step.TrackingSteps.OfType<DependencyPropertyStep>())#>
<#+                     {#>
                Public Sub DependencyPropertyChanged_<#=child.CodeName#>(sender As <#=Globalize(KnownNamespaces.Xaml)#>.DependencyObject, prop As <#=Globalize(KnownNamespaces.Xaml)#>.DependencyProperty)
                    Dim bindings As <#=bindUniverse.BindingsClassName#> = TryGetBindingObject()
                    If bindings IsNot Nothing Then
                        Dim obj As <#=step.ValueType#> = TryCast(sender, <#=step.ValueType#>)
<#+                         PushIndent(Indent.FourTabs);#>
<#+                         Output_Update_DataChanged_Step("bindings", child);#>
<#+                         PopIndent();#>
<#+                         if (bindUniverse.NeedsCompleteUpdate) { #>
                        bindings.CompleteUpdate(DATA_CHANGED)
<#+                         }#>
                    End If
                End Sub
<#+                     }#>
<#+                     if (step.IsTrackingSource && step.ImplementsINDEI && ProjectInfo.IsInputValidationEnabled)#>
<#+                     {#>
                Public Sub ErrorsChanged_<#=step.CodeName#>(sender As Global.System.Object, e As <#= DataErrorsEventArgName(step)#>)
                    Dim bindings As <#=bindUniverse.BindingsClassName#> = TryGetBindingObject()
                    If bindings IsNot Nothing Then
                        Dim propName As String = e.PropertyName
                        If (Global.System.String.IsNullOrEmpty(propName)) Then
<#+                 foreach (var propertyStep in step.TrackingSteps.OfType<PropertyStep>())#>
<#+                 {#>
<#+                         Output_ApiInformationCall_Push(propertyStep.ApiInformation, Indent.FourTabs);#>
                            bindings.UpdateErrors_<#=step.CodeName#>(sender, "<#= propertyStep.PropertyName #>")
<#+                         Output_ApiInformationCall_Pop(propertyStep.ApiInformation, Indent.FourTabs);#>
<#+                 }#>
                        Else
<#+                         Output_ApiInformationCall_Push(step.ApiInformation, Indent.FourTabs);#>
                            bindings.UpdateErrors_<#=step.CodeName#>(sender, propName)
<#+                         Output_ApiInformationCall_Pop(step.ApiInformation, Indent.FourTabs);#>
                        End If
                    End If
                End Sub
<#+                      }#>
<#+                     // Register & unregister change notification generators #>
<#+                     Output_UpdateChildListeners(step, bindUniverse);#>
<#+                 }#>
<#+                 foreach (var e in bindUniverse.BoundElements.Where(e => e.TwoWayBindAssignments.Any())) { #>
<#+                     PushIndent(Indent.TwoTabs); #>
<#+                     Output_RegisterTwoWayListeners(e); #>
<#+                     PopIndent(); #>
<#+                 } #>
<#+ //End of _BindingsTracking class #>
            End Class
<#+             }#>
<#+ //End of bindings class #>
        End Class
<#+         }#>
<#+     }#>

<#+     private void Output_UpdateChildListeners(BindPathStep step, BindUniverse bindUniverse)#>
<#+     {#>
<#+         if (step.NeedsUpdateChildListeners)#>
<#+         {#>
<#+             string cacheName = "bindings.dataRoot"; #>
<#+                     if (!(step is RootStep))#>
<#+                     {#>
                Private cache_<#=step.CodeName#> As <#=step.ValueType#> = Nothing
<#+                 cacheName="cache_" +step.CodeName;#>
<#+                     }#>
<#+                     foreach (DependencyPropertyStep child in step.TrackingSteps.OfType<DependencyPropertyStep>())#>
<#+                     {#>
                Private tokenDPC_<#=child.CodeName#> As Long = 0
<#+                     }#>
<#+                     if (step.RequiresChildNotification)#>
<#+                     {#>
                Public Sub UpdateChildListeners_<#=step.CodeName#>(obj As <#=step.ValueType#>)
<#+                 if (!(step is RootStep))#>
<#+                 {#>
                    If obj IsNot <#=cacheName#> Then
                        If <#=cacheName#> IsNot Nothing Then
<#+                 }#>
<#+                 else#>
<#+                 {#>
                    Dim bindings As <#=bindUniverse.BindingsClassName#> = TryGetBindingObject()
                    If bindings IsNot Nothing Then
                        If <#=cacheName#> IsNot Nothing Then
<#+                 }#>
<#+                         if (step.ImplementsINPC)#>
<#+                         {#>
                            RemoveHandler DirectCast(<#=cacheName#>,<#=INPCInterfaceName(step)#>).PropertyChanged, AddressOf PropertyChanged_<#=step.CodeName#>
<#+                         }#>
<#+                         if (step.ImplementsINDEI && ProjectInfo.IsInputValidationEnabled)#>
<#+                         {#>
                            RemoveHandler DirectCast(<#=cacheName#>,<#=INDEIInterfaceName(step)#>).ErrorsChanged, AddressOf ErrorsChanged_<#=step.CodeName#>
<#+                         }#>
<#+                         if (step.ImplementsIObservableVector)#>
<#+                         {#>
                            RemoveHandler DirectCast(<#=cacheName#>, Global.Windows.Foundation.Collections.IObservableVector(Of <#=step.ValueType.ItemType#>)).VectorChanged, AddressOf VectorChanged_<#=step.CodeName#>
<#+                         }#>
<#+                         if (step.ImplementsIObservableMap)#>
<#+                         {#>
                            RemoveHandler DirectCast(<#=cacheName#>, Global.Windows.Foundation.Collections.IObservablemap(Of String, <#=step.ValueType.ItemType#>)).MapChanged, AddressOf MapChanged_<#=step.CodeName#>
<#+                         }#>
<#+                         else if (step.ImplementsINCC)#>
<#+                         {#>
                            RemoveHandler DirectCast(<#=cacheName#>, <#=INCCInterfaceName(step)#>).CollectionChanged, AddressOf CollectionChanged_<#=step.CodeName#>
<#+                         }#>
<#+                         foreach (DependencyPropertyStep child in step.TrackingSteps.OfType<DependencyPropertyStep>())#>
<#+                         {#>
                            <#=cacheName#>.UnregisterPropertyChangedCallback(<#=child.OwnerType#>.<#=child.PropertyName#>Property, tokenDPC_<#=child.CodeName#>)
<#+                         }#>
<#+                     if (!(step is RootStep))#>
<#+                     {#>
                            <#=cacheName#> = Nothing
<#+                     }#>
                        End If
                        If obj IsNot Nothing Then
                            <#=cacheName#> = obj
<#+                     if (step.ImplementsINPC)#>
<#+                     {#>
                            AddHandler DirectCast(obj, <#=INPCInterfaceName(step)#>).PropertyChanged, AddressOf PropertyChanged_<#=step.CodeName#>
<#+                     }#>
<#+                     if (step.ImplementsINDEI && ProjectInfo.IsInputValidationEnabled)#>
<#+                     {#>
                            AddHandler DirectCast(<#=cacheName#>, <#=INDEIInterfaceName(step)#>).ErrorsChanged, AddressOf ErrorsChanged_<#=step.CodeName#>
<#+                     }#>
<#+                     if (step.ImplementsIObservableVector)#>
<#+                     {#>
                            AddHandler DirectCast(obj, Global.Windows.Foundation.Collections.IObservableVector(Of <#=step.ValueType.ItemType#>)).VectorChanged, AddressOf VectorChanged_<#=step.CodeName#>
<#+                     }#>
<#+                     if (step.ImplementsIObservableMap)#>
<#+                     {#>
                            AddHandler DirectCast(obj, Global.Windows.Foundation.Collections.IObservableMap(Of String, <#=step.ValueType.ItemType#>)).MapChanged, AddressOf MapChanged_<#=step.CodeName#>
<#+                     }#>
<#+                     else if (step.ImplementsINCC)#>
<#+                     {#>
                            AddHandler DirectCast(obj, Global.System.Collections.Specialized.INotifyCollectionChanged).CollectionChanged, AddressOf CollectionChanged_<#=step.CodeName#>
<#+                     }#>
<#+                     foreach (DependencyPropertyStep child in step.TrackingSteps.OfType<DependencyPropertyStep>())#>
<#+                     {#>
                            tokenDPC_<#=child.CodeName#> = obj.RegisterPropertyChangedCallback(<#=child.OwnerType#>.<#=child.PropertyName#>Property, AddressOf DependencyPropertyChanged_<#=child.CodeName#>)
<#+                     }#>
                        End If
                    End If
                End Sub
<#+             }#>
<#+         }#>
<#+     }#>

<#+ private void Output_RegisterTwoWayListeners(ConnectionIdElement element)#>
<#+ {#>
        Public Sub RegisterTwoWayListener_<#=element.ConnectionId#>(sourceObject as <#=element.Type#>)
<#+     foreach (var ba in element.TwoWayBindAssignments) { #>
<#+         Output_ApiInformationCall_Push(ba.ApiInformation, Indent.None); #>
<#+         if (ba.NeedsLostFocusForTwoWay) { #>
            AddHandler sourceObject.LostFocus, Sub(sender, e)
<#+         } else { #>
            sourceObject.RegisterPropertyChangedCallback(<#=ba.MemberDeclaringType#>.<#=ba.MemberName#>Property, Sub(sender, prop)
<#+         }#>
                Dim bindingObj As <#=ba.BindUniverse.BindingsClassName#> = Me.TryGetBindingObject()
                If bindingObj IsNot Nothing Then
                    bindingObj.UpdateTwoWay_<#=element.ConnectionId#>_<#=ba.MemberName#>()
                End If
            End Sub<#=ba.NeedsLostFocusForTwoWay ? "" : ")" #>
<#+         Output_ApiInformationCall_Pop(ba.ApiInformation, Indent.None); #>
<#+     } #>
        End Sub
<#+ } #>

<#+ private void Output_UpdateTwoWay(BindAssignment ba)#>
<#+ {#>
            Private Sub UpdateTwoWay_<#=ba.ConnectionIdElement.ConnectionId#>_<#=ba.MemberName#>()
                If Me.initialized Then
<#+         MethodStep bindBackStep = ba.BindBackStep as MethodStep; #>
<#+         if (bindBackStep != null)#>
<#+         {#>
<#+             var param = bindBackStep.Parameters[0]; #>
                    Dim <#=param.Name#> As <#=ba.MemberType#> = <#=ba.ReverseAssignmentExpression#>
<#+                 Output_NullCheckedAssignment(bindBackStep, null);#>
<#+         }#>
<#+         else#>
<#+         {#>
<#+                 Output_NullCheckedAssignment(ba.PathStep, ba.ReverseAssignmentExpression);#>
<#+         }#>
                End If
            End Sub
<#+ } #>

<#+ void  Output_NullCheckedAssignment(BindPathStep step, LanguageSpecificString value) #>
<#+ { #>
<#+     PushIndent(Indent.TwoTabs);#>
<#+     foreach (var parent in step.Parents.Where(parent => parent.NeedsCheckForNull)) { #>
            If <#=parent.CodeGen().PathExpression#> IsNot Nothing Then
<#+         PushIndent(); #>
<#+     } #>
<#+     if (value != null) { #>
            <#=step.CodeGen().PathSetExpression(value)#>
<#+     } else { #>
            <#=step.CodeGen().PathExpression#>
<#+     } #>
<#+     foreach (var parent in step.Parents.Where(parent => parent.NeedsCheckForNull)) { #>
<#+         PopIndent(); #>
            End If
<#+     } #>
<#+     PopIndent();#>
<#+ } #>

<#+ void Output_UpdateErrors(BindUniverse bindUniverse) #>
<#+ { #>
<#+     PushIndent(Indent.TwoTabs);#>
<#+     var twoWayWithIndeiSteps =  bindUniverse.INDEIPathSteps; #>
<#+     if (twoWayWithIndeiSteps.Any(step => step.ValueType.ImplementsXamlINotifyDataErrorInfo())) { #>
    Private Sub UpdateErrors_(control As <#=Globalize(KnownNamespaces.XamlControls)#>.Control, sender As <#=Globalize(KnownNamespaces.XamlData)#>.INotifyDataErrorInfo, propertyName As Global.System.String)
        If sender IsNot Nothing Then
            UpdateInputValidationErrors(control, sender.GetErrors(propertyName))
        End If
    End Sub
<#+     }#> 
<#+     if (twoWayWithIndeiSteps.Any(step => step.ImplementsINDEI && !step.ValueType.ImplementsXamlINotifyDataErrorInfo())) { #>
    Private Sub UpdateErrors_(control As <#=Globalize(KnownNamespaces.XamlControls)#>.Control, sender As Global.System.ComponentModel.INotifyDataErrorInfo, propertyName As Global.System.String)
        If sender IsNot Nothing Then
            UpdateInputValidationErrors(control, sender.GetErrors(propertyName))
        End If
    End Sub
<#+     }#>
<#+     if (twoWayWithIndeiSteps.Any()) { #>

    Private Sub UpdateInputValidationErrors(control As <#=Globalize(KnownNamespaces.XamlControls)#>.Control, modelErrors As Global.System.Collections.IEnumerable)
        Dim validationControl As <#=Globalize(KnownNamespaces.XamlControls)#>.IInputValidationControl = TryCast(control, <#=Globalize(KnownNamespaces.XamlControls)#>.IInputValidationControl)
        If validationControl IsNot Nothing Then
            Dim inputValidationErrors As Global.Windows.Foundation.Collections.IObservableVector(Of <#=Globalize(KnownNamespaces.XamlControls)#>.InputValidationError) = validationControl.ValidationErrors
            inputValidationErrors.Clear()

            For Each modelError As Global.System.Object In modelErrors
                Dim validationError As <#=Globalize(KnownNamespaces.XamlControls)#>.InputValidationError = TryCast(modelError, <#=Globalize(KnownNamespaces.XamlControls)#>.InputValidationError)
                If validationError Is Nothing Then
                    validationError = New <#=Globalize(KnownNamespaces.XamlControls)#>.InputValidationError(modelError.ToString())
                End If
                inputValidationErrors.Add(validationError)
            Next
        End If
    End Sub
<#+ } #>

<#+     foreach (BindPathStep step in twoWayWithIndeiSteps)#>
<#+     {#>
    Private Sub UpdateErrors_<#=step.CodeName#>(sender As <#=INDEIInterfaceName(step)#>, propertyName As Global.System.String)
        If Me.initialized Then
            Select Case propertyName
<#+         foreach (string propertyName in step.TrackingSteps.OfType<PropertyStep>().Select(p => p.PropertyName).Distinct())#>
<#+         {#>
                Case "<#=propertyName#>"
<#+                 PushIndent(Indent.ThreeTabs);#>
<#+                 foreach (var child in step.TrackingSteps.OfType<PropertyStep>().Where(p => p.PropertyName == propertyName)) { #>
<#+                     Output_UpdateErrorsCall(child);#>
<#+                 } #>
<#+                 PopIndent();#>
                    Exit Select
<#+         }#>
                Case Else
                    Return
                End Select
        End If
    End Sub

<#+     } #>
<#+     PopIndent();#>
<#+ } #>
<#+ void Output_UpdateErrorsCall(PropertyStep step) #>
<#+ { #>
<#+  foreach (var ba in step.AssociatedBindAssignments.Where(ba => ba.IsTrackingTarget)) {#>
        UpdateErrors_(<#=(ba as BindAssignmentBase).ConnectionIdElement.ObjectCodeName #>, sender, "<#= step.PropertyName #>")
<#+  }#>
<#+  }#>

<#+     private void Output_Binding_SetValue_Function(BindAssignment ba)#>
<#+     {#>
<#+         if (ba.MemberType.IsNullable)#>
<#+         {#>
            Public Shared Sub Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(obj As <#=ba.MemberTargetType#>, value As <#=ba.MemberType#>, targetNullValue As String)
                If value Is Nothing AndAlso targetNullValue IsNot Nothing Then
<#+             if (ba.MemberType.IsString())#>
<#+             {#>
                    value = targetNullValue
<#+             }#>
<#+             else#>
<#+             {#>
                    value = <#=ba.MemberType.GetStringToThing("targetNullValue")#>
<#+             }#>
                End If
<#+         }#>
<#+         else#>
<#+         {#>
            Public Shared Sub Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(obj As <#=ba.MemberTargetType#>, value As <#=ba.MemberType#>)
<#+         }#>
<#+         if (ba.IsAttachable)#>
<#+         {#>
                <#=ba.MemberDeclaringType#>.Set<#=ba.MemberName#>(obj, value)
<#+         }#>
<#+         else if (ba.MemberType.IsString())#>
<#+         {#>
<#+                 // We cannot pass null .Net types to WinRT, so we decided to "fix" them to match what CX does. #>
                obj.<#=ba.MemberName#> = If (value, Global.System.String.Empty)
<#+         }#>
<#+         else#>
<#+         {#>
                obj.<#=ba.MemberName#> = value
<#+         }#>
            End Sub
<#+     }#>

<#+ private void Output_Binding_Phased_SetValue(int phase, bool isTracking, BindPathStep bindStep, bool isFunctionResult)#>
<#+ {#>
<#+     var matchingBindAssignments = from ba in bindStep.BindAssignments where ba.ComputedPhase == phase && ba.IsTrackingSource == isTracking select ba;#>
<#+     if (matchingBindAssignments.Count() > 0)#>
<#+     {#>
<#+         string condition = GetDirectPhaseCondition(phase, isTracking); #>
                If <#=condition#> Then
<#+         PushIndent();#>
<#+         foreach (BindAssignment bindAssignment in matchingBindAssignments)#>
<#+         {#>
<#+             Output_Binding_SetValue(bindAssignment, isFunctionResult);#>
<#+         }#>
<#+         PopIndent();#>
                End If
<#+     }#>
<#+ }#>

<#+ private void Output_Binding_Phased_Fallback_SetValue(int phase, bool isTracking, BindPathStep bindStep)#>
<#+ {#>
<#+     var matchingBindAssignments = from ba in bindStep.BindAssignments where ba.ComputedPhase == phase && ba.IsTrackingSource == isTracking && ba.BindStatus.HasFlag(BindStatus.HasFallbackValue) select ba;#>
<#+     if (matchingBindAssignments.Count() > 0)#>
<#+     {#>
<#+         string condition =  GetDirectPhaseCondition(phase, isTracking); #>
                If <#=condition#> Then
<#+         PushIndent();#>
<#+         foreach (BindAssignment bindAssignment in matchingBindAssignments)#>
<#+         {#>
<#+             Output_Binding_SetValue_Non_Function_Call(bindAssignment, bindAssignment.FallbackValueExpression.VBName(), true);#>
<#+         }#>
<#+         PopIndent();#>
                End If
<#+     }#>
<#+ }#>

<#+     private void Output_Binding_SetValue(BindAssignment bindAssignment, bool isFunctionResult)#>
<#+     {#>
<#+         if (bindAssignment.PathStep is FunctionStep && !isFunctionResult)#>
<#+         {#>
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>
                If <#=bindAssignment.DisableFlagName#> = False Then
<#+                 PushIndent();#>
<#+             }#>
                Me.PendingFunctionBindings("<#=bindAssignment.PathStep.CodeName#>") = New InvokeFunctionDelegate(AddressOf Me.Invoke_<#=bindAssignment.PathStep.CodeName#>)
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>
<#+                 PopIndent();#>
                End If
<#+             }#>
<#+         }#>
<#+         else#>
<#+         {#>
<#+             string value = bindAssignment.DirectAssignmentExpression(isFunctionResult ? "result" : "obj").VBName();#>
<#+             Output_Binding_SetValue_Non_Function_Call(bindAssignment, value, true);#>
<#+         }#>
<#+     }#>

<#+     private void Output_Binding_SetValue_Non_Function_Call(BindAssignment bindAssignment, string value, bool includeDeferredSet)#>
<#+     {#>
<#+         ConnectionIdElement element = bindAssignment.ConnectionIdElement;#>
<#+         string objRef = element.ReferenceExpression.VBName();#>
<#+         if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+         {#>
                If <#=bindAssignment.DisableFlagName#> = False Then
<#+             PushIndent();#>
<#+         }#>
<#+         Output_ApiInformationCall_Push(bindAssignment.ApiInformation, Indent.OneTab); #>
<#+         if (bindAssignment is BoundLoadAssignment) { #>
<#+             if (includeDeferredSet) { #>
                Me.<#=bindAssignment.ObjectDeferredAssignmentCodeName#> = <#=value#>

<#+             }#>
                If <#=value#> Then
<#+             if (bindAssignment.BindUniverse.IsFileRoot) { #>
                    dataRoot.FindName("<#=element.ElementName#>")
<#+             } else { #>
                    <#=bindAssignment.BindUniverse.RootElement.ReferenceExpression#>.FindName("<#=element.ElementName#>")
<#+             }#>
                Else
<#+             if (bindAssignment.BindUniverse.IsFileRoot) { #>
                    dataRoot.UnloadObject(<#=objRef#>)
<#+             } else { #>
                    If <#=objRef#> IsNot Nothing Then
                        <#=Globalize(KnownNamespaces.XamlMarkup)#>.XamlMarkupHelper.UnloadObject(<#=objRef#>)
                    End If
                    Me.DisconnectUnloadedObject(<#=element.ConnectionId#>)
<#+             }#>
                End If
<#+         } else { #>
<#+             if (element.NeedsNullCheckBeforeSetValue) { #>
                If <#=objRef#> IsNot Nothing Then
<#+             PushIndent();#>
<#+             }#>
<#+             if (bindAssignment.MemberType.IsNullable) { #>
                XamlBindingSetters.Set_<#=bindAssignment.MemberDeclaringType.MemberFriendlyName()#>_<#=bindAssignment.MemberName#>(<#=objRef#>, <#=value#>, <#=bindAssignment.TargetNullValueExpression#>)
<#+             } else {#>
                XamlBindingSetters.Set_<#=bindAssignment.MemberDeclaringType.MemberFriendlyName()#>_<#=bindAssignment.MemberName#>(<#=objRef#>, <#=value#>)
<#+             }#>
<#+             if (element.NeedsNullCheckBeforeSetValue) { #>
<#+                 PopIndent();#>
<#+                 if (includeDeferredSet && element.CanBeInstantiatedLater) { #>
                Else
                    Me.<#=bindAssignment.ObjectDeferredAssignmentCodeName#> = <#=value#>
<#+                 }#>
                End If
<#+             }#>
<#+         }#>
<#+         Output_ApiInformationCall_Pop(bindAssignment.ApiInformation, Indent.OneTab); #>
<#+         if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+         {#>
<#+             PopIndent();#>
                End If
<#+         }#>
<#+     }#>

<#+ private void Output_Update_DataChanged_Step(string context, BindPathStep step)#>
<#+ {#>
<#+     if (step.Parent.ValueType.IsNullable) #>
<#+     {#>
        If obj IsNot Nothing Then
<#+     }#>
<#+     Output_UpdateCall(context, step, KnownStrings.DataChanged);#>
<#+     if (step.Parent.ValueType.IsNullable) #>
<#+     {#>
<#+         if (step.BindStatus.HasFlag(BindStatus.HasFallbackValue)) #>
<#+         {#>
        Else
        <#=context#>.UpdateFallback_<#=step.CodeName#>(DATA_CHANGED)
<#+         }#>
        End If
<#+     }#>
<#+ }#>

<#+ private void Output_Update_Steps(bool checkForNull, string context, IEnumerable<BindPathStep> steps, bool checkPhaseCondition, string phaseParam)#>
<#+ {#>
<#+     if (steps.Count() > 0) #>
<#+     {#>
<#+         PushIndent();#>
<#+         if (checkForNull)#>
<#+         {#>
<#+             PushIndent();#>
        If obj IsNot Nothing Then
<#+         }#>
<#+         List<BindPathStep> stepsWithFallback = new List<BindPathStep>();#>
<#+         string lastCondition = null;#>
<#+         foreach (BindPathStep childStep in (from step in steps where step.IsIncludedInUpdate orderby step.PhaseList select step))#>
<#+         {#>
<#+             if(checkPhaseCondition)#>
<#+             {#>
<#+                 string thisCondition = GetPhaseCondition(childStep);#>
<#+                 if (thisCondition != lastCondition)#>
<#+                 {#>
<#+                     if (lastCondition != null)#>
<#+                     {#>
            End If
<#+                     }#>
<#+                     lastCondition = thisCondition;#>
            If <#=thisCondition#> Then
<#+                 }#>
<#+                 PushIndent();#>
<#+                 Output_UpdateCall(context, childStep, phaseParam);#>
<#+                 PopIndent();#>
<#+             }#>
<#+             else#>
<#+             {#>
<#+                 if (lastCondition != null)#>
<#+                 {#>
            End If
<#+                 }#>
<#+                 lastCondition = null;#>
<#+                 Output_UpdateCall(context, childStep, phaseParam);#>
<#+             }#>
<#+             if (childStep.BindStatus.HasFlag(BindStatus.HasFallbackValue))#>
<#+             {#>
<#+               stepsWithFallback.Add(childStep);#>
<#+             }#>
<#+         }#>
<#+                 if (lastCondition != null)#>
<#+                 {#>
            End If
<#+                 }#>
<#+         if (checkForNull) #>
<#+         {#>
<#+             if (stepsWithFallback.Count > 0) #>
<#+             {#>
        Else
<#+                 foreach (BindPathStep childStep in stepsWithFallback)#>
<#+                 {#>
<#+                     if(checkPhaseCondition)#>
<#+                     {#>
            If <#=GetPhaseCondition(childStep)#> Then
                <#=context#>.UpdateFallback_<#=childStep.CodeName#>(<#=phaseParam#>)
            End If
<#+                     }#>
<#+                     else#>
<#+                     {#>
            <#=context#>.UpdateFallback_<#=childStep.CodeName#>(<#=phaseParam#>)
<#+                     }#>
<#+                 }#>
<#+             }#>
        End If
<#+             PopIndent();#>
<#+         }#>
<#+         PopIndent();#>
<#+     }#>
<#+ }#>

<#+ private string GetUpdateParams(BindPathStep bindStep)#>
<#+ {#>
<#+     if (bindStep is FunctionStep)#>
<#+     {#>
<#+         return "phase As Integer";#>
<#+     }#>
<#+     else#>
<#+     {#>
<#+         return "obj As " + bindStep.ValueType.VBName() + ", phase As Integer";#>
<#+     }#>
<#+ }#>

<#+ private void Output_Custom_Update_Call(string context, BindPathStep step, string firstArgument, string phaseParam)#>
<#+ {#>
<#+     if (string.IsNullOrEmpty(firstArgument))#>
<#+     {#>
            <#=context#>.Update_<#=step.CodeName#>(<#=phaseParam#>)
<#+     }#>
<#+     else#>
<#+     {#>
<#+         Output_ApiInformationCall_Push(step.ApiInformation, Indent.None);#>
            <#=context#>.Update_<#=step.CodeName#>(<#=firstArgument#>, <#=phaseParam#>)
<#+         Output_ApiInformationCall_Pop(step.ApiInformation, Indent.None);#>
<#+     }#>
<#+ }#>

<#+ private void Output_UpdateCall(string context, BindPathStep step, string phaseParam)#>
<#+ {#>
<#+     string firstArgument = step.CodeGen().UpdateCallParam.VBName(); #>
<#+     Output_Custom_Update_Call(context, step, firstArgument, phaseParam); #>
<#+ }#>

<#+ private void Output_CompleteUpdate(BindUniverse bindUniverse)#>
<#+ {#>
<#+     List<string> conditions = new List<string>();#>
<#+     bool needsLoop = bindUniverse.UnloadableBindingSourceElements.Any(); #>

            Private Sub CompleteUpdate(phase As Integer)
<#+     if (needsLoop) { #>
                Do
<#+         PushIndent(); #>
<#+     } #>
<#+     if (bindUniverse.HasFunctionBindings) {#>
                Dim functions As Global.System.Collections.Generic.Dictionary(Of string, InvokeFunctionDelegate) = Me.PendingFunctionBindings
                Me.PendingFunctionBindings = New Global.System.Collections.Generic.Dictionary(Of string, InvokeFunctionDelegate)()
                For Each func As InvokeFunctionDelegate In functions.Values
                    func.Invoke(phase)
                Next
<#+         conditions.Add("Me.PendingFunctionBindings.Count > 0"); #>
<#+     } #>
<#+     if (bindUniverse.UnloadableBindingSourceElements.Any()) {#>
                Do While Me.UnloadableBindingSourcesToUpdate.Count > 0
                    Me.UnloadableBindingSourcesToUpdate.Dequeue()()
                Loop
<#+         conditions.Add("Me.UnloadableBindingSourcesToUpdate.Count > 0"); #>
<#+     } #>
<#+     if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) {#>
                Do While Me.UnloadedElementsToUpdate.Count > 0
                    Me.UpdateUnloadedElement(Me.UnloadedElementsToUpdate.Dequeue())
                Loop
<#+         conditions.Add("Me.UnloadedElementsToUpdate.Count > 0"); #>
<#+     } #>
<#+     if (needsLoop) { #>
<#+         PopIndent(); #>
                Loop While <#=string.Join(" Or ", conditions)#>
<#+     } #>
            End Sub
<#+ } #>

<#+ private void Output_FunctionBindings(BindUniverse bindUniverse)#>
<#+ {#>

            Private Delegate Sub InvokeFunctionDelegate(phase As Integer)
            Private PendingFunctionBindings As Global.System.Collections.Generic.Dictionary(Of string, InvokeFunctionDelegate) = New Global.System.Collections.Generic.Dictionary(Of string, InvokeFunctionDelegate)()
<#+     foreach (FunctionStep functionStep in bindUniverse.BindPathSteps.Values.Where(s => s is FunctionStep))#>
<#+     {#>

            Private Sub Invoke_<#=functionStep.CodeName#>(phase As Integer)
<#+         foreach (var param in functionStep.Parameters.OrderBy(p => p.HasTryGetValue)) {#>
<#+             if (param.HasTryGetValue && functionStep.RequiresSafeParameterRetrieval) {#>
                Dim <#=param.Name#> As <#=param.AssignmentType#> = Nothing
                If Not <#=param.TryGetValueCodeName#>(<#=param.Name#>) Then Return
<#+             } else {#>
                Dim <#=param.Name#> As <#=param.ValueType#> = <#=param.CodeGen().PathExpression#>
<#+             }#>
<#+         }#>
                Dim result As <#=functionStep.ValueType#> = <#= functionStep.CodeGen().PathExpression #>
<#+         foreach (int distinctPhase in functionStep.DistinctPhases) {#>
<#+             Output_Binding_Phased_SetValue(distinctPhase, true, functionStep, true);#>
<#+             Output_Binding_Phased_SetValue(distinctPhase, false, functionStep, true);#>
<#+         }#>
            End Sub
<#+     }#>
<#+ }#>

<#+ private void Output_TryGetValueFunctions(BindUniverse bindUniverse)#>
<#+ {#>
<#+     foreach (BindPathStep step in bindUniverse.TryGetValueSteps)#>
<#+     {#>

            Private Function <#=step.TryGetValueCodeName#>(<Global.System.Runtime.InteropServices.Out()> ByRef val As <#=step.ValueType#>) As Boolean
<#+         if (step is RootStep || !step.Parent.IsIncludedInUpdate) {#>
                val = <#=step.CodeGen().PathExpression#>
                Return True
<#+         }#>
<#+         else {#>
                Dim obj As <#=step.Parent.ValueType#> = Nothing
<#+             if (step.Parent.ValueType.IsNullable) {#>
                If <#=step.Parent.TryGetValueCodeName#>(obj) And obj IsNot Nothing Then
<#+             } else { #>
                If <#=step.Parent.TryGetValueCodeName#>(obj) Then
<#+             } #>
                    val = <#=step.CodeGen().UpdateCallParam#>
                    Return True
                Else
                    val = Nothing
                    Return False
                End If
<#+         }#>
            End Function
<#+     }#>
<#+ }#>

<#+ private void Output_ApiInformationCall_Push(ApiInformation apiInformation, Indent indent)#>
<#+ {#>
<#+     if (apiInformation != null) { #>
<#+         PushIndent(indent); #>
            If <#=Model.CodeInfo.ClassName.ShortName#>.<#= apiInformation.MemberFriendlyName #> Then
<#+         PopIndent(); #>
<#+         PushIndent(); #>
<#+     } #>
<#+ } #>

<#+ private void Output_ApiInformationCall_Pop(ApiInformation apiInformation, Indent indent)#>
<#+ {#>
<#+     if (apiInformation != null) { #>
<#+         PopIndent(); #>
<#+         PushIndent(indent); #>
            End If
<#+         PopIndent(); #>
<#+     } #>
<#+ } #>

<#+ private void Output_ApiInformationDeclarations()#>
<#+ {#>
<#+     if (Model.ApiInformationDeclarations.Any()) { #>

        ' Api Information for conditional namespace declarations
<#+     } #>
<#+     foreach (var apiInformation in Model.ApiInformationDeclarations) { #>
        Shared <#= apiInformation.MemberFriendlyName #> as Boolean = <#= apiInformation.CodeGen().CallExpression #>
<#+     } #>
<#+ } #>