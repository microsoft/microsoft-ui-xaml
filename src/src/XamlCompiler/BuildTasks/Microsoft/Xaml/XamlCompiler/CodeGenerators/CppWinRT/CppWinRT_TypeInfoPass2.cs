// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 17.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.UI.Xaml.Markup.Compiler.CodeGen
{
    using System.Collections.Generic;
    using System.Linq;
    using Microsoft.UI.Xaml.Markup.Compiler.Properties;
    using Microsoft.UI.Xaml.Markup.Compiler.Utilities;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
    internal partial class CppWinRT_TypeInfoPass2 : CppWinRT_CodeGenerator<TypeInfoDefinition>
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
");
  if(!String.IsNullOrEmpty(ProjectInfo.PrecompiledHeaderFile)) { 
            this.Write("#include \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(ProjectInfo.PrecompiledHeaderFile));
            this.Write("\"\r\n");
  }
            this.Write("#include <memory>\r\n#include <unknwn.h>\r\n\r\n// Undefine GetCurrentTime macro to pre" +
                    "vent\r\n// conflict with Storyboard::GetCurrentTime\r\n#undef GetCurrentTime\r\n\r\n");
  foreach (var includeFile in Model.NeededCppWinRTProjectionHeaderFiles) { 
            this.Write("#if __has_include(<");
            this.Write(this.ToStringHelper.ToStringWithCulture(includeFile));
            this.Write(">)\r\n#include <");
            this.Write(this.ToStringHelper.ToStringWithCulture(includeFile));
            this.Write(">\r\n#endif\r\n");
  }
            this.Write("\r\n");
  if (ProjectInfo.GenerateIncrementalTypeInfo) { 
            this.Write("#ifdef XAML_TYPE_INFO_INC\r\n#include XAML_TYPE_INFO_INC\r\n#endif\r\n");
  } 
            this.Write("#include \"XamlTypeInfo.xaml.g.h\"\r\n\r\n");
  if (!ProjectInfo.GenerateIncrementalTypeInfo) { 
      foreach(string includeFile in Model.AllLocalXamlHeaderFiles) { 
            this.Write("#include \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(includeFile));
            this.Write("\"\r\n");
      } 
  } 
            this.Write("#include \"XamlBindingInfo.xaml.g.hpp\"\r\n");
  if (!ProjectInfo.GenerateIncrementalTypeInfo) { 
      foreach(string includeFile in Model.AllLocalHppGeneratedFiles) 
      { 
            this.Write("#include \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(includeFile.Replace(".g.hpp", ".xaml.g.hpp")));
            this.Write("\"\r\n");
      } 
  } 
            this.Write("\r\nnamespace winrt::");
            this.Write(this.ToStringHelper.ToStringWithCulture(Colonize(ProjectInfo.RootNamespace)));
            this.Write("::implementation\r\n{\r\nusing IXamlMember = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));
            this.Write("::IXamlMember;\r\nusing IXamlType = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));
            this.Write("::IXamlType;\r\nusing TypeKind = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsXamlInterop)));
            this.Write("::TypeKind;\r\n");
  if (Model.TypeInfos.Any()) { 
      if (ProjectInfo.GenerateCppWinRTStaticAsserts) { 
            this.Write(@"
    namespace XamlTypeInfo_staticasserts
    {
        template<typename, typename = void>
        constexpr bool is_type_complete_v = false;

        template<typename T>
        constexpr bool is_type_complete_v<T, std::void_t<decltype(sizeof(T))>> = true;

");
          foreach (var typeInfo in Model.TypeInfos) { 
              Output_StaticAssertTypeIsComplete(typeInfo, Indent.TwoTabs); 
          } 
            this.Write("\r\n    }\r\n");
      } 
            this.Write("\r\n");
      if (ProjectInfo.GenerateIncrementalTypeInfo) { 
          foreach(var entry in Model.TypeInfos.OrderBy(t => t.StandardName)) { 
              IncludeTemplate<CppWinRT_MetadataDelegates>(entry, ProjectInfo.ClassToHeaderFileMap.ContainsKey(entry.StandardName));
          } 
      } else { 
          IncludeTemplate<CppWinRT_TemplatedMetadataDelegates>(Model);
      } 
            this.Write(@"
enum TypeInfo_Flags
{
    TypeInfo_Flags_None                 = 0x00,
    TypeInfo_Flags_IsLocalType          = 0x01,
    TypeInfo_Flags_IsSystemType         = 0x02,
    TypeInfo_Flags_IsReturnTypeStub     = 0x04,
    TypeInfo_Flags_IsBindable           = 0x08,
    TypeInfo_Flags_IsMarkupExtension    = 0x10, 
};

struct TypeInfo
{
    const wchar_t* typeName{nullptr};
    const wchar_t* contentPropertyName{nullptr};
    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsFoundation)));
            this.Write("::IInspectable (*activator)();\r\n    void (*collectionAdd)(");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsFoundation)));
            this.Write("::IInspectable const&, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsFoundation)));
            this.Write("::IInspectable const&);\r\n    void (*dictionaryAdd)(");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsFoundation)));
            this.Write("::IInspectable const&, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsFoundation)));
            this.Write("::IInspectable const&, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsFoundation)));
            this.Write("::IInspectable const&);\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsFoundation)));
            this.Write(@"::IInspectable (*fromStringConverter)(XamlUserType const&, ::winrt::hstring const& );
    int     baseTypeIndex;
    int     firstMemberIndex;
    int     firstEnumValueIndex;
    int     createFromStringIndex;
    TypeKind kindOfType;
    unsigned int flags;
    int boxedTypeIndex;
};

");
  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) 
  { 
            this.Write("#pragma warning( push )\r\n#pragma warning( disable : 4973 )\r\n");
  } 
  if (Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod).Any()) { 
            this.Write("\r\nXamlUserType::CreateFromStringFn CreateFromStringMethods[] =\r\n{\r\n");
      foreach(var entry in Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod)) { 
            this.Write("    [](::winrt::hstring const& value) -> ::winrt::Windows::Foundation::IInspectab" +
                    "le { return ::winrt::box_value(");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.CreateFromStringMethod.ResolvedName.CppWinRTName()));
            this.Write("(value)); },\r\n");
      }
            this.Write("};\r\n");
  } 
            this.Write("\r\nconst TypeInfo TypeInfos[] = \r\n{\r\n");
  int entryIndex = 0; 
  int firstEnumValueIndex = 0; 
  int firstMemberIndex = 0; 
  int createFromStringIndex = 0; 
  foreach(var entry in Model.TypeInfos) 
  { 
      String isLocalType = entry.IsLocalType ? "TypeInfo_Flags_IsLocalType | " : "";
      String isSystemType = entry.IsSystemType ? "TypeInfo_Flags_IsSystemType | " : "";
      String isReturnTypeStub = entry.IsReturnTypeStub ? "TypeInfo_Flags_IsReturnTypeStub | " : "";
      String isBindable = entry.IsBindable ? "TypeInfo_Flags_IsBindable | " : "";
      String isMarkupExtension = entry.IsMarkupExtension ? "TypeInfo_Flags_IsMarkupExtension | " : "";
      String baseTypeIndex = entry.BaseTypeStandardName.Length > 0 ? Model.TypeInfoIndexes[entry.BaseTypeStandardName].ToString() + ", // " + entry.BaseTypeStandardName : "-1,";
      String boxedTypeIndex = entry.BoxedTypeStandardName.Length > 0 ? Model.TypeInfoIndexes[entry.BoxedTypeStandardName].ToString() + ", // " + entry.BoxedTypeStandardName : "-1,";
      String kindofType = String.Format("TypeKind::{0}", entry.IsLocalType && !ProjectInfo.IsLibrary ? "Custom" : "Metadata");
      String activator = entry.HasActivator ? $"&{entry.ActivatorName.CppWinRTName()}" : "nullptr";
      String collectionAdd = entry.IsCollection ? $"&{entry.CollectionAddName.CppWinRTName()}" : "nullptr";
      String dictionaryAdd = entry.IsDictionary ? $"&{entry.DictionaryAddName.CppWinRTName()}" : "nullptr";
      String fromStringConverter = entry.HasEnumValues ? $"&{entry.FromStringConverterName.CppWinRTName()}" : "nullptr";
      String createFromString = "-1";
      if (entry.HasCreateFromStringMethod)
      {
          createFromString = createFromStringIndex.ToString();
          createFromStringIndex++;
      }
      if (entry.HasMembers) 
      { 
          Model.TrackTypeMembers(entry, out firstMemberIndex); 
      } 
      if(entry.HasEnumValues) 
      { 
          Model.TrackTypeEnumValues(entry, out firstEnumValueIndex); 
      } 
            this.Write("    // ");
            this.Write(this.ToStringHelper.ToStringWithCulture(String.Format("{0,3}", entryIndex++)));
            this.Write("\r\n    L\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.StandardName));
            this.Write("\", L\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.ContentPropertyName));
            this.Write("\",\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(activator));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(collectionAdd));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(dictionaryAdd));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(fromStringConverter));
            this.Write(",\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeIndex));
            this.Write("\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(firstMemberIndex));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(firstEnumValueIndex));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(createFromString));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(kindofType));
            this.Write(",\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(isLocalType));
            this.Write(this.ToStringHelper.ToStringWithCulture(isSystemType));
            this.Write(this.ToStringHelper.ToStringWithCulture(isReturnTypeStub));
            this.Write(this.ToStringHelper.ToStringWithCulture(isBindable));
            this.Write(this.ToStringHelper.ToStringWithCulture(isMarkupExtension));
            this.Write("TypeInfo_Flags_None,\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(boxedTypeIndex));
            this.Write("\r\n");
      firstEnumValueIndex += entry.EnumValues.Count(); 
      firstMemberIndex += entry.Members.Count(); 
  } 
            this.Write("    //  Last type here is for padding\r\n    L\"\", L\"\",\r\n    nullptr, nullptr, nullp" +
                    "tr, nullptr,\r\n    -1, \r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(firstMemberIndex));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(firstEnumValueIndex));
            this.Write(", -1, TypeKind::Custom,\r\n    TypeInfo_Flags_None,\r\n};\r\n");
  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) 
  { 
            this.Write("#pragma warning( pop )\r\n");
  } 
            this.Write("\r\n");
  entryIndex = 0; 
            this.Write("constexpr uint32_t TypeInfoLookup[] = { \r\n");
  foreach(var entry in Model.TypeInfoLookup) 
  { 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(String.Format("{0,3},   // {1,3}", entry, entryIndex++)));
            this.Write("\r\n");
 } 
            this.Write("};\r\n");
  if (Model.EnumValues.Count() > 0) 
  { 
            this.Write("\r\nstruct EnumValueInfo\r\n{\r\n    const wchar_t* name{nullptr};\r\n    int eValue;\r\n};" +
                    "\r\n\r\nconst EnumValueInfo EnumValues[] =\r\n{ \r\n");
      foreach (var enumValue in Model.EnumValues) 
      { 
            this.Write("    L\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(enumValue.ValueName));
            this.Write("\", static_cast<int>(");
            this.Write(this.ToStringHelper.ToStringWithCulture(enumValue.TypeInfo.FullName));
            this.Write("::");
            this.Write(this.ToStringHelper.ToStringWithCulture(enumValue.ValueName));
            this.Write("),\r\n");
      } 
            this.Write("};\r\n");
  } 
  if (Model.MemberInfos.Count() > 0) 
  { 
            this.Write("\r\nstruct MemberInfo \r\n{\r\n    const wchar_t* shortName{nullptr};\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsFoundation)));
            this.Write("::IInspectable (*getter)(");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsFoundation)));
            this.Write("::IInspectable const&);\r\n    void (*setter)(");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsFoundation)));
            this.Write("::IInspectable const&, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.WindowsFoundation)));
            this.Write("::IInspectable const&);\r\n    int typeIndex;\r\n    int targetTypeIndex;\r\n    bool i" +
                    "sReadOnly;\r\n    bool isDependencyProperty;\r\n    bool isAttachable;\r\n};\r\n\r\n");
      if (Model.MemberInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) 
      { 
            this.Write("#pragma warning( push )\r\n#pragma warning( disable : 4973 )\r\n");
      } 
            this.Write("const MemberInfo MemberInfos[] = \r\n{\r\n");
      entryIndex = 0; 
      foreach(var entry in Model.MemberInfos) 
      { 
      String isReadOnly = entry.HasPublicGetter && !entry.HasPublicSetter ? "true, " : "false,"; 
      String isDependencyProperty = entry.IsDependencyProperty ? "true, " : "false,"; 
      String isAttachable = entry.IsAttachable ? "true, " : "false,"; 
      String targetTypeIndex = entry.TargetType != null ? Model.TypeInfoIndexes[entry.TargetType.StandardName].ToString() + ", // " + entry.TargetType.StandardName : "-1,";
            this.Write("    // ");
            this.Write(this.ToStringHelper.ToStringWithCulture(String.Format("{0,3}", entryIndex++)));
            this.Write(" - ");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.DeclaringType.StandardName));
            this.Write(".");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.Name));
            this.Write("\r\n    L\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.Name));
            this.Write("\",\r\n");
          if (entry.HasGetAttachableMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.GetAttachableMemberName));
            this.Write(",\r\n");
          } else if (entry.HasGetValueTypeMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.GetValueTypeMemberName));
            this.Write(",\r\n");
          } else if (entry.HasGetReferenceTypeMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.GetReferenceTypeMemberName));
            this.Write(",\r\n");
          } else { 
            this.Write("    nullptr,\r\n");
          } 
          if (entry.HasSetAttachableMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.SetAttachableMemberName));
            this.Write(",\r\n");
          } else if (entry.HasSetEnumMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.SetEnumMemberName));
            this.Write(",\r\n");
          } else if (entry.HasSetValueTypeMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.SetValueTypeMemberName));
            this.Write(",\r\n");
          } else if (entry.HasSetReferenceTypeMember) { 
            this.Write("    &");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.SetReferenceTypeMemberName));
            this.Write(",\r\n");
          } else { 
            this.Write("    nullptr,\r\n");
          } 
            this.Write("    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Model.TypeInfoIndexes[entry.Type.StandardName]));
            this.Write(", // ");
            this.Write(this.ToStringHelper.ToStringWithCulture(entry.Type.StandardName));
            this.Write("\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(targetTypeIndex));
            this.Write("\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(isReadOnly));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(isDependencyProperty));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(isAttachable));
            this.Write("\r\n");
      } 
            this.Write("};\r\n");
      if (Model.MemberInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) 
      { 
            this.Write("#pragma warning( pop )\r\n");
      } 
            this.Write("\r\nconst wchar_t* GetShortName(const wchar_t* longName)\r\n{\r\n    const auto separat" +
                    "or = wcsrchr(longName, \'.\');\r\n    return separator ? separator + 1: longName;\r\n}" +
                    "\r\n");
  } 
            this.Write(@"
const TypeInfo* GetTypeInfo(::winrt::hstring const& typeName)
{
    size_t typeNameLength = typeName.size();
    if (typeNameLength < _countof(TypeInfoLookup) - 1)
    {
        const auto begin = TypeInfos + TypeInfoLookup[typeNameLength];
        const auto end = TypeInfos + TypeInfoLookup[typeNameLength + 1];
        auto pos = std::find_if(begin, end, [&typeName](TypeInfo const& elem)
        {
            return wcscmp(typeName.data(), elem.typeName) == 0;
        });
        if (pos != end)
        {
            return pos;
        }
    }
    return nullptr;
}
");
      if (Model.MemberInfos.Count() > 0) { 
            this.Write(@"
const MemberInfo* GetMemberInfo(::winrt::hstring const& longMemberName)
{
    const auto dotPosition = std::find(longMemberName.crbegin(), longMemberName.crend(), L'.').base();
    if (dotPosition != longMemberName.end())
    {
        const auto sizeBeforeDot = static_cast<::winrt::hstring::size_type>(dotPosition - longMemberName.begin()) - 1;
        const TypeInfo* pTypeInfo = GetTypeInfo(::winrt::hstring{longMemberName.data(), sizeBeforeDot});
        if (pTypeInfo)
        {
            const TypeInfo* pNextTypeInfo = pTypeInfo + 1;
            const auto shortMemberName = GetShortName(longMemberName.data());
            const auto begin = MemberInfos + pTypeInfo->firstMemberIndex;
            const auto end = MemberInfos + pNextTypeInfo->firstMemberIndex;
            auto info = std::find_if(begin, end,
                [shortMemberName](const MemberInfo& elem)
            {
                return wcscmp(shortMemberName, elem.shortName) == 0;
            });
            if (info != end)
            {
                return info;
            }
        }
    }
    return nullptr;
}
");
      } 
  } // if (Model.TypeInfos.Count() > 0) 
            this.Write("\r\nstd::vector<");
            this.Write(this.ToStringHelper.ToStringWithCulture(Projection(KnownNamespaces.XamlMarkup)));
            this.Write("::IXamlMetadataProvider> const& XamlTypeInfoProvider::OtherProviders()\r\n{\r\n");
      if (ProjectInfo.GenerateProviderCode && SchemaInfo.OtherMetadataProviders.Any()) { 
            this.Write("    std::lock_guard<std::recursive_mutex> lock(_xamlTypesCriticalSection);\r\n    i" +
                    "f (_otherProviders.empty())\r\n    {\r\n");
          foreach(var provider in SchemaInfo.OtherMetadataProviders) { 
            this.Write("        _otherProviders.push_back(");
            this.Write(this.ToStringHelper.ToStringWithCulture(provider.FullName));
            this.Write("());\r\n");
          } 
            this.Write("    }\r\n");
  } 
            this.Write("    return _otherProviders;\r\n}\r\n\r\n");
  if (!Model.TypeInfos.Any()) { 
            this.Write("IXamlType XamlTypeInfoProvider::CreateXamlType(::winrt::hstring const& )\r\n{\r\n    " +
                    "// No local types\r\n    return nullptr;\r\n}\r\n");
  } else  { 
            this.Write("IXamlType XamlTypeInfoProvider::CreateXamlType(::winrt::hstring const& typeName)\r" +
                    "\n{\r\n    const TypeInfo* pTypeInfo = GetTypeInfo(typeName);\r\n    const TypeInfo* " +
                    "pNextTypeInfo = pTypeInfo + 1;\r\n    if (!pTypeInfo || !pNextTypeInfo)\r\n    {\r\n  " +
                    "      return nullptr;\r\n    }\r\n    else if (pTypeInfo->flags & TypeInfo_Flags_IsS" +
                    "ystemType)\r\n    {\r\n        return ::winrt::make<XamlSystemBaseType>(typeName);\r\n" +
                    "    }\r\n    else\r\n    {\r\n        ::winrt::hstring baseName { pTypeInfo->baseTypeI" +
                    "ndex >= 0 ? TypeInfos[pTypeInfo->baseTypeIndex].typeName : L\"\"};\r\n        ::winr" +
                    "t::hstring boxedName { pTypeInfo->boxedTypeIndex >= 0 ? TypeInfos[pTypeInfo->box" +
                    "edTypeIndex].typeName : L\"\"};\r\n        auto userType = ::winrt::make_self<XamlUs" +
                    "erType>(shared_from_this(), pTypeInfo->typeName, GetXamlTypeByName(baseName));\r\n" +
                    "        userType->_kindOfType = pTypeInfo->kindOfType;\r\n        userType->_activ" +
                    "ator = pTypeInfo->activator;\r\n        userType->_collectionAdd = pTypeInfo->coll" +
                    "ectionAdd;\r\n        userType->_dictionaryAdd = pTypeInfo->dictionaryAdd;\r\n      " +
                    "  userType->_fromStringConverter = pTypeInfo->fromStringConverter;\r\n        user" +
                    "Type->ContentPropertyName(pTypeInfo->contentPropertyName);\r\n        userType->Is" +
                    "LocalType(pTypeInfo->flags & TypeInfo_Flags_IsLocalType);\r\n        userType->IsR" +
                    "eturnTypeStub(pTypeInfo->flags & TypeInfo_Flags_IsReturnTypeStub);\r\n        user" +
                    "Type->IsBindable(pTypeInfo->flags & TypeInfo_Flags_IsBindable);\r\n        userTyp" +
                    "e->IsMarkupExtension(pTypeInfo->flags & TypeInfo_Flags_IsMarkupExtension);\r\n    " +
                    "    userType->_createFromStringMethod = nullptr;\r\n");
  if (Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod).Any()) { 
            this.Write("        if (pTypeInfo->createFromStringIndex != -1)\r\n        {\r\n            userT" +
                    "ype->_createFromStringMethod = CreateFromStringMethods[pTypeInfo->createFromStri" +
                    "ngIndex];\r\n        }\r\n");
  } 
            this.Write("        userType->SetBoxedType(GetXamlTypeByName(boxedName));\r\n");
  if (Model.MemberInfos.Any()) { 
            this.Write("        for (int i = pTypeInfo->firstMemberIndex; i < pNextTypeInfo->firstMemberI" +
                    "ndex; ++i)\r\n        {\r\n            userType->AddMemberName(MemberInfos[i].shortN" +
                    "ame);\r\n        }\r\n");
  } 
  if (Model.EnumValues.Any()) { 
            this.Write(@"        for (int i = pTypeInfo->firstEnumValueIndex; i < pNextTypeInfo->firstEnumValueIndex; ++i)
        {
            userType->AddEnumValue(EnumValues[i].name, winrt::Windows::Foundation::PropertyValue::CreateInt32(EnumValues[i].eValue));
        }
");
  } 
            this.Write("        return userType.as<IXamlType>();\r\n    }\r\n}\r\n");
  } 
            this.Write("\r\n");
  if (!Model.MemberInfos.Any()) { 
            this.Write("IXamlMember XamlTypeInfoProvider::CreateXamlMember(::winrt::hstring const& )\r\n{\r\n" +
                    "    // No local properties\r\n    return nullptr;\r\n}\r\n");
  } else { 
            this.Write(@"IXamlMember XamlTypeInfoProvider::CreateXamlMember(::winrt::hstring const& longMemberName)
{
    const MemberInfo* pMemberInfo = GetMemberInfo(longMemberName);
    if (!pMemberInfo)
    {
        return nullptr;
    }
    auto xamlMember = ::winrt::make_self<XamlMember>(shared_from_this(),
        pMemberInfo->shortName, TypeInfos[pMemberInfo->typeIndex].typeName);
    xamlMember->_getter = pMemberInfo->getter;
    xamlMember->_setter = pMemberInfo->setter;
    xamlMember->TargetTypeName(pMemberInfo->targetTypeIndex >= 0 ? TypeInfos[pMemberInfo->targetTypeIndex].typeName : L"""");
    xamlMember->IsReadOnly(pMemberInfo->isReadOnly);
    xamlMember->IsDependencyProperty(pMemberInfo->isDependencyProperty);
    xamlMember->IsAttachable(pMemberInfo->isAttachable);

    return xamlMember.as<IXamlMember>();
}
");
  } 
            this.Write("} // namespace\r\n\r\n");
            return this.GenerationEnvironment.ToString();
        }
 HashSet<TypeGenInfo> staticAssertTypes = new HashSet<TypeGenInfo>();
 private void Output_StaticAssertTypeIsComplete(TypeGenInfo typeInfo, Indent indent = Indent.None)
 {
     bool hasGeneratedCodeReference = typeInfo.HasActivator || typeInfo.IsCollection || typeInfo.IsDictionary || typeInfo.HasEnumValues;
     if(hasGeneratedCodeReference && !staticAssertTypes.Contains(typeInfo))
     {
         staticAssertTypes.Add(typeInfo);
         PushIndent(indent);
         if(!String.IsNullOrEmpty(ProjectInfo.PrecompiledHeaderFile))
         {
this.Write("static_assert( is_type_complete_v<");

this.Write(this.ToStringHelper.ToStringWithCulture(typeInfo.FullName.CppWinRTName()));

this.Write(">, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(ResourceUtilities.FormatString(XamlCompilerResources.XamlCompiler_CodeGenStaticAssert_IncompleteType, typeInfo.FullName.CppWinRTName(), ProjectInfo.PrecompiledHeaderFile)));

this.Write("\" );\r\n");

         }
         else
         {
this.Write("static_assert( is_type_complete_v<");

this.Write(this.ToStringHelper.ToStringWithCulture(typeInfo.FullName.CppWinRTName()));

this.Write(">, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(ResourceUtilities.FormatString(XamlCompilerResources.XamlCompiler_CodeGenStaticAssert_IncompleteType_NoPch, typeInfo.FullName.CppWinRTName())));

this.Write("\" );\r\n");

         }
         PopIndent();
     }
 }
    }
}
