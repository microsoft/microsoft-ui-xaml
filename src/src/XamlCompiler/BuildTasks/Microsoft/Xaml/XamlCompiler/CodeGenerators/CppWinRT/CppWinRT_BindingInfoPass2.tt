<#@ template language="C#" inherits="CppWinRT_CodeGenerator<BindingInfoDefinition>" visibility="internal" linePragmas="false"#>
<#@ assembly name="System.Core"#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<#  if(!String.IsNullOrEmpty(ProjectInfo.PrecompiledHeaderFile)) { #>
#include "<#=ProjectInfo.PrecompiledHeaderFile#>"
<#  }#>
#include "XamlBindingInfo.xaml.g.h"

namespace winrt::<#=Colonize(ProjectInfo.RootNamespace)#>::implementation
{

using DataContextChangedEventArgs = <#=Projection(KnownNamespaces.Xaml)#>::DataContextChangedEventArgs;
using DependencyObject = <#=Projection(KnownNamespaces.Xaml)#>::DependencyObject;
using DependencyProperty = <#=Projection(KnownNamespaces.Xaml)#>::DependencyProperty;
using FrameworkElement = <#=Projection(KnownNamespaces.Xaml)#>::FrameworkElement;
using INotifyCollectionChanged = <#=Projection(KnownNamespaces.XamlInterop)#>::INotifyCollectionChanged;
using INotifyPropertyChanged = <#=Projection(KnownNamespaces.XamlData)#>::INotifyPropertyChanged;
using PropertyChangedEventArgs = <#=Projection(KnownNamespaces.XamlData)#>::PropertyChangedEventArgs;
using NotifyCollectionChangedEventArgs = <#=Projection(KnownNamespaces.XamlInterop)#>::NotifyCollectionChangedEventArgs;
using ContainerContentChangingEventArgs = <#=Projection(KnownNamespaces.XamlControls)#>::ContainerContentChangingEventArgs;
using IComponentConnector = <#=Projection(KnownNamespaces.XamlMarkup)#>::IComponentConnector;
using WindowActivatedEventArgs = <#=Projection(KnownNamespaces.Xaml)#>::WindowActivatedEventArgs;
<# if (ProjectInfo.IsInputValidationEnabled) {#>
using INotifyDataErrorInfo = <#=Projection(KnownNamespaces.XamlData)#>::INotifyDataErrorInfo;
using DataErrorsChangedEventArgs = <#=Projection(KnownNamespaces.XamlData)#>::DataErrorsChangedEventArgs;
<# }#>

// XamlBindings

XamlBindings::XamlBindings(std::unique_ptr<IXamlBindings>&& pBindings)
    : _pBindings(std::move(pBindings))
{
}

void XamlBindings::Initialize()
{
    if (!_pBindings->IsInitialized())
    { 
        _pBindings->Update();
    }
}

void XamlBindings::Update()
{
    _pBindings->Update();
}

void XamlBindings::StopTracking()
{
    _pBindings->StopTracking();
}

void XamlBindings::Loading(FrameworkElement const&, IInspectable const&)
{
    Initialize();
}

void XamlBindings::Activated(IInspectable const&, WindowActivatedEventArgs const&)
{
    Initialize();
}

void XamlBindings::DataContextChanged(
    FrameworkElement const&,
    DataContextChangedEventArgs const& args)
{
    if (_pBindings->SetDataRoot(args.NewValue()))
    {
        Update();
    }
}

void XamlBindings::SubscribeForDataContextChanged(FrameworkElement const& object)
{
    _pBindings->SubscribeForDataContextChanged(object, *this);
}

void XamlBindings::DisconnectUnloadedObject(int connectionId)
{
    _pBindings->DisconnectUnloadedObject(connectionId);
}

void XamlBindings::Connect(int connectionId, IInspectable const& target)
{
    _pBindings->Connect(connectionId, target);
}

IComponentConnector XamlBindings::GetBindingConnector(int32_t, IInspectable const&)
{
    return nullptr;
}

bool XamlBindings::ProcessBinding(unsigned int)
{
    throw ::winrt::hresult_not_implemented {};
}

int XamlBindings::ProcessBindings(ContainerContentChangingEventArgs const& args)
{
    int32_t nextPhase;
    _pBindings->ProcessBindings(args.Item(), args.ItemIndex(), args.Phase(), nextPhase);
    return nextPhase;
}

void XamlBindings::ResetTemplate()
{
    _pBindings->Recycle();
}

void XamlBindings::ProcessBindings(
    IInspectable const& item, int itemIndex, int phase, int32_t& nextPhase)
{
    _pBindings->ProcessBindings(item, itemIndex, phase, nextPhase);
}

void XamlBindings::Recycle()
{
    _pBindings->Recycle();
}

// XamlBindingTrackingBase

XamlBindingTrackingBase::XamlBindingTrackingBase()
{
}

void XamlBindingTrackingBase::SetListener(IXamlBindingTracking* pBindings)
{
    _pBindingsTrackingWeakRef = pBindings;
}

void XamlBindingTrackingBase::PropertyChanged(
    IInspectable const& sender,
    PropertyChangedEventArgs const&  e)
{
    if (_pBindingsTrackingWeakRef)
    {
        _pBindingsTrackingWeakRef->PropertyChanged(sender, e);
    }
}

void XamlBindingTrackingBase::CollectionChanged(
    IInspectable const& sender,
    NotifyCollectionChangedEventArgs const& e)
{
    if (_pBindingsTrackingWeakRef)
    {
        _pBindingsTrackingWeakRef->CollectionChanged(sender, e);
    }
}

void XamlBindingTrackingBase::DependencyPropertyChanged(
    DependencyObject const& sender,
    DependencyProperty const& prop)
{
    if (_pBindingsTrackingWeakRef)
    {
        _pBindingsTrackingWeakRef->DependencyPropertyChanged(sender, prop);
    }
}

void XamlBindingTrackingBase::VectorChanged(
    IInspectable const& sender,
    <#=Projection(KnownNamespaces.WindowsFoundationCollections)#>::IVectorChangedEventArgs const& e)
{
    if (_pBindingsTrackingWeakRef)
    {
        _pBindingsTrackingWeakRef->VectorChanged(sender, e);
    }
}

void XamlBindingTrackingBase::MapChanged(
    IInspectable const& sender,
    <#=Projection(KnownNamespaces.WindowsFoundationCollections)#>::IMapChangedEventArgs<::winrt::hstring> const& e)
{
    if (_pBindingsTrackingWeakRef)
    {
        _pBindingsTrackingWeakRef->MapChanged(sender, e);
    }
}
<# if (ProjectInfo.IsInputValidationEnabled) {#>

void XamlBindingTrackingBase::ErrorsChanged(
    IInspectable const& sender,
    DataErrorsChangedEventArgs const&  e)
{
    if (_pBindingsTrackingWeakRef)
    {
        _pBindingsTrackingWeakRef->ErrorsChanged(sender, e);
    }
}
<# }#>

void XamlBindingTrackingBase::UpdatePropertyChangedListener(
    INotifyPropertyChanged const& obj,
    INotifyPropertyChanged& cache,
    ::winrt::event_token& token)
{
    if (cache && cache != obj)
    {
        cache.PropertyChanged(token);
        cache = nullptr;
    }

    if (!cache && obj)
    {
        cache = obj;
        token = obj.PropertyChanged({ this, &XamlBindingTrackingBase::PropertyChanged });
    }
}

void XamlBindingTrackingBase::UpdatePropertyChangedListener(
    INotifyPropertyChanged const& obj,
    ::winrt::weak_ref<<#=Projection(KnownNamespaces.XamlData)#>::INotifyPropertyChanged>& cacheRef,
    ::winrt::event_token& token)
{
    INotifyPropertyChanged cache = cacheRef.get();
    if (cache && cache != obj)
    {
        cache.PropertyChanged(token);
        cache = nullptr;
        cacheRef = nullptr;
    }

    if (!cache && obj)
    {
        cacheRef = cache = obj;
        token = obj.PropertyChanged({ this, &XamlBindingTrackingBase::PropertyChanged });
    }
}

void XamlBindingTrackingBase::UpdateCollectionChangedListener(
    INotifyCollectionChanged const& obj,
    INotifyCollectionChanged& cache,
    ::winrt::event_token& token)
{
    if (cache && cache != obj)
    {
        cache.CollectionChanged(token);
        cache = nullptr;
    }

    if (!cache && obj)
    {
        cache = obj;
        token = obj.CollectionChanged({ this, &XamlBindingTrackingBase::CollectionChanged });
    }
}

void XamlBindingTrackingBase::UpdateDependencyPropertyChangedListener(
    DependencyObject const& obj,
    DependencyProperty const& property,
    DependencyObject& cache,
    int64_t& token)
{
    if (cache && cache != obj)
    {
        cache.UnregisterPropertyChangedCallback(property, token);
        cache = nullptr;
    }

    if (!cache && obj)
    {
        cache = obj;
        token = obj.RegisterPropertyChangedCallback(property, 
            { this, &XamlBindingTrackingBase::DependencyPropertyChanged });
    }
}

void XamlBindingTrackingBase::UpdateDependencyPropertyChangedListener(
    DependencyObject const& obj,
    DependencyProperty const& property,
    winrt::weak_ref<<#=Projection(KnownNamespaces.Xaml)#>::DependencyObject>& cacheRef,
    int64_t& token)
{
    DependencyObject cache = cacheRef.get();
    if (cache && cache != obj)
    {
        cache.UnregisterPropertyChangedCallback(property, token);
        cache = nullptr;
        cacheRef = nullptr;
    }

    if (!cache && obj)
    {
        cacheRef = cache = obj;
        token = obj.RegisterPropertyChangedCallback(property, 
            { this, &XamlBindingTrackingBase::DependencyPropertyChanged });
    }
}

<# if (ProjectInfo.IsInputValidationEnabled) {#>
void XamlBindingTrackingBase::UpdateErrorsChangedListener(
    INotifyDataErrorInfo const& obj,
    INotifyDataErrorInfo& cache,
    ::winrt::event_token& token)
{
    if (cache && cache != obj)
    {
        cache.ErrorsChanged(token);
        cache = nullptr;
    }

    if (!cache && obj)
    {
        cache = obj;
        token = obj.ErrorsChanged({ this, &XamlBindingTrackingBase::ErrorsChanged });
    }
}

void XamlBindingTrackingBase::UpdateErrorsChangedListener(
    INotifyDataErrorInfo const& obj,
    ::winrt::weak_ref<<#=Projection(KnownNamespaces.XamlData)#>::INotifyDataErrorInfo>& cacheRef,
    ::winrt::event_token& token)
{
    INotifyDataErrorInfo cache = cacheRef.get();
    if (cache && cache != obj)
    {
        cache.ErrorsChanged(token);
        cache = nullptr;
        cacheRef = nullptr;
    }

    if (!cache && obj)
    {
        cacheRef = cache = obj;
        token = obj.ErrorsChanged({ this, &XamlBindingTrackingBase::ErrorsChanged });
    }
}
<# } #>
} // namespace
