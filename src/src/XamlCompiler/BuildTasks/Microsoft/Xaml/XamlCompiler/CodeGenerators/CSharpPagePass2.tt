<#@ template language="C#" inherits="CSharp_CodeGenerator<PageDefinition>" visibility="internal" linePragmas="false"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#  foreach(var pair in Model.XamlFileFullPathAndCheckSums) #>
<#  {   #>
#pragma checksum "<#=pair.FileName#>" "<#=Model.ChecksumAlgorithmGuid#>" "<#=pair.Checksum#>"
<#  }   #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace <#=Model.CodeInfo.ClassName.Namespace#>
{
<# if (Model.CodeInfo.IsApplication) #>
<# {#>
    partial class <#=Model.CodeInfo.ClassName.ShortName#> : <#=Globalize(Model.CodeInfo.BaseTypeName)#>
    {
    }
<# }#>
<# else #>
<# {#>
    partial class <#=Model.CodeInfo.ClassName.ShortName#> : 
        <#=Globalize(Model.CodeInfo.BaseTypeName)#>, 
        <#=Globalize(KnownTypes.IComponentConnector)#>
    {
<#      if (Model.CodeInfo.HasBindingSetters) #>
<#      { #>
        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        private static class XamlBindingSetters
        {
<#      var bindingSetters = new HashSet<String>();#>
<#      foreach (ConnectionIdElement connectionId in Model.AllConnectionIdElements)#>
<#      {#>
<#          foreach (BindPathStep step in connectionId.BindUniverse.BindPathSteps.Values)#>
<#          {#>
<#              foreach (BindAssignment bindAssignment in step.BindAssignments.Where(ba => ba.HasSetValueHelper))#>
<#              {#>
<#                  if (!bindingSetters.Contains(bindAssignment.MemberFullName))#>
<#                  {#>
<#                      Output_Binding_SetValue_Function(bindAssignment);#>
<#                      bindingSetters.Add(bindAssignment.MemberFullName);#>
<#                  }#>
<#              }#>
<#          }#>
<#      }#>
<# #>
        };
<#      } #>
<#      if (Model.CodeInfo.IsUsingCompiledBinding) #>
<#      { #>
<#          Output_BindingsClasses();  #>
<#      } #>
<#      Output_ConnectMethod();  #>
<#      Output_UnloadObjectMethod(); #>

<#      Output_GetBindingConnectorMethod();  #>
<#      Output_ApiInformationDeclarations();  #>
<#      Output_InitializeXProperties(); #>
    }
<# }#>
}
<#+     private void Output_InitializeXProperties() #>
<#+     { #>
<#+         if (Model.XProperties.Any()) #>
<#+         { #>

        /// <summary>
        /// InitializeXProperties()
        /// </summary>
        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        partial void InitializeXProperties()
        {
<#+             foreach (xProperty xProp in Model.XProperties) #>
<#+             { #>
<#+                 if (xProp.DefaultValueString != null) #>
<#+                 { #>
            _<#=xProp.Name#> = <#=xProp.PropertyType.GetStringToThing($"\"{xProp.DefaultValueString}\"")#>;
<#+                 } #>
<#+                 if (xProp.DefaultValueMarkup != null) #>
<#+                 { #>
            _<#=xProp.Name#> = (<#=xProp.PropertyType.CSharpName()#>)(<#=Globalize(KnownTypes.XamlReader)#>.Load(<#=xProp.DefaultValueMarkup#>));
<#+                 } #>
<#+             } #>
        }
<#+         } #>
<#+     } #>
<#+     private void Output_ConnectMethod()#>
<#+     {#>

        /// <summary>
        /// Connect()
        /// </summary>
        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        public void Connect(int connectionId, object target)
        {
<#+         if(Model.ConnectableElements.Any()) #>
<#+         { #>
            switch(connectionId)
            {
<#+             foreach (ConnectionIdElement element in Model.ConnectableElements)#>
<#+             {#>
            case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
<#+                 FieldDefinition fieldInfo = element.FieldDefinition; #>
<#+                 string objectInitName; #>
<#+                 string objectName; #>
<#+                 if(fieldInfo == null) #>
<#+                 { #>
<#+                     objectInitName = element.Type.CSharpName() + " " + element.ElementCodeName; #>
<#+                     objectName = element.ElementCodeName; #>
<#+                 } #>
<#+                 else #>
<#+                 { #>
<#+                     objectInitName = "this." + fieldInfo.FieldName; #>
<#+                     objectName = "this." + fieldInfo.FieldName; #>
<#+                 } #>
<#+                 Output_PushDeprecated(element.Type.IsDeprecated()); #>
                {
<#+                 Output_ApiInformationCall_Push(element.ApiInformation, Indent.TwoTabs); #>
                    <#=objectInitName#> = <#=ObjectCast(element.Type.ToString(), "target")#>;
<#+                 foreach (EventAssignment ev in element.EventAssignments) #>
<#+                 { #>
<#+                     Output_ApiInformationCall_Push(ev.ApiInformation, Indent.TwoTabs); #>
                    ((<#=element.Type#>)<#=objectName#>).<#=ev.EventName#> += this.<#=ev.HandlerName#>;
<#+                     Output_ApiInformationCall_Pop(ev.ApiInformation, Indent.TwoTabs); #>
<#+                 }#>
<#+                 Output_PopDeprecated(element.Type.IsDeprecated()); #>
<#+                 Output_ApiInformationCall_Pop(element.ApiInformation, Indent.TwoTabs); #>
                }
                break;
<#+             }#>
            default:
                break;
            }
<#+         } #>
            this._contentLoaded = true;
        }
<#+     }#>

<#+     private void Output_UnloadObjectMethod()#>
<#+     {#>
<#+         if (Model.UnloadableFields.Count() > 0)#>
<#+         {#>

        /// <summary>
        /// UnloadObject(DependencyObject)
        /// </summary>
        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        partial void UnloadObject(<#=Globalize(KnownTypes.DependencyObject)#> unloadableObject)
        {
            if (unloadableObject != null)
            {
<#+             foreach (var element in Model.UnloadableFields) { #>
                // <#=element.LineNumberAndXamlFile#>
<#+             Output_ApiInformationCall_Push(element.ApiInformation, Indent.OneTab); #>
                if (unloadableObject == this.<#=element.ElementName#>)
                { 
                    this.DisconnectUnloadedObject(<#=element.ConnectionId#>);
                }
<#+             Output_ApiInformationCall_Pop(element.ApiInformation, Indent.OneTab); #>
<#+             } #>
                <#=Globalize(KnownTypes.XamlMarkupHelper)#>.UnloadObject(unloadableObject);
            }
        }

        /// <summary>
        /// DisconnectUnloadedObject(int connectionId)
        /// </summary>
        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        private void DisconnectUnloadedObject(int connectionId)
        {
            switch(connectionId)
            {
<#+             foreach (var element in Model.DeferrableElements)#>
<#+             {#>
                case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
                {
<#+                 foreach (var childElem in element.Children) #>
<#+                 {#>
<#+                     if (childElem.HasFieldDefinition) #>
<#+                     {#>
                    this.DisconnectUnloadedObject(<#=childElem.ConnectionId#>);
<#+                     }#>
<#+                     if (childElem.HasBindAssignments || element.HasRootNamedElementStep) #>
<#+                     {#>
                    this.Bindings.DisconnectUnloadedObject(<#=childElem.ConnectionId#>);
<#+                     }#>
<#+                 }#>
<#+                 if (element.HasBindAssignments || element.HasRootNamedElementStep) #>
<#+                 {#>
                    this.Bindings.DisconnectUnloadedObject(<#=element.ConnectionId#>);
<#+                 }#>
<#+                 FieldDefinition fieldInfo = element.FieldDefinition; #>
<#+                 if(fieldInfo != null) #>
<#+                 { #>
<#+                     Output_ApiInformationCall_Push(element.ApiInformation, Indent.TwoTabs); #>
                    this.<#=fieldInfo.FieldName#> = null;
<#+                     Output_ApiInformationCall_Pop(element.ApiInformation, Indent.TwoTabs); #>
<#+                 } #>
                    break;
                }
<#+             }#>
                default:
                {
                    throw new global::System.ArgumentException("Invalid connectionId.");
                }
            }
        }
<#+         } #>
<#+     }#>
<#+     private void Output_GetBindingConnectorCaseBindingPropertiesSet(ConnectionIdElement element, bool isPageRoot) #>
<#+     { #>
<#+         if (element.BindUniverse.NeededForOuterScopeElement) #>
<#+         { #>
<#+             if (isPageRoot) #>
<#+             { #>
<#+                 if (Model.CodeInfo.IsResourceDictionary)#>
<#+                 {#>
                    bindings.RootWeakReference = new <#=Globalize(WeakReferenceTypeName)#><<#=Globalize(KnownTypes.ResourceDictionary)#>>(this);
<#+                 }#>
<#+                 else#>
<#+                 {#>
                    bindings.RootWeakReference = new <#=Globalize(WeakReferenceTypeName)#><<#=Globalize(KnownTypes.FrameworkElement)#>>(this);
<#+                 }#>
<#+                 if (!element.BindUniverse.IsFileRoot) #>
<#+                 { #>
                    bindings.Parent = new <#=Globalize(WeakReferenceTypeName)#>(this.Bindings);
<#+                 } #>
<#+             } #>
<#+             else #>
<#+             { #>
                    bindings.RootWeakReference = this.RootWeakReference;
                    bindings.Parent = new <#=Globalize(WeakReferenceTypeName)#>(this);
<#+             } #>
<#+         } #>
<#+     } #>

<#+     private void Output_GetBindingConnectorCase(ConnectionIdElement element, bool isPageRoot)#>
<#+     {#>
            case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
                {                    
<#+                     Output_PushDeprecated(element.Type.IsDeprecated());#>
<#+                     if (element.Type.IsDerivedFromControlTemplate())#>
<#+                     {#>
                    var <#=element.ElementTemplatedParentCodeName #> = target as <#=element.TemplatedParentType#>;
                    if (<#=element.ElementTemplatedParentCodeName #> != null)
                    {
                        <#=element.BindUniverse.BindingsClassName#> bindings = new <#=element.BindUniverse.BindingsClassName#>();
                        returnValue = bindings;
                        bindings.SetDataRoot(<#=element.ElementTemplatedParentCodeName #>);
                        <#=Globalize(KnownTypes.XamlBindingHelper)#>.SetDataTemplateComponent(<#=element.ElementTemplatedParentCodeName#>, bindings);
<#+                         PushIndent(Indent.OneTab); #>
<#+                         Output_GetBindingConnectorCaseBindingPropertiesSet(element, isPageRoot); #>
<#+                         PopIndent(); #>
                    }
<#+                     }#>
<#+                     else#>
<#+                     {#>
                    <#=element.Type#> <#=element.ElementCodeName#> = (<#=element.Type#>)target;
                    <#=element.BindUniverse.BindingsClassName#> bindings = new <#=element.BindUniverse.BindingsClassName#>();
                    returnValue = bindings;
                    bindings.SetDataRoot(<#=element.IsBindingFileRoot ? "this" : element.ElementCodeName + ".DataContext"#>);
<#+                         if (element.BindUniverse.DistinctConvertersUsed.Count() > 0) #>
<#+                         {#>
<#+                             if (isPageRoot) #>
<#+                             { #>
                    bindings.SetConverterLookupRoot(this);
<#+                             } #>
<#+                             else #>
<#+                             { #>
<#+                                 if (Model.CodeInfo.IsResourceDictionary)#>
<#+                                 {#>
                    <#=Globalize(KnownTypes.ResourceDictionary)#> rootReference;
<#+                                 }#>
<#+                                 else#>
<#+                                 {#>
                    <#=Globalize(KnownTypes.FrameworkElement)#> rootReference;
<#+                                 }#>
                    this.RootWeakReference.TryGetTarget(out rootReference);
                    bindings.SetConverterLookupRoot(rootReference);
<#+                             } #>
<#+                         }#>
<#+                         if (element.IsBindingFileRoot)#>
<#+                         { #>
                    this.Bindings = bindings;
<#+                             if (element.Type.IsDerivedFromWindow()) { #>
                    <#=element.ElementCodeName#>.Activated += bindings.Activated;
<#+                             } #>
<#+                             else { #>
                    <#=element.ElementCodeName#>.Loading += bindings.Loading;
<#+                             } #>
<#+                         }#>
<#+                         else#>
<#+                         {#>
                    <#=element.ElementCodeName#>.DataContextChanged += bindings.DataContextChangedHandler;
                    <#=Globalize(KnownTypes.DataTemplate)#>.SetExtensionInstance(<#=element.ElementCodeName#>, bindings);
<#+                         }#>
<#+                         if (!element.Type.IsDerivedFromWindow() && (ProjectInfo.ShouldGenerateDisableXBind || !element.IsBindingFileRoot)) #>
<#+                         {#>
                    <#=Globalize(KnownTypes.XamlBindingHelper)#>.SetDataTemplateComponent(<#=element.ElementCodeName#>, bindings);
<#+                         }#>
<#+                         Output_GetBindingConnectorCaseBindingPropertiesSet(element, isPageRoot); #>
<#+                     }#>
<#+                     Output_PopDeprecated(element.Type.IsDeprecated()); #>
                }
                break;
<#+     }#>

<#+     private void Output_GetBindingConnectorMethod()#>
<#+     {#>
        /// <summary>
        /// GetBindingConnector(int connectionId, object target)
        /// </summary>
        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        public <#=Globalize(KnownTypes.IComponentConnector)#> GetBindingConnector(int connectionId, object target)
        {
            <#=Globalize(KnownTypes.IComponentConnector)#> returnValue = null;
<#+         if (Model.CodeInfo.BindStatus != BindStatus.None) #>
<#+         { #>
            switch(connectionId)
            {
<#+             foreach (ConnectionIdElement element in Model.AllConnectionIdElements)#>
<#+             {#>
<#+                 if (element.IsBindingRoot)#>
<#+                 {#>
<#+                     Output_GetBindingConnectorCase(element, true); #>
<#+                 }#>
<#+             }#>
            }
<#+         } #>
            return returnValue;
        }
<#+     }#>
<#+ #>
<#+     private void Output_PushDeprecated(bool isDeprecated)#>
<#+     {#>
<#+         if (isDeprecated) #>
<#+         { #>
#pragma warning disable 0618  //   Warning on Deprecated usage
<#+         } #>
<#+     }#>

<#+     private void Output_PopDeprecated(bool isDeprecated)#>
<#+     {#>
<#+         if (isDeprecated) #>
<#+         { #>
#pragma warning restore 0618
<#+         } #>
<#+     }#>

<#+     private void Output_BindingsClasses()#>
<#+     {#>
<#+         foreach (BindUniverse bindUniverse in Model.CodeInfo.BindUniverses)#>
<#+         {#>

        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        private class <#=bindUniverse.BindingsClassName#> :
<#+             if (bindUniverse.NeedsIDataTemplateExtension) #>
<#+             {#>
            <#=Globalize(KnownTypes.IDataTemplateExtension)#>,
<#+             }#>
<#+             if (bindUniverse.NeedsIDataTemplateComponent || ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>
            <#=Globalize(KnownTypes.IDataTemplateComponent)#>,
<#+             }#>
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>
            <#=Globalize(KnownTypes.IXamlBindScopeDiagnostics)#>,
<#+             }#>
            <#=Globalize(KnownTypes.IComponentConnector)#>,
<#+             if (bindUniverse.NeededForOuterScopeElement) { #>
            I<#=Model.CodeInfo.ClassName.ShortName#>_BindingsScopeConnector,
<#+             }#>
            I<#=Model.CodeInfo.ClassName.ShortName#>_Bindings
        {
            private <#=bindUniverse.DataRootType#> dataRoot;
<#+             if (bindUniverse.NeededForOuterScopeElement) #>
<#+             { #>
            #pragma warning disable 649
<#+                 if (Model.CodeInfo.IsResourceDictionary)#>
<#+                 {#>
            public <#=Globalize(WeakReferenceTypeName)#><<#=Globalize(KnownTypes.ResourceDictionary)#>> RootWeakReference { get; set; }
<#+                 }#>
<#+                 else#>
<#+                 {#>
            public <#=Globalize(WeakReferenceTypeName)#><<#=Globalize(KnownTypes.FrameworkElement)#>> RootWeakReference { get; set; }
<#+                 }#>
            #pragma warning restore 649
<#+             } #>
            private bool initialized = false;
            private const int NOT_PHASED = (1 << 31);
            private const int DATA_CHANGED = (1 << 30);
<#+             if (bindUniverse.DistinctConvertersUsed.Count() > 0) #>
<#+             {#>
            private <#=Globalize(KnownTypes.ResourceDictionary)#> localResources;
<#+                 if (!Model.CodeInfo.IsResourceDictionary)#>
<#+                 {#>
            private <#=Globalize(WeakReferenceTypeName)#><<#=Globalize(KnownTypes.FrameworkElement)#>> converterLookupRoot;
<#+                 }#>
<#+             }#>
<#+             if (bindUniverse.NeedsIDataTemplateExtension) #>
<#+             { #>
            private bool removedDataContextHandler = false;
<#+             } #>

            // Fields for each control that has bindings.
<#+             foreach (ConnectionIdElement bindElement in bindUniverse.BoundElements)#>
<#+             {#>
<#+                 if (bindElement.IsWeakRef) #>
<#+                 {#>
            private <#=Globalize(WeakReferenceTypeName)#> <#=bindElement.ObjectCodeName#>;
<#+                 }#>
<#+                 else if (!bindElement.Type.IsDerivedFromControlTemplate()) #>
<#+                 {#>
            private <#=bindElement.Type#> <#=bindElement.ObjectCodeName#>;
<#+                 }#>
<#+                 if (bindElement.CanBeInstantiatedLater)#>
<#+                 {#>
<#+                     foreach (var bindAssignment in bindElement.BindAssignments)#>
<#+                     {#>
            private <#=bindAssignment.MemberType#> <#=bindAssignment.ObjectDeferredAssignmentCodeName#>;
<#+                     }#>
<#+                 }#>
<#+             }#>
<#+         if (bindUniverse.ElementsWithConnectCase.Where(e => e.BoundEventAssignments.Count > 0).Count() > 0)#>
<#+             {#>

            // Fields for each event bindings event handler.
<#+             }#>
<#+             foreach (var element in bindUniverse.ElementsWithConnectCase)#>
<#+             {#>
<#+                 foreach (BoundEventAssignment evt in element.BoundEventAssignments)#>
<#+                 {#>
            private <#=evt.MemberType#> <#=evt.EventHandlerCodeName#>;
<#+                 }#>
<#+             }#>
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>

            // Static fields for each binding's enabled/disabled state
<#+                 foreach (ConnectionIdElement bindElement in bindUniverse.ElementsWithConnectCaseInLocalScope)#>
<#+                 {#>
<#+                     foreach (BindAssignment ba in bindElement.BindAssignments)#>
<#+                     {#>
            private static bool <#=ba.DisableFlagName#> = false;
<#+                     }#>
<#+                 }#>
<#+             }#>

<#+             if (bindUniverse.UnloadableBindingSourceElements.Any()) { #>
            private global::System.Collections.Generic.Queue<global::System.Action> UnloadableBindingSourcesToUpdate = new global::System.Collections.Generic.Queue<global::System.Action>();
<#+             } #>
<#+             if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) { #>
            private global::System.Collections.Generic.Queue<global::System.Int32> UnloadedElementsToUpdate = new global::System.Collections.Generic.Queue<global::System.Int32>();
<#+             } #>
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>

            private <#=bindUniverse.BindingsClassName#>Tracking bindingsTracking;
<#+             }#>

            public <#=bindUniverse.BindingsClassName#>()
            {
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>
                this.bindingsTracking = new <#=bindUniverse.BindingsClassName#>Tracking(this);
<#+             }#>
            }
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>

            public void Disable(int lineNumber, int columnNumber)
            {
<#+                 bool firstIfInDisable = true; #>
<#+                 foreach (var element in bindUniverse.ElementsWithConnectCaseInLocalScope)#>
<#+                 {#>
<#+                     foreach (BindAssignment ba in element.BindAssignments)#>
<#+                     {#>
<#+                         if (firstIfInDisable)#>
<#+                         {#>
<#+                         firstIfInDisable = false; #>
                if (lineNumber == <#=ba.LineNumber#> && columnNumber == <#=ba.ColumnNumber#>)
<#+                         } else {#>
                else if (lineNumber == <#=ba.LineNumber#> && columnNumber == <#=ba.ColumnNumber#>)
<#+                         }#>
                {
                    <#=ba.DisableFlagName#> = true;
                }
<#+                     }#>
<#+                     foreach (BoundEventAssignment evt in element.BoundEventAssignments)#>
<#+                     {#>
<#+                         if (firstIfInDisable)#>
<#+                         {#>
<#+                         firstIfInDisable = false; #>
                if (lineNumber == <#=evt.LineNumber#> && columnNumber == <#=evt.ColumnNumber#>)
<#+                         } else {#>
                else if (lineNumber == <#=evt.LineNumber#> && columnNumber == <#=evt.ColumnNumber#>)
<#+                         }#>
                {
<#+                         if (element.IsWeakRef)#>
<#+                         {#>
                    if (this.<#=element.ObjectCodeName#>.IsAlive)
                    {
                        ((<#=element.Type#>)this.<#=element.ObjectCodeName#>.Target).<#=evt.MemberName#> -= <#=evt.EventHandlerCodeName#>;
                    }
<#+                         } else {#>
                    this.<#=element.ObjectCodeName#>.<#=evt.MemberName#> -= <#=evt.EventHandlerCodeName#>;
<#+                         }#>
                }
<#+                     }#>
<#+                 }#>
            }
<#+             }#>

            // IComponentConnector

            public void Connect(int connectionId, global::System.Object target)
            {
<#+             if (!bindUniverse.ElementsWithConnectCase.Any()) #>
<#+             { #>
                return;
<#+             } #>
<#+             else #>
<#+             { #>
                switch(connectionId)
                {
<#+             foreach (var element in bindUniverse.ElementsWithConnectCase)#>
<#+             {#>
                    case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
<#+                 if (bindUniverse.BoundElements.Contains(element)) { #>
<#+                 Output_ApiInformationCall_Push(element.ApiInformation, Indent.ThreeTabs); #>
<#+                 if (element.IsWeakRef)#>
<#+                 {#>
                        this.<#=element.ObjectCodeName#> = new <#=Globalize(WeakReferenceTypeName)#>(<#=ObjectCast(element.Type.ToString(), "target")#>);
<#+                 }#>
<#+                 else if (element.Type.IsDerivedFromControlTemplate())#>
<#+                 {#>
                        this.Initialize(); // Template children have been connected, initialize bindings
<#+                 }#>
<#+                 else#>
<#+                 {#>
                        this.<#=element.ObjectCodeName#> = <#=ObjectCast(element.Type.ToString(), "target")#>;
<#+                 }#>
<#+                 if (element.IsUsedByOtherScopes) #>
<#+                 { #>
                        elementWeakRefs[connectionId] = new <#=Globalize(WeakReferenceTypeName)#>(target);
                        NotifyDependentScopes(connectionId);
<#+                 } #>
<#+                 foreach (BoundEventAssignment evt in element.BoundEventAssignments)#>
<#+                 {#>
<#+                     Output_ApiInformationCall_Push(evt.ApiInformation, Indent.ThreeTabs); #>
                        this.<#=evt.EventHandlerCodeName#> = (<#=evt.Parameters.Declaration()#>) =>
                        {
<#+                     PushIndent();#>
<#+                     if (!evt.PathStep.ValueType.IsDelegate())#>
<#+                     {#>
                        <#=evt.PathStep.CodeGen().PathExpression#>;
<#+                     }#>
<#+                     else#>
<#+                     {#>
                        <#=evt.PathStep.CodeGen().PathExpression#>(<#=evt.Parameters.ForCall()#>);
<#+                     }#>
<#+                     PopIndent();#>
                        };
                        (<#=ObjectCast(element.Type.ToString(), "target")#>).<#=evt.MemberName#> += <#=evt.EventHandlerCodeName#>;
<#+                     Output_ApiInformationCall_Pop(evt.ApiInformation, Indent.ThreeTabs); #>
<#+                 }#>
<#+                 if (element.CanBeInstantiatedLater && (element.HasBindAssignments || element.HasBoundEventAssignments))#>
<#+                 {#>
<#+                     // In Connect() we update non-load assignments first, #>
<#+                     foreach (var ba in element.BindAssignments.Where(ba => !(ba is BoundLoadAssignment))) #>
<#+                     { #>
<#+                         PushIndent(Indent.TwoTabs); #>
<#+                         Output_Binding_SetValue_Non_Function_Call(ba, "this." + ba.ObjectDeferredAssignmentCodeName.CSharpName(), false); #>
<#+                         PopIndent(); #>
<#+                     } #>
<#+                 }#>
<#+                 if (element.TwoWayBindAssignments.Any()) { #>
                        this.bindingsTracking.RegisterTwoWayListener_<#=element.ConnectionId#>(<#=element.ReferenceExpression#>);
<#+                 }#>
<#+                 Output_ApiInformationCall_Pop(element.ApiInformation, Indent.ThreeTabs); #>
<#+                 } #>
<#+                 if (!element.IsBindingRoot) #>
<#+                 { #>
<#+                     // Queue load assignments to be updated later, because they're not available yet #>
<#+                     foreach (var childElem in element.Children.Intersect(bindUniverse.ElementsWithBoundLoadAssignments)) #>
<#+                     { #>
                        if (!this.UnloadedElementsToUpdate.Contains(<#=childElem.ConnectionId#>))
                        {
                            this.UnloadedElementsToUpdate.Enqueue(<#=childElem.ConnectionId#>);
                        }
<#+                     } #>
<#+                 } #>
<#+                 if (element.CanBeInstantiatedLater && element.HasRootNamedElementStep) { #>
                        this.UnloadableBindingSourcesToUpdate.Enqueue(new global::System.Action(() =>
                        {
<#+                     PushIndent(Indent.FourTabs); #>
<#+                     Output_Custom_Update_Call("this", element.RootNamedElementStep, element.RootNamedElementStep.CodeGen().PathExpression.CSharpName(), KnownStrings.NotPhased);#>
<#+                     PopIndent(); #>
                        }));
<#+                 } #>
<#+                 if (element.TryGetValidationContextStep(out PropertyStep validationStep) && ProjectInfo.IsInputValidationEnabled && ProjectInfo.EnableDefaultValidationContextGeneration) #>
<#+                 { #>
<#+                     Output_ApiInformationCall_Push(validationStep.ApiInformation, Indent.ThreeTabs); #>
                        (<#=ObjectCast(Globalize(KnownTypes.IInputValidationControl), "target")#>).ValidationContext = new <#=Globalize(KnownTypes.InputValidationContext)#>("<#=validationStep.PropertyName #>", <#=validationStep.IsValueRequired#>);
<#+                     Output_ApiInformationCall_Pop(validationStep.ApiInformation, Indent.ThreeTabs); #>
<#+                 }#>
                        break;
<#+             }#>
                    default:
                        break;
                }
<#+             }#>
            }
<#+         if (bindUniverse.NeededForOuterScopeElement) { #>

            // IComponentConnector

            <#=GeneratedCodeAttribute#>
            <#=DebuggerNonUserCodeAttribute#>
            public <#=Globalize(KnownTypes.IComponentConnector)#> GetBindingConnector(int connectionId, object target)
            {
                <#=Globalize(KnownTypes.IComponentConnector)#> returnValue = null;
<#+             if (bindUniverse.Children.Any()) #>
<#+             { #>
                switch(connectionId)
                {
<#+                 foreach (BindUniverse childUniverse in bindUniverse.Children)#>
<#+                 {#>
<#+                     ConnectionIdElement element = childUniverse.RootElement;#>
<#+                     if (element.IsBindingRoot)#>
<#+                     {#>
<#+                         PushIndent(Indent.TwoTabs); #>
<#+                         Output_GetBindingConnectorCase(element, false); #>
<#+                         PopIndent(); #>
<#+                     }#>
<#+                 }#>
                }
<#+             } #>
                return returnValue;
            }

            private global::System.Collections.Generic.Dictionary<int, global::System.Collections.Generic.List<<#=Globalize(WeakReferenceTypeName)#>>> dependentBindings =
                new global::System.Collections.Generic.Dictionary<int, global::System.Collections.Generic.List<<#=Globalize(WeakReferenceTypeName)#>>>();
            private global::System.Collections.Generic.Dictionary<int, <#=Globalize(WeakReferenceTypeName)#>> elementWeakRefs =
                new global::System.Collections.Generic.Dictionary<int, <#=Globalize(WeakReferenceTypeName)#>>();

            // I<#=Model.CodeInfo.ClassName.ShortName#>_BindingsScopeConnector

            private <#=Globalize(WeakReferenceTypeName)#> _parent;
            public <#=Globalize(WeakReferenceTypeName)#> Parent
            {
                get
                {
                    return _parent;
                }
                set
                {
                    if (_parent != value)
                    {
                        _parent = value;
                        RegisterDependenciesOnParents();
                    }
                }
            
            }
            public bool ContainsElement(int connectionId)
            {
                switch (connectionId)
                {
<#+             foreach (var element in bindUniverse.ElementsWithConnectCaseInLocalScope)#>
<#+             {#>
<#+                 if (element.IsUsedByOtherScopes) #>
<#+                 {#>
                    case <#=element.ConnectionId#>:
                        return true;
<#+                 }#>
<#+             }#>
                    default:
                        return false;
                }
            }

            public void RegisterForElementConnection(int connectionId, <#=Globalize(KnownTypes.IComponentConnector)#> connector)
            {
                global::System.Collections.Generic.List<<#=Globalize(WeakReferenceTypeName)#>> dependentsList;
                if (!dependentBindings.TryGetValue(connectionId, out dependentsList))
                {
                    dependentsList = new global::System.Collections.Generic.List<<#=Globalize(WeakReferenceTypeName)#>>();
                    dependentBindings.Add(connectionId, dependentsList);
                }

                dependentsList.Add(new <#=Globalize(WeakReferenceTypeName)#>(connector));

                NotifyDependentScope(connectionId, connector);
            }

            private void NotifyDependentScopes(int connectionId)
            {
                if (dependentBindings.ContainsKey(connectionId))
                {
                    var dependentsList = dependentBindings[connectionId];
                    foreach (<#=Globalize(WeakReferenceTypeName)#> dependent in dependentsList)
                    {
                        if (dependent.IsAlive)
                        {
                            NotifyDependentScope(connectionId, (<#=Globalize(KnownTypes.IComponentConnector)#>)dependent.Target);
                        }
                    }
                }
            }

            private void NotifyDependentScope(int connectionId, <#=Globalize(KnownTypes.IComponentConnector)#> connector)
            {
                if (elementWeakRefs.ContainsKey(connectionId) && elementWeakRefs[connectionId].IsAlive)
                {
                    connector.Connect(connectionId, elementWeakRefs[connectionId].Target);
                }
            }

            private void RegisterDependenciesOnParents()
            {
                <#=Globalize(WeakReferenceTypeName)#> currentParent = _parent;
                global::System.Collections.Generic.List<int> unresolvedDependencies = new global::System.Collections.Generic.List<int>();
<#+                 foreach (var element in bindUniverse.OuterScopeBoundElements)#>
<#+                 {#>
                unresolvedDependencies.Add(<#=element.ConnectionId#>);
<#+                 }#>

                while (unresolvedDependencies.Count > 0 && currentParent != null && currentParent.IsAlive)
                {
                    var parentBindings = (I<#=Model.CodeInfo.ClassName.ShortName#>_BindingsScopeConnector)(currentParent.Target);
                    for (int i = unresolvedDependencies.Count - 1; i >= 0; i--)
                    {
                        int unresolvedDependency = unresolvedDependencies[i];
                        if (parentBindings.ContainsElement(unresolvedDependency))
                        {
                            parentBindings.RegisterForElementConnection(unresolvedDependency, this);
                            unresolvedDependencies.RemoveAt(i);
                        }
                    }

                    currentParent = parentBindings.Parent;
                }
            }
<#+         } else { // if (bindUniverse.NeededForOuterScopeElement) #>
                        <#=GeneratedCodeAttribute#>
                        <#=DebuggerNonUserCodeAttribute#>
                        public <#=Globalize(KnownTypes.IComponentConnector)#> GetBindingConnector(int connectionId, object target) 
                        {
                            return null;
                        }
<#+                }#>
<#+             if (bindUniverse.NeedsIDataTemplateExtension) #>
<#+             {#>

            public void DataContextChangedHandler(<#=Globalize(KnownTypes.FrameworkElement)#> sender, <#=Globalize(KnownTypes.DataContextChangedEventArgs)#> args)
            {
                 if (this.SetDataRoot(args.NewValue))
                 {
                    this.Update();
                 }
            }

            // IDataTemplateExtension

            public bool ProcessBinding(uint phase)
            {
                throw new global::System.NotImplementedException();
            }

            public int ProcessBindings(<#=Globalize(KnownTypes.ContainerContentChangingEventArgs)#> args)
            {
                int nextPhase = -1;
                ProcessBindings(args.Item, args.ItemIndex, (int)args.Phase, out nextPhase);
                return nextPhase;
            }

            public void ResetTemplate()
            {
                Recycle();
            }

            // IDataTemplateComponent

            public void ProcessBindings(global::System.Object item, int itemIndex, int phase, out int nextPhase)
            {
                nextPhase = -1;
                switch(phase)
                {
                    case 0:
                        nextPhase = <#=bindUniverse.GetNextPhase(0)#>;
                        this.SetDataRoot(item);
                        if (!removedDataContextHandler)
                        {
                            removedDataContextHandler = true;
                            var rootElement = <#=bindUniverse.RootElement.ReferenceExpression#>;
                            if (rootElement != null)
                            {
                                rootElement.DataContextChanged -= this.DataContextChangedHandler;
                            }
                        }
                        this.initialized = true;
                        break;
<#+                     foreach(KeyValuePair<int, List<PhaseAssignment>> kvp in bindUniverse.PhaseAssignments.Where(kvp => kvp.Key != 0).OrderBy(kvp => kvp.Key)) #>
<#+                     { #>
                    case <#=kvp.Key#>:
<#+                         foreach(PhaseAssignment phase in kvp.Value) #>
<#+                         { #>
<#+                             if (phase.ConnectionIdElement.CanBeInstantiatedLater)#>
<#+                             {#>
                        if (<#=phase.ConnectionIdElement.ReferenceExpression#> != null)
                        {
<#+                             }#>
                        <#=Globalize(KnownTypes.XamlBindingHelper)#>.ResumeRendering(<#=phase.ConnectionIdElement.ReferenceExpression#>);
<#+                             if (phase.ConnectionIdElement.CanBeInstantiatedLater)#>
<#+                             {#>
                        }
<#+                             }#>
<#+                         } #>
                        nextPhase = <#=bindUniverse.GetNextPhase(kvp.Key)#>;
                        break;
<#+                     } #>
                }
                this.Update_(<#=ObjectCast(bindUniverse.RootStep.ValueType.ToString(), "item")#>, 1 << phase);
            }

            public void Recycle()
            {
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>
                this.bindingsTracking.ReleaseAllListeners();
<#+             }#>
<#+ foreach(KeyValuePair<int, List<PhaseAssignment>> kvp in bindUniverse.PhaseAssignments.Where(kvp => kvp.Key != 0).OrderBy(kvp => kvp.Key)) #>
<#+ { #>
<#+     foreach(PhaseAssignment phase in kvp.Value) #>
<#+     { #>
<#+         if (phase.ConnectionIdElement.CanBeInstantiatedLater)#>
<#+         {#>
                if (<#=phase.ConnectionIdElement.ReferenceExpression#> !=null)
                {
<#+                 PushIndent();#>
<#+         }#>
                <#=Globalize(KnownTypes.XamlBindingHelper)#>.SuspendRendering(<#=phase.ConnectionIdElement.ReferenceExpression#>);
<#+         if (phase.ConnectionIdElement.CanBeInstantiatedLater)#>
<#+         {#>
<#+             PopIndent();#>
                }
<#+         }#>
<#+     } #>
<#+ } #>
            }
<#+             } else if (bindUniverse.NeedsIDataTemplateComponent || ProjectInfo.ShouldGenerateDisableXBind){ //if (bindUniverse.NeedsIDataTemplateExtension)#>

            // IDataTemplateComponent

            public void ProcessBindings(global::System.Object item, int itemIndex, int phase, out int nextPhase)
            {
                nextPhase = -1;
            }

            public void Recycle()
            {
                return;
            }
<#+             }#>

            // I<#=Model.CodeInfo.ClassName.ShortName#>_Bindings

            public void Initialize()
            {
                if (!this.initialized)
                {
                    this.Update();
                }
            }
            
            public void Update()
            {
<#+             if (bindUniverse.HasBindings)#>
<#+             {#>
                this.Update_<#=bindUniverse.RootStep.CodeName#>(this.dataRoot, NOT_PHASED);
<#+             }#>
                this.initialized = true;
            }

            public void StopTracking()
            {
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>
                this.bindingsTracking.ReleaseAllListeners();
                this.initialized = false;
<#+             }#>
            }

            public void DisconnectUnloadedObject(int connectionId)
            {
<#+                 if(bindUniverse.ElementsWithDisconnectCase.Count() == 0) { #>
                throw new global::System.ArgumentException("No unloadable elements to disconnect.");
<#+                 } else { #>
                switch (connectionId)
                {
<#+                     foreach (var element in bindUniverse.ElementsWithDisconnectCase)#>
<#+                     {#>
                    case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
                    {
<#+                         if (bindUniverse.BoundElements.Contains(element)) { #>
<#+                         Output_ApiInformationCall_Push(element.ApiInformation, Indent.OneTab); #>
                        if (this.<#=element.ObjectCodeName#> != null)
                        {
<#+                         foreach (BindAssignment bindAssignment in element.BindAssignments.Where(ba => ba.HasDeferredValueProxy))#>
<#+                         {#>
                            this.<#=bindAssignment.ObjectDeferredAssignmentCodeName#> = <#=element.GetMemberGetExpression(bindAssignment)#>;
<#+                         }#>
                            this.<#=element.ObjectCodeName#> = null;
                        }
<#+                         foreach (var childElem in element.Children.Where(c => bindUniverse.ElementsWithDisconnectCase.Contains(c))) #>
<#+                         {#>
                        this.DisconnectUnloadedObject(<#=childElem.ConnectionId#>);
<#+                         }#>
<#+                         Output_ApiInformationCall_Pop(element.ApiInformation, Indent.OneTab); #>
<#+                         } #>
<#+                         if (element.HasRootNamedElementStep) { #>
                        this.UnloadableBindingSourcesToUpdate.Enqueue(new global::System.Action(() =>
                        {
<#+                             PushIndent(Indent.FourTabs); #>
<#+                             Output_Custom_Update_Call("this", element.RootNamedElementStep, "null", KnownStrings.NotPhased);#>
<#+                             PopIndent(); #>
                        }));
<#+                         } #>
                        break;
                    }
<#+                     }#>
                    default:
                    {
                        throw new global::System.ArgumentException("Invalid connectionId.");
                    }
                }
<#+                 }#>
            }
<#+         if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) #>
<#+         { #>

            private void UpdateUnloadedElement(int connectionId)
            {
                switch (connectionId)
                {
<#+             foreach (var element in bindUniverse.ElementsWithBoundLoadAssignments)#>
<#+             {#>
                    case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
                    {
<#+                 foreach (var ba in element.BindAssignments.OfType<BoundLoadAssignment>()) #>
<#+                 { #>
<#+                     PushIndent(Indent.TwoTabs); #>
<#+                     Output_Binding_SetValue_Non_Function_Call(ba, "this." + ba.ObjectDeferredAssignmentCodeName.CSharpName(), false); #>
<#+                     PopIndent(); #>
<#+                 } #>
                        break;
                    }
<#+             }#>
                    default:
                    {
                        throw new global::System.ArgumentException("Invalid connectionId.");
                    }
                }
            }
<#+         }#>

            public bool SetDataRoot(global::System.Object newDataRoot)
            {
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>
                this.bindingsTracking.ReleaseAllListeners();
<#+             }#>
                if (newDataRoot != null)
                {
                    this.dataRoot = <#=ObjectCast(bindUniverse.DataRootType.ToString(), "newDataRoot")#>;
                    return true;
                }
                return false;
            }
<#+             if (bindUniverse.RootElement.IsBindingFileRoot)#>
<#+             {#>

            public void Activated(object obj, <#=Globalize(KnownNamespaces.Xaml)#>.WindowActivatedEventArgs data)
            {
                this.Initialize();
            }

            public void Loading(<#=Globalize(KnownTypes.FrameworkElement)#> src, object data)
            {
                this.Initialize();
            }
<#+             }#>
<#+             if (bindUniverse.DistinctConvertersUsed.Count() > 0) #>
<#+             {#>

<#+                 if (Model.CodeInfo.IsResourceDictionary)#>
<#+                 {#>
            public void SetConverterLookupRoot(<#=Globalize(KnownTypes.ResourceDictionary)#> resources)
            {
                this.localResources = resources;
            }
<#+                 }#>
<#+                 else#>
<#+                 {#>
            public void SetConverterLookupRoot(<#=Globalize(KnownTypes.FrameworkElement)#> rootElement)
            {
                this.converterLookupRoot = new <#=Globalize(WeakReferenceTypeName)#><<#=Globalize(KnownTypes.FrameworkElement)#>>(rootElement);
            }
<#+                 }#>

            public <#=Globalize(KnownTypes.IValueConverter)#> LookupConverter(string key)
            {
<#+             if (!Model.CodeInfo.IsResourceDictionary)#>
<#+             {#>
                if (this.localResources == null)
                {
                    <#=Globalize(KnownTypes.FrameworkElement)#> rootElement;
                    this.converterLookupRoot.TryGetTarget(out rootElement);
                    this.localResources = rootElement.Resources;
                    this.converterLookupRoot = null;
                }
<#+             }#>
                return (<#=Globalize(KnownTypes.IValueConverter)#>) (this.localResources.ContainsKey(key) ? this.localResources[key] : <#=Globalize(KnownTypes.Application)#>.Current.Resources[key]);
            }
<#+             }#>
<#+             if (bindUniverse.HasBindings)#>
<#+             {#>
<#+                 if (bindUniverse.HasFunctionBindings)#>
<#+                 {#>
<#+                     Output_TryGetValueFunctions(bindUniverse);#>
<#+                     Output_FunctionBindings(bindUniverse);#>
<#+                 }#>
<#+                 if (bindUniverse.NeedsCompleteUpdate)#>
<#+                 {#>
<#+                     Output_CompleteUpdate(bindUniverse);#>
<#+                 }#>

            // Update methods for each path node used in binding steps.
<#+             }#>
<#+             foreach (BindPathStep bindStep in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.IsIncludedInUpdate == true))#>
<#+             {#>
            private void Update_<#=bindStep.CodeName#>(<#=GetUpdateParams(bindStep)#>)
            {
<#+                 if (bindStep.UpdateNeedsBindingsVariable || (bindStep is RootStep && bindUniverse.ElementRootStep != null)) { #>
                <#=bindUniverse.BindingsClassName#> bindings = this;
<#+                 }#>
<#+                 if (bindStep.RequiresChildNotification && (bindStep is PropertyStep || bindStep is CastStep || bindStep is RootStep || bindStep is RootNamedElementStep || bindStep is ArrayIndexStep || bindStep is MapIndexStep))#>
<#+                 {#>
                this.bindingsTracking.UpdateChildListeners_<#=bindStep.CodeName#>(obj);
<#+                 }#>
<#+                 Output_Update_Steps(bindStep.ValueType.IsNullable, "this", bindStep.Children, true, "phase");#>
<#+                 Output_Update_Steps(bindStep.ValueType.IsNullable, "this", bindStep.Dependents, false, "phase");#>
<#+                 foreach (int distinctPhase in bindStep.DistinctPhases)#>
<#+                 {#>
<#+                     Output_Binding_Phased_SetValue(distinctPhase, true, bindStep, false);#>
<#+                     Output_Binding_Phased_SetValue(distinctPhase, false, bindStep, false);#>
<#+                 }#>
<#+                 if (bindStep is RootStep) { #>
<#+                     Output_Update_Steps(false, "this", bindUniverse.BindPathSteps.Values.Where(s => s.Parent is StaticRootStep), false, "phase");#>
<#+                     if (bindUniverse.ElementRootStep != null) #>
<#+                     { #>
<#+                         Output_Update_Steps(false, "this", bindUniverse.BindPathSteps.Values.Where(s => s.Parent == bindUniverse.ElementRootStep), false, "phase");#>
<#+                     } #>
<#+                     if (bindUniverse.NeedsCompleteUpdate) { #>
                this.CompleteUpdate(phase);
<#+                     }#>
<#+                 }#>
            }
<#+             }#>
<#+             // UpdateFallback generators #>
<#+             foreach (BindPathStep bindStep in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.IsIncludedInUpdate == true))#>
<#+             {#>
<#+                 if (bindStep.Parent != null && bindStep.BindStatus.HasFlag(BindStatus.HasFallbackValue))#>
<#+                 {#>

            private void UpdateFallback_<#=bindStep.CodeName#>(int phase)
            {
<#+                     foreach (BindPathStep childStep in bindStep.Children.Concat(bindStep.Dependents))#>
<#+                     {#>
<#+                         if (childStep.BindStatus.HasFlag(BindStatus.HasFallbackValue))#>
<#+                         {#>
                this.UpdateFallback_<#=childStep.CodeName#>(phase);
<#+                         }#>
<#+                     }#>
<#+                     foreach (int distinctPhase in bindStep.DistinctPhases) #>
<#+                     {#>
<#+                         Output_Binding_Phased_Fallback_SetValue(distinctPhase, true, bindStep);#>
<#+                         Output_Binding_Phased_Fallback_SetValue(distinctPhase, false, bindStep);#>
<#+                     }#>
            }
<#+                 }#>
<#+             }#>
<#+             // UpdateTwoWay generators #>
<#+             foreach (var ba in bindUniverse.BindAssignments.Where(ba => ba.IsTrackingTarget)) { #>
<#+                 Output_UpdateTwoWay(ba); #>
<#+             } #>

<#+         if (ProjectInfo.IsInputValidationEnabled) {#>
<#+              Output_UpdateErrors(bindUniverse); #>
<#+         }#>
<#+             if (bindUniverse.NeedsBindingsTracking)#>
<#+             {#>

            <#=GeneratedCodeAttribute#>
            <#=DebuggerNonUserCodeAttribute#>
            private class <#=bindUniverse.BindingsClassName#>Tracking
            {
                private <#=Globalize(WeakReferenceTypeName)#><<#=bindUniverse.BindingsClassName#>> weakRefToBindingObj; 

                public <#=bindUniverse.BindingsClassName#>Tracking(<#=bindUniverse.BindingsClassName#> obj)
                {
                    weakRefToBindingObj = new <#=Globalize(WeakReferenceTypeName)#><<#=bindUniverse.BindingsClassName#>>(obj);
                }

                public <#=bindUniverse.BindingsClassName#> TryGetBindingObject()
                {
                    <#=bindUniverse.BindingsClassName#> bindingObject = null;
                    if (weakRefToBindingObj != null)
                    {
                        weakRefToBindingObj.TryGetTarget(out bindingObject);
                        if (bindingObject == null)
                        {
                            weakRefToBindingObj = null;
                            ReleaseAllListeners();
                        }
                    }
                    return bindingObject;
                }

                public void ReleaseAllListeners()
                {
<#+                 foreach (var step in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.NeedsUpdateChildListeners))#>
<#+                 {#>
<#+                     Output_ApiInformationCall_Push(step.ApiInformation, Indent.TwoTabs); #>
                    UpdateChildListeners_<#=step.CodeName#>(null);
<#+                     Output_ApiInformationCall_Pop(step.ApiInformation, Indent.TwoTabs); #>
<#+                 }#>
                }

<#+                 foreach (BindPathStep step in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.IsIncludedInUpdate == true))#>
<#+                 {#>
<#+                     if (step.IsTrackingSource && step.ImplementsINPC && (step is PropertyStep || step is CastStep || step is RootStep || step is RootNamedElementStep || step is ArrayIndexStep || step is MapIndexStep))#>
<#+                     {#>
                public void PropertyChanged_<#=step.CodeName#>(object sender, <#=PropertyChangedEventArgName(step)#> e)
                {
                    <#=bindUniverse.BindingsClassName#> bindings = TryGetBindingObject();
                    if (bindings != null)
                    {
                        string propName = e.PropertyName;
                        <#=step.ValueType#> obj = sender as <#=step.ValueType#>;
                        if (global::System.String.IsNullOrEmpty(propName))
                        {
<#+                         PushIndent(Indent.ThreeTabs);#>
<#+                         Output_Update_Steps(step.ValueType.IsNullable, "bindings", step.TrackingSteps, false, "DATA_CHANGED");#>
<#+                         PopIndent();#>
                        }
                        else
                        {
                            switch (propName)
                            {
<#+                         foreach (string propertyName in step.TrackingSteps.OfType<PropertyStep>().Select(p => p.PropertyName).Distinct())#>
<#+                         {#>
                                case "<#=propertyName#>":
                                {
<#+                                 PushIndent(Indent.SevenTabs);#>
<#+                                 foreach (var child in step.TrackingSteps.OfType<PropertyStep>().Where(p => p.PropertyName == propertyName)) { #>
<#+                                     Output_Update_DataChanged_Step("bindings", child);#>
<#+                                 } #>
<#+                                 PopIndent();#>
                                    break;
                                }
<#+                         }#>
<#+                         foreach (string functionName in step.TrackingSteps.OfType<FunctionStep>().Select(p => p.Method.MethodName).Distinct())#>
<#+                         {#>
                                case "<#=functionName#>":
                                {
<#+                                 PushIndent(Indent.FiveTabs);#>
<#+                                 Output_Update_Steps(step.ValueType.IsNullable, "bindings", step.TrackingSteps.OfType<FunctionStep>().Where(p => p.Method.MethodName == functionName), false, "DATA_CHANGED");#>
<#+                                 PopIndent();#>
                                    break;
                                }
<#+                         }#>
                                default:
                                    break;
                            }
                        }
<#+                         if (bindUniverse.NeedsCompleteUpdate) { #>
                        bindings.CompleteUpdate(DATA_CHANGED);
<#+                         }#>
                    }
                }
<#+                     }#>
<#+                     if (step.IsTrackingSource && (step is PropertyStep || step is CastStep || step is RootStep || step is RootNamedElementStep) && step.ImplementsINCC && !step.ImplementsIObservableVector && !step.ImplementsIObservableMap)#>
<#+                     {#>
                public void CollectionChanged_<#=step.CodeName#>(object sender, <#=NotifyCollectionChangedEventArgName(step)#> e)
                {
                    <#=bindUniverse.BindingsClassName#> bindings = TryGetBindingObject();
                    if (bindings != null)
                    {
                        <#=step.ValueType#> obj = sender as <#=step.ValueType#>;
<#+                     Output_Update_Steps(step.ValueType.IsNullable, "bindings", step.TrackingSteps, false, "DATA_CHANGED");#>
<#+                     if (bindUniverse.NeedsCompleteUpdate) { #>
                        bindings.CompleteUpdate(DATA_CHANGED);
<#+                     }#>
                    }
                }
<#+                     }#>

<#+                     if (step.IsTrackingSource && (step is PropertyStep || step is CastStep || step is RootStep) && step.ImplementsIObservableVector)#>
<#+                     {#>
                public void VectorChanged_<#=step.CodeName#>(global::Windows.Foundation.Collections.IObservableVector<<#=step.ValueType.ItemType#>> sender, global::Windows.Foundation.Collections.IVectorChangedEventArgs e)
                {
                    <#=bindUniverse.BindingsClassName#> bindings = TryGetBindingObject();
                    if (bindings != null)
                    {
                        <#=step.ValueType#> obj = sender as <#=step.ValueType#>;
<#+                         Output_Update_Steps(step.ValueType.IsNullable, "bindings", step.TrackingSteps, false, "DATA_CHANGED");#>
<#+                         if (bindUniverse.NeedsCompleteUpdate) { #>
                        bindings.CompleteUpdate(DATA_CHANGED);
<#+                         }#>
                    }
                }
<#+                     }#>

<#+                     if (step.IsTrackingSource && (step is PropertyStep || step is CastStep || step is RootStep) && step.ImplementsIObservableMap)#>
<#+                     {#>
                public void MapChanged_<#=step.CodeName#>(global::Windows.Foundation.Collections.IObservableMap<string, <#=step.ValueType.ItemType#>> sender, global::Windows.Foundation.Collections.IMapChangedEventArgs<string> e)
                {
                    <#=bindUniverse.BindingsClassName#> bindings = TryGetBindingObject();
                    if (bindings != null)
                    {
                        <#=step.ValueType#> obj = sender as <#=step.ValueType#>;
<#+                         Output_Update_Steps(step.ValueType.IsNullable, "bindings", step.TrackingSteps, false, "DATA_CHANGED");#>
<#+                         if (bindUniverse.NeedsCompleteUpdate) { #>
                        bindings.CompleteUpdate(DATA_CHANGED);
<#+                         }#>
                    }
                }
<#+                     }#>

<#+                     foreach (DependencyPropertyStep child in step.TrackingSteps.OfType<DependencyPropertyStep>())#>
<#+                     {#>
                public void DependencyPropertyChanged_<#=child.CodeName#>(<#=Globalize(KnownTypes.DependencyObject)#> sender, <#=Globalize(KnownTypes.DependencyProperty)#> prop)
                {
                    <#=bindUniverse.BindingsClassName#> bindings = TryGetBindingObject();
                    if (bindings != null)
                    {
                        <#=step.ValueType#> obj = sender as <#=step.ValueType#>;
<#+                         PushIndent(Indent.FourTabs);#>
<#+                         Output_Update_DataChanged_Step("bindings", child);#>
<#+                         PopIndent();#>
<#+                         if (bindUniverse.NeedsCompleteUpdate) { #>
                        bindings.CompleteUpdate(DATA_CHANGED);
<#+                         }#>
                    }
                }
<#+                     }#>
<#+                     if (step.IsTrackingSource && step.ImplementsINDEI && ProjectInfo.IsInputValidationEnabled)#>
<#+                     {#>

                public void ErrorsChanged_<#=step.CodeName#>(object sender, <#=DataErrorsEventArgName(step)#> e) 
                {
                   <#=bindUniverse.BindingsClassName#> bindings = TryGetBindingObject();
                   if (bindings != null)
                   {
                        string propName = e.PropertyName;
                        if (global::System.String.IsNullOrEmpty(propName))
                        {
<#+                 foreach (var propertyStep in step.TrackingSteps.OfType<PropertyStep>())#>
<#+                 {#>
<#+                         Output_ApiInformationCall_Push(propertyStep.ApiInformation, Indent.FourTabs);#>
                            bindings.UpdateErrors_<#=step.CodeName#>((<#=INDEIInterfaceName(step)#>)sender, "<#= propertyStep.PropertyName #>");
<#+                         Output_ApiInformationCall_Pop(propertyStep.ApiInformation, Indent.FourTabs);#>
<#+                 }#>
                        }
                        else
                        {
<#+                         Output_ApiInformationCall_Push(step.ApiInformation, Indent.FourTabs);#>
                            bindings.UpdateErrors_<#=step.CodeName#>((<#=INDEIInterfaceName(step)#>)sender, propName);
<#+                         Output_ApiInformationCall_Pop(step.ApiInformation, Indent.FourTabs);#>
                        }
                    }
                }
<#+                      }#>
<#+                     // Register & unregister change notification generators #>
<#+                     Output_UpdateChildListeners(step, bindUniverse);#>
<#+                 }#>
<#+                 foreach (var e in bindUniverse.BoundElements.Where(e => e.TwoWayBindAssignments.Any())) { #>
<#+                     PushIndent(Indent.TwoTabs); #>
<#+                     Output_RegisterTwoWayListeners(e); #>
<#+                     PopIndent(); #>
<#+                 } #>
<#+ //End of _BindingsTracking class #>
            }
<#+             }#>
<#+ //End of bindings class #>
        }
<#+         }#>
<#+     }#>

<#+ #>
<#+     private void Output_UpdateChildListeners(BindPathStep step, BindUniverse bindUniverse)#>
<#+     {#>
<#+         if (step.NeedsUpdateChildListeners)#>
<#+         {#>
<#+             string cacheName = "bindings.dataRoot"; #>
<#+                     if (!(step is RootStep))#>
<#+                     {#>
                private <#=step.ValueType#> cache_<#=step.CodeName#> = null;
<#+                 cacheName="cache_" +step.CodeName;#>
<#+                     }#>
<#+                     foreach (DependencyPropertyStep child in step.TrackingSteps.OfType<DependencyPropertyStep>())#>
<#+                     {#>
                private long tokenDPC_<#=child.CodeName#> = 0;
<#+                     }#>
<#+                     if (step.RequiresChildNotification)#>
<#+                     {#>
                public void UpdateChildListeners_<#=step.CodeName#>(<#=step.ValueType#> obj)
                {
<#+                 if (!(step is RootStep))#>
<#+                 {#>
                    if (obj != <#=cacheName#>)
                    {
                        if (<#=cacheName#> != null)
<#+                 }#>
<#+                 else#>
<#+                 {#>
                    <#=bindUniverse.BindingsClassName#> bindings = TryGetBindingObject();
                    if (bindings != null)
                    {
                        if (<#=cacheName#> != null)
<#+                 }#>
                        {
<#+                         if (step.ImplementsINPC)#>
<#+                         {#>
                            ((<#=INPCInterfaceName(step)#>)<#=cacheName#>).PropertyChanged -= PropertyChanged_<#=step.CodeName#>;
<#+                         }#>
<#+                         if (step.ImplementsINDEI && ProjectInfo.IsInputValidationEnabled)#>
<#+                         {#>
                            ((<#=INDEIInterfaceName(step)#>)<#=cacheName#>).ErrorsChanged -= ErrorsChanged_<#=step.CodeName#>;
<#+                         }#>
<#+                         if (step.ImplementsIObservableVector)#>
<#+                         {#>
                            ((global::Windows.Foundation.Collections.IObservableVector<<#=step.ValueType.ItemType#>>)<#=cacheName#>).VectorChanged -= VectorChanged_<#=step.CodeName#>;
<#+                         }#>
<#+                         if (step.ImplementsIObservableMap)#>
<#+                         {#>
                            ((global::Windows.Foundation.Collections.IObservableMap<string, <#=step.ValueType.ItemType#>>)<#=cacheName#>).MapChanged -= MapChanged_<#=step.CodeName#>;
<#+                         }#>
<#+                         else if (step.ImplementsINCC)#>
<#+                         {#>
                            ((<#=INCCInterfaceName(step)#>)<#=cacheName#>).CollectionChanged -= CollectionChanged_<#=step.CodeName#>;
<#+                         }#>
<#+                         foreach (DependencyPropertyStep child in step.TrackingSteps.OfType<DependencyPropertyStep>())#>
<#+                         {#>
                            <#=cacheName#>.UnregisterPropertyChangedCallback(<#=child.OwnerType#>.<#=child.PropertyName#>Property, tokenDPC_<#=child.CodeName#>);
<#+                         }#>
<#+                     if (!(step is RootStep))#>
<#+                     {#>
                            <#=cacheName#> = null;
<#+                     }#>
                        }
                        if (obj != null)
                        {
                            <#=cacheName#> = obj;
<#+                     if (step.ImplementsINPC)#>
<#+                     {#>
                            ((<#=INPCInterfaceName(step)#>)obj).PropertyChanged += PropertyChanged_<#=step.CodeName#>;
<#+                     }#>
<#+                     if (step.ImplementsINDEI && ProjectInfo.IsInputValidationEnabled)#>
<#+                     {#>
                            ((<#=INDEIInterfaceName(step)#>)<#=cacheName#>).ErrorsChanged += ErrorsChanged_<#=step.CodeName#>;
<#+                     }#>
<#+                     if (step.ImplementsIObservableVector)#>
<#+                     {#>
                            ((global::Windows.Foundation.Collections.IObservableVector<<#=step.ValueType.ItemType#>>)obj).VectorChanged += VectorChanged_<#=step.CodeName#>;
<#+                     }#>
<#+                     if (step.ImplementsIObservableMap)#>
<#+                     {#>
                            ((global::Windows.Foundation.Collections.IObservableMap<string, <#=step.ValueType.ItemType#>>)obj).MapChanged += MapChanged_<#=step.CodeName#>;
<#+                     }#>
<#+                     else if (step.ImplementsINCC)#>
<#+                     {#>
                            ((<#=INCCInterfaceName(step)#>)obj).CollectionChanged += CollectionChanged_<#=step.CodeName#>;
<#+                     }#>
<#+                     foreach (DependencyPropertyStep child in step.TrackingSteps.OfType<DependencyPropertyStep>())#>
<#+                     {#>
                            tokenDPC_<#=child.CodeName#> = obj.RegisterPropertyChangedCallback(<#=child.OwnerType#>.<#=child.PropertyName#>Property, DependencyPropertyChanged_<#=child.CodeName#>);
<#+                     }#>
                        }
                    }
                }
<#+                     }#>
<#+         }#>
<#+     }#>

<#+ private void Output_RegisterTwoWayListeners(ConnectionIdElement element)#>
<#+ {#>
        public void RegisterTwoWayListener_<#=element.ConnectionId#>(<#=element.Type#> sourceObject)
        {
<#+     foreach (var ba in element.TwoWayBindAssignments) { #>
<#+         Output_ApiInformationCall_Push(ba.ApiInformation, Indent.None); #>
<#+         if (ba.NeedsLostFocusForTwoWay) { #>
            sourceObject.LostFocus += (sender, e) =>
            {
<#+         } else { #>
            sourceObject.RegisterPropertyChangedCallback(<#=ba.MemberDeclaringType#>.<#=ba.MemberName#>Property, (sender, prop) =>
            {
<#+         }#>
                var bindingObj = this.TryGetBindingObject();
                if (bindingObj != null)
                {
                    bindingObj.UpdateTwoWay_<#=element.ConnectionId#>_<#=ba.MemberName#>();
                }
            }<#=ba.NeedsLostFocusForTwoWay ? ";" : ");" #>
<#+         Output_ApiInformationCall_Pop(ba.ApiInformation, Indent.None); #>
<#+     } #>
        }
<#+ } #>

<#+ private void Output_UpdateTwoWay(BindAssignment ba)#>
<#+ {#>
            private void UpdateTwoWay_<#=ba.ConnectionIdElement.ConnectionId#>_<#=ba.MemberName#>()
            {
                if (this.initialized)
                {
<#+             MethodStep bindBackStep = ba.BindBackStep as MethodStep; #>
<#+             if (bindBackStep != null)#>
<#+             {#>
<#+                 var param = bindBackStep.Parameters[0]; #>
                    <#=ba.MemberType#> <#=param.Name#> = <#=ba.ReverseAssignmentExpression#>;
<#+                 Output_NullCheckedAssignment(bindBackStep, null);#>
<#+             }#>
<#+             else#>
<#+             {#>
<#+                 Output_NullCheckedAssignment(ba.PathStep, ba.ReverseAssignmentExpression);#>
<#+             }#>
                }
            }
<#+ } #>

<#+ void  Output_NullCheckedAssignment(BindPathStep step, LanguageSpecificString value) #>
<#+ { #>
<#+     PushIndent(Indent.TwoTabs);#>
<#+     foreach (var parent in step.Parents.Where(parent => parent.NeedsCheckForNull)) { #>
            if (<#=parent.CodeGen().PathExpression#> != null)
            {
<#+         PushIndent(); #>
<#+     } #>
<#+     if (value != null) { #>
            <#=step.CodeGen().PathSetExpression(value)#>;
<#+     } else { #>
            <#=step.CodeGen().PathExpression#>;
<#+     } #>
<#+     foreach (var parent in step.Parents.Where(parent => parent.NeedsCheckForNull)) { #>
<#+         PopIndent(); #>
            }
<#+     } #>
<#+     PopIndent();#>
<#+ } #>

<#+ void Output_UpdateErrors(BindUniverse bindUniverse) #>
<#+ { #>
<#+     var twoWayWithIndeiSteps =  bindUniverse.INDEIPathSteps; #>
<#+     if (twoWayWithIndeiSteps.Any(step => step.ValueType.ImplementsXamlINotifyDataErrorInfo())) { #>
<#+     PushIndent(Indent.TwoTabs);#>
    private void UpdateErrors_(<#=Globalize(KnownTypes.Control)#> control, <#=Globalize(KnownTypes.XamlINotifyDataErrorInfo)#> sender, string propertyName)
    {
        UpdateInputValidationErrors(control, sender.GetErrors(propertyName));
    }
<#+     PopIndent();#>

<#+     }#> 
<#+     if (twoWayWithIndeiSteps.Any(step => step.ImplementsINDEI && !step.ValueType.ImplementsXamlINotifyDataErrorInfo())) { #>
<#+     PushIndent(Indent.TwoTabs);#>
    private void UpdateErrors_(<#=Globalize(KnownTypes.Control)#> control, global::System.ComponentModel.INotifyDataErrorInfo sender, string propertyName)
    {
        UpdateInputValidationErrors(control, sender.GetErrors(propertyName));
    }
<#+     PopIndent();#>

<#+     }#>
<#+     if (twoWayWithIndeiSteps.Any()) { #>
<#+     PushIndent(Indent.TwoTabs);#>
    private void UpdateInputValidationErrors(<#=Globalize(KnownTypes.Control)#> control, global::System.Collections.IEnumerable modelErrors)
    {
        var validationControl = control as <#=Globalize(KnownTypes.IInputValidationControl)#>;
        if (validationControl != null)
        {
            var inputValidationErrors = validationControl.ValidationErrors;
			inputValidationErrors.Clear();

            foreach (var error in modelErrors)
            {
                var validationError = error as <#=Globalize(KnownTypes.InputValidationError)#>;
                if (validationError == null)
                {
                    validationError = new <#=Globalize(KnownTypes.InputValidationError)#>(error.ToString());
                }
                inputValidationErrors.Add(validationError);
            }
        }

    }
<#+     PopIndent();#>

<#+     PushIndent(Indent.TwoTabs);#>
<#+     foreach (BindPathStep step in twoWayWithIndeiSteps)#>
<#+     {#>
    private void UpdateErrors_<#=step.CodeName#>(<#=INDEIInterfaceName(step)#> sender, string propertyName)
    {
        if (this.initialized)
        {
            switch (propertyName)
            {
<#+         foreach (string propertyName in step.TrackingSteps.OfType<PropertyStep>().Select(p => p.PropertyName).Distinct())#>
<#+         {#>
                case "<#=propertyName#>":
                {
<#+                 PushIndent(Indent.ThreeTabs);#>
<#+                 foreach (var child in step.TrackingSteps.OfType<PropertyStep>().Where(p => p.PropertyName == propertyName)) { #>
<#+                     Output_UpdateErrorsCall(child);#>
<#+                 } #>
<#+                 PopIndent();#>
                    break;
                }
<#+         }#>
                default:
                    break;
            }
        }
    }
<#+     }#>
<#+     PopIndent();#>
<#+     } #>
<#+ } #>

<#+ void Output_UpdateErrorsCall(PropertyStep step) #>
<#+ { #>
<#+  foreach (var ba in step.AssociatedBindAssignments.Where(ba => ba.IsTrackingTarget)){#>
        UpdateErrors_(<#=(ba as BindAssignmentBase).ConnectionIdElement.ObjectCodeName #>, sender, "<#= step.PropertyName #>");
<#+  }#>
<#+ }#>

<#+     private void Output_Binding_SetValue_Function(BindAssignment ba)#>
<#+     {#>
<#+         if (ba.MemberType.IsNullable)#>
<#+         {#>
            public static void Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(<#=ba.MemberTargetType#> obj, <#=ba.MemberType#> value, string targetNullValue)
            {
                if (value == null && targetNullValue != null)
                {
<#+             if (ba.MemberType.IsString())#>
<#+             {#>
                    value = targetNullValue;
<#+             }#>
<#+             else#>
<#+             {#>
                    value = <#=ba.MemberType.GetStringToThing("targetNullValue")#>;
<#+             }#>
                }
<#+         }#>
<#+         else#>
<#+         {#>
            public static void Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(<#=ba.MemberTargetType#> obj, <#=ba.MemberType#> value)
            {
<#+         }#>
<#+         if (ba.IsAttachable)#>
<#+         {#>
                <#=ba.MemberDeclaringType#>.Set<#=ba.MemberName#>(obj, value);
<#+         }#>
<#+         else if (ba.MemberType.IsString())#>
<#+         {#>
<#+             // We cannot pass null .Net types to WinRT, so we decided to "fix" them to match what CX does. #>
                obj.<#=ba.MemberName#> = value ?? global::System.String.Empty;
<#+         }#>
<#+         else#>
<#+         {#>
                obj.<#=ba.MemberName#> = value;
<#+         }#>
            }
<#+     }#>

<#+ private void Output_Binding_Phased_SetValue(int phase, bool isTracking, BindPathStep bindStep, bool isFunctionResult)#>
<#+ {#>
<#+     var matchingBindAssignments = from ba in bindStep.BindAssignments where ba.ComputedPhase == phase && ba.IsTrackingSource == isTracking select ba;#>
<#+     if (matchingBindAssignments.Count() > 0)#>
<#+     {#>
<#+         string condition =  GetDirectPhaseCondition(phase, isTracking); #>
                if (<#=condition#>)
                {
<#+         PushIndent();#>
<#+         foreach (BindAssignment bindAssignment in matchingBindAssignments)#>
<#+         {#>
<#+             Output_Binding_SetValue(bindAssignment, isFunctionResult);#>
<#+         }#>
<#+         PopIndent();#>
                }
<#+     }#>
<#+ }#>

<#+ private void Output_Binding_Phased_Fallback_SetValue(int phase, bool isTracking, BindPathStep bindStep)#>
<#+ {#>
<#+     var matchingBindAssignments = from ba in bindStep.BindAssignments where ba.ComputedPhase == phase && ba.IsTrackingSource == isTracking && ba.BindStatus.HasFlag(BindStatus.HasFallbackValue) select ba;#>
<#+     if (matchingBindAssignments.Count() > 0)#>
<#+     {#>
<#+         string condition =  GetDirectPhaseCondition(phase, isTracking); #>
                if (<#=condition#>)
                {
<#+         PushIndent();#>
<#+         foreach (BindAssignment bindAssignment in matchingBindAssignments)#>
<#+         {#>
<#+             Output_Binding_SetValue_Non_Function_Call(bindAssignment, bindAssignment.FallbackValueExpression.CSharpName(), true);#>
<#+         }#>
<#+         PopIndent();#>
                }
<#+     }#>
<#+ }#>

<#+     private void Output_Binding_SetValue(BindAssignment bindAssignment, bool isFunctionResult)#>
<#+     {#>
<#+         if (bindAssignment.PathStep is FunctionStep && !isFunctionResult)#>
<#+         {#>
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>
                if (!<#=bindAssignment.DisableFlagName#>)
                {
<#+                 PushIndent();#>
<#+             }#>
                this.PendingFunctionBindings["<#=bindAssignment.PathStep.CodeName#>"] = new InvokeFunctionDelegate(this.Invoke_<#=bindAssignment.PathStep.CodeName#>); 
<#+             if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+             {#>
<#+                 PopIndent();#>
                }
<#+             }#>
<#+         }#>
<#+         else#>
<#+         {#>
<#+             string value = bindAssignment.DirectAssignmentExpression(isFunctionResult ? "result" : "obj").CSharpName();#>
<#+             Output_Binding_SetValue_Non_Function_Call(bindAssignment, value, true);#>
<#+         }#>
<#+     }#>

<#+     private void Output_Binding_SetValue_Non_Function_Call(BindAssignment bindAssignment, string value, bool includeDeferredSet)#>
<#+     {#>
<#+         ConnectionIdElement element = bindAssignment.ConnectionIdElement;#>
<#+         string objRef = element.ReferenceExpression.CSharpName();#>
                // <#=element.LineNumberAndXamlFile#>
<#+         if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+         {#>
                if (!<#=bindAssignment.DisableFlagName#>)
                {
<#+             PushIndent();#>
<#+         }#>
<#+         Output_ApiInformationCall_Push(bindAssignment.ApiInformation, Indent.OneTab); #>
<#+         if (bindAssignment is BoundLoadAssignment) { #>
<#+             if (includeDeferredSet) { #>
                this.<#=bindAssignment.ObjectDeferredAssignmentCodeName#> = <#=value#>;

<#+             }#>
                if (<#=value#>)
                {
<#+             if (bindAssignment.BindUniverse.IsFileRoot) { #>
                    dataRoot.FindName("<#=element.ElementName#>");
<#+             } else { #>
                    <#=bindAssignment.BindUniverse.RootElement.ReferenceExpression#>.FindName("<#=element.ElementName#>");
<#+             }#>
                }
                else
                {
<#+             if (bindAssignment.BindUniverse.IsFileRoot) { #>
                    dataRoot.UnloadObject(<#=objRef#>);
<#+             } else { #>
                    if (<#=objRef#> != null) 
                    {
                        <#=Globalize(KnownTypes.XamlMarkupHelper)#>.UnloadObject(<#=objRef#>);
                    }
                    this.DisconnectUnloadedObject(<#=element.ConnectionId#>);
<#+             }#>
                }
<#+         } else { #>
<#+             if (element.NeedsNullCheckBeforeSetValue) { #>
                if (<#=objRef#> != null)
                {
<#+                 PushIndent();#>
<#+             }#>
<#+             if (bindAssignment.MemberType.IsNullable) { #>
                XamlBindingSetters.Set_<#=bindAssignment.MemberDeclaringType.MemberFriendlyName()#>_<#=bindAssignment.MemberName#>(<#=objRef#>, <#=value#>, <#=bindAssignment.TargetNullValueExpression#>);
<#+             } else {#>
                XamlBindingSetters.Set_<#=bindAssignment.MemberDeclaringType.MemberFriendlyName()#>_<#=bindAssignment.MemberName#>(<#=objRef#>, <#=value#>);
<#+             }#>
<#+             if (element.NeedsNullCheckBeforeSetValue) { #>
<#+                 PopIndent();#>
                }
<#+                 if (includeDeferredSet && element.CanBeInstantiatedLater) { #>
                else
                {
                    this.<#=bindAssignment.ObjectDeferredAssignmentCodeName#> = <#=value#>;
                }
<#+                 }#>
<#+             }#>
<#+         }#>
<#+         Output_ApiInformationCall_Pop(bindAssignment.ApiInformation, Indent.OneTab); #>
<#+         if (ProjectInfo.ShouldGenerateDisableXBind) #>
<#+         {#>
<#+             PopIndent();#>
                }
<#+         }#>
<#+     }#>

<#+ private void Output_Update_DataChanged_Step(string context, BindPathStep step)#>
<#+ {#>
<#+     if (step.Parent.ValueType.IsNullable) #>
<#+     {#>
        if (obj != null)
        {
<#+     }#>
<#+     Output_UpdateCall(context, step, KnownStrings.DataChanged);#>
<#+     if (step.Parent.ValueType.IsNullable) #>
<#+     {#>
        }
<#+     }#>
<#+     if (step.BindStatus.HasFlag(BindStatus.HasFallbackValue)) #>
<#+     {#>
        else
        {
            <#=context#>.UpdateFallback_<#=step.CodeName#>(DATA_CHANGED);
        }
<#+     }#>
<#+ }#>

<#+ private void Output_Update_Steps(bool checkForNull, string context, IEnumerable<BindPathStep> steps, bool checkPhaseCondition, string phaseParam)#>
<#+ {#>
<#+     if (steps.Count() > 0) #>
<#+     {#>
<#+         PushIndent();#>
<#+         if (checkForNull)#>
<#+         {#>
<#+             PushIndent();#>
        if (obj != null)
        {
<#+         }#>
<#+         List<BindPathStep> stepsWithFallback = new List<BindPathStep>();#>
<#+         string lastCondition = null;#>
<#+         foreach (BindPathStep childStep in (from step in steps where step.IsIncludedInUpdate orderby step.PhaseList select step))#>
<#+         {#>
<#+             if(checkPhaseCondition)#>
<#+             {#>
<#+                 string thisCondition = GetPhaseCondition(childStep);#>
<#+                 if (thisCondition != lastCondition)#>
<#+                 {#>
<#+                     if (lastCondition != null)#>
<#+                     {#>
            }
<#+                     }#>
<#+                     lastCondition = thisCondition;#>
            if (<#=thisCondition#>)
            {
<#+                 }#>
<#+                 PushIndent();#>
<#+                 Output_UpdateCall(context, childStep, phaseParam);#>
<#+                 PopIndent();#>
<#+             }#>
<#+             else#>
<#+             {#>
<#+                 if (lastCondition != null)#>
<#+                 {#>
            }
<#+                 }#>
<#+                 lastCondition = null;#>
<#+                 Output_UpdateCall(context, childStep, phaseParam);#>
<#+             }#>
<#+             if (childStep.BindStatus.HasFlag(BindStatus.HasFallbackValue))#>
<#+             {#>
<#+               stepsWithFallback.Add(childStep);#>
<#+             }#>
<#+         }#>
<#+                 if (lastCondition != null)#>
<#+                 {#>
            }
<#+                 }#>
<#+         if (checkForNull) #>
<#+         {#>
        }
<#+             if (stepsWithFallback.Count > 0) #>
<#+             {#>
        else
        {
<#+                 foreach (BindPathStep childStep in stepsWithFallback)#>
<#+                 {#>
<#+                     if(checkPhaseCondition)#>
<#+                     {#>
            if (<#=GetPhaseCondition(childStep)#>)
            {
                <#=context#>.UpdateFallback_<#=childStep.CodeName#>(<#=phaseParam#>);
            }
<#+                     }#>
<#+                     else#>
<#+                     {#>
            <#=context#>.UpdateFallback_<#=childStep.CodeName#>(<#=phaseParam#>);
<#+                     }#>
<#+                 }#>
        }
<#+             }#>
<#+             PopIndent();#>
<#+         }#>
<#+         PopIndent();#>
<#+     }#>
<#+ }#>

<#+ private string GetUpdateParams(BindPathStep bindStep)#>
<#+ {#>
<#+     if (bindStep is FunctionStep)#>
<#+     {#>
<#+         return "int phase";#>
<#+     }#>
<#+     else#>
<#+     {#>
<#+         return bindStep.ValueType.CSharpName() + " obj, int phase";#>
<#+     }#>
<#+ }#>

<#+ private void Output_Custom_Update_Call(string context, BindPathStep step, string firstArgument, string phaseParam)#>
<#+ {#>
<#+     if (string.IsNullOrEmpty(firstArgument))#>
<#+     {#>
            <#=context#>.Update_<#=step.CodeName#>(<#=phaseParam#>);
<#+     }#>
<#+     else#>
<#+     {#>
<#+         Output_ApiInformationCall_Push(step.ApiInformation, Indent.None);#>
            <#=context#>.Update_<#=step.CodeName#>(<#=firstArgument#>, <#=phaseParam#>);
<#+         Output_ApiInformationCall_Pop(step.ApiInformation, Indent.None);#>
<#+     }#>
<#+ }#>

<#+ private void Output_UpdateCall(string context, BindPathStep step, string phaseParam)#>
<#+ {#>
<#+     string firstArgument = step.CodeGen().UpdateCallParam.CSharpName(); #>
<#+     Output_Custom_Update_Call(context, step, firstArgument, phaseParam); #>
<#+ }#>

<#+ private void Output_CompleteUpdate(BindUniverse bindUniverse)#>
<#+ {#>
<#+     List<string> conditions = new List<string>();#>
<#+     bool needsLoop = bindUniverse.UnloadableBindingSourceElements.Any(); #>

            private void CompleteUpdate(int phase)
            {
<#+     if (needsLoop) { #>
                do
                {
<#+         PushIndent(); #>
<#+     } #>
<#+     if (bindUniverse.HasFunctionBindings) {#>
                var functions = this.PendingFunctionBindings;
                this.PendingFunctionBindings = new global::System.Collections.Generic.Dictionary<string, InvokeFunctionDelegate>();
                foreach (var function in functions.Values)
                {
                    function.Invoke(phase);
                }
<#+         conditions.Add("this.PendingFunctionBindings.Count > 0"); #>
<#+     } #>
<#+     if (bindUniverse.UnloadableBindingSourceElements.Any()) {#>
                while (this.UnloadableBindingSourcesToUpdate.Count > 0)
                {
                    this.UnloadableBindingSourcesToUpdate.Dequeue()();
                }
<#+         conditions.Add("this.UnloadableBindingSourcesToUpdate.Count > 0"); #>
<#+     } #>
<#+     if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) {#>
                while (this.UnloadedElementsToUpdate.Count > 0)
                {
                    this.UpdateUnloadedElement(this.UnloadedElementsToUpdate.Dequeue());
                }
<#+         conditions.Add("this.UnloadedElementsToUpdate.Count > 0"); #>
<#+     } #>
<#+     if (needsLoop) { #>
<#+         PopIndent(); #>
                }
                while (<#=string.Join(" || ", conditions)#>);
<#+     } #>
            }
<#+ } #>

<#+ private void Output_FunctionBindings(BindUniverse bindUniverse)#>
<#+ {#>

            private delegate void InvokeFunctionDelegate(int phase);
            private global::System.Collections.Generic.Dictionary<string, InvokeFunctionDelegate> PendingFunctionBindings = new global::System.Collections.Generic.Dictionary<string, InvokeFunctionDelegate>();
<#+     foreach (FunctionStep functionStep in bindUniverse.BindPathSteps.Values.Where(s => s is FunctionStep))#>
<#+     {#>

            private void Invoke_<#=functionStep.CodeName#>(int phase)
            {
<#+         foreach (var param in functionStep.Parameters.OrderBy(p => p.HasTryGetValue)) {#>
<#+             if (param.HasTryGetValue && functionStep.RequiresSafeParameterRetrieval) {#>
                <#=param.AssignmentType#> <#=param.Name#>;
                if (!<#=param.TryGetValueCodeName#>(out <#=param.Name#>)) { return; }
<#+             } else {#>
                <#=param.ValueType#> <#=param.Name#> = <#=param.CodeGen().PathExpression#>;
<#+             }#>
<#+         }#>
                <#=functionStep.ValueType#> result = <#= functionStep.CodeGen().PathExpression #>;
<#+         foreach (int distinctPhase in functionStep.DistinctPhases) {#>
<#+             Output_Binding_Phased_SetValue(distinctPhase, true, functionStep, true);#>
<#+             Output_Binding_Phased_SetValue(distinctPhase, false, functionStep, true);#>
<#+         }#>
            }
<#+     }#>
<#+ }#>

<#+ private void Output_TryGetValueFunctions(BindUniverse bindUniverse)#>
<#+ {#>
<#+     foreach (BindPathStep step in bindUniverse.TryGetValueSteps)#>
<#+     {#>

            private bool <#=step.TryGetValueCodeName#>(out <#=step.ValueType#> val)
            {
<#+         if (step is RootStep || !step.Parent.IsIncludedInUpdate) {#>
                val = <#=step.CodeGen().PathExpression#>;
                return true;
<#+         }#>
<#+         else {#>
                <#=step.Parent.ValueType#> obj;
<#+             if (step.Parent.ValueType.IsNullable) {#>
                if (<#=step.Parent.TryGetValueCodeName#>(out obj) && obj != null)
<#+             } else { #>
                if (<#=step.Parent.TryGetValueCodeName#>(out obj))
<#+             } #>
                {
                    val = <#=step.CodeGen().UpdateCallParam#>;
                    return true;
                }
                else
                {
                    val = default(<#=step.ValueType#>);
                    return false;
                }
<#+         }#>
            }
<#+     }#>
<#+ }#>

<#+ private void Output_ApiInformationCall_Push(ApiInformation apiInformation, Indent indent)#>
<#+ {#>
<#+     if (apiInformation != null) { #>
<#+         PushIndent(indent); #>
            if (<#=Model.CodeInfo.ClassName.ShortName#>.<#= apiInformation.MemberFriendlyName #>)
            {
<#+         PopIndent(); #>
<#+         PushIndent(); #>
<#+     } #>
<#+ } #>

<#+ private void Output_ApiInformationCall_Pop(ApiInformation apiInformation, Indent indent)#>
<#+ {#>
<#+     if (apiInformation != null) { #>
<#+         PopIndent(); #>
<#+         PushIndent(indent); #>
            }
<#+         PopIndent(); #>
<#+     } #>
<#+ } #>

<#+ private void Output_ApiInformationDeclarations()#>
<#+ {#>
<#+     if (Model.ApiInformationDeclarations.Any()) { #>

        // Api Information for conditional namespace declarations
<#+     } #>
<#+     foreach (var apiInformation in Model.ApiInformationDeclarations) { #>
        internal static bool <#= apiInformation.MemberFriendlyName #> = <#= apiInformation.CodeGen().CallExpression #>;
<#+     } #>
<#+ } #>