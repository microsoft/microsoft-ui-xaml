// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.

// DO NOT EDIT! This file was generated by CustomTasks.DependencyPropertyCodeGen
#include "pch.h"
#include "common.h"
#include "AcrylicBrush.h"

GlobalDependencyProperty AcrylicBrushProperties::s_AlwaysUseFallbackProperty{ nullptr };
GlobalDependencyProperty AcrylicBrushProperties::s_BackgroundSourceProperty{ nullptr };
GlobalDependencyProperty AcrylicBrushProperties::s_TintColorProperty{ nullptr };
GlobalDependencyProperty AcrylicBrushProperties::s_TintLuminosityOpacityProperty{ nullptr };
GlobalDependencyProperty AcrylicBrushProperties::s_TintOpacityProperty{ nullptr };
GlobalDependencyProperty AcrylicBrushProperties::s_TintTransitionDurationProperty{ nullptr };

AcrylicBrushProperties::AcrylicBrushProperties()
{
    EnsureProperties();
}

void AcrylicBrushProperties::EnsureProperties()
{
    if (!s_AlwaysUseFallbackProperty)
    {
        s_AlwaysUseFallbackProperty =
            InitializeDependencyProperty(
                L"AlwaysUseFallback",
                winrt::name_of<bool>(),
                winrt::name_of<winrt::AcrylicBrush>(),
                false /* isAttached */,
                ValueHelper<bool>::BoxedDefaultValue(),
                winrt::PropertyChangedCallback(&OnPropertyChanged));
    }
    if (!s_BackgroundSourceProperty)
    {
        s_BackgroundSourceProperty =
            InitializeDependencyProperty(
                L"BackgroundSource",
                winrt::name_of<winrt::AcrylicBackgroundSource>(),
                winrt::name_of<winrt::AcrylicBrush>(),
                false /* isAttached */,
                ValueHelper<winrt::AcrylicBackgroundSource>::BoxValueIfNecessary(winrt::AcrylicBackgroundSource::Backdrop),
                winrt::PropertyChangedCallback(&OnPropertyChanged));
    }
    if (!s_TintColorProperty)
    {
        s_TintColorProperty =
            InitializeDependencyProperty(
                L"TintColor",
                winrt::name_of<winrt::Color>(),
                winrt::name_of<winrt::AcrylicBrush>(),
                false /* isAttached */,
                ValueHelper<winrt::Color>::BoxValueIfNecessary(AcrylicBrush::sc_defaultTintColor),
                winrt::PropertyChangedCallback(&OnPropertyChanged));
    }
    if (!s_TintLuminosityOpacityProperty)
    {
        s_TintLuminosityOpacityProperty =
            InitializeDependencyProperty(
                L"TintLuminosityOpacity",
                winrt::name_of<winrt::IReference<double>>(),
                winrt::name_of<winrt::AcrylicBrush>(),
                false /* isAttached */,
                ValueHelper<winrt::IReference<double>>::BoxedDefaultValue(),
                &OnPropertyChanged_CoerceToZeroOneRange_Nullable);
    }
    if (!s_TintOpacityProperty)
    {
        s_TintOpacityProperty =
            InitializeDependencyProperty(
                L"TintOpacity",
                winrt::name_of<double>(),
                winrt::name_of<winrt::AcrylicBrush>(),
                false /* isAttached */,
                ValueHelper<double>::BoxValueIfNecessary(AcrylicBrush::sc_defaultTintOpacity),
                &OnPropertyChanged_CoerceToZeroOneRange);
    }
    if (!s_TintTransitionDurationProperty)
    {
        s_TintTransitionDurationProperty =
            InitializeDependencyProperty(
                L"TintTransitionDuration",
                winrt::name_of<winrt::TimeSpan>(),
                winrt::name_of<winrt::AcrylicBrush>(),
                false /* isAttached */,
                ValueHelper<winrt::TimeSpan>::BoxValueIfNecessary(AcrylicBrush::sc_defaultTintTransitionDuration),
                winrt::PropertyChangedCallback(&OnPropertyChanged));
    }
}

void AcrylicBrushProperties::ClearProperties()
{
    s_AlwaysUseFallbackProperty = nullptr;
    s_BackgroundSourceProperty = nullptr;
    s_TintColorProperty = nullptr;
    s_TintLuminosityOpacityProperty = nullptr;
    s_TintOpacityProperty = nullptr;
    s_TintTransitionDurationProperty = nullptr;
}

void AcrylicBrushProperties::OnPropertyChanged(
    winrt::DependencyObject const& sender,
    winrt::DependencyPropertyChangedEventArgs const& args)
{
    auto owner = sender.as<winrt::AcrylicBrush>();
    winrt::get_self<AcrylicBrush>(owner)->OnPropertyChanged(args);
}
void AcrylicBrushProperties::OnPropertyChanged_CoerceToZeroOneRange(
    winrt::DependencyObject const& sender,
    winrt::DependencyPropertyChangedEventArgs const& args)
{
    auto owner = sender.as<winrt::AcrylicBrush>();

    auto value = winrt::unbox_value<double>(args.NewValue());
    auto coercedValue = value;
    winrt::get_self<AcrylicBrush>(owner)->CoerceToZeroOneRange(coercedValue);
    if (std::memcmp(&value, &coercedValue, sizeof(value)) != 0) // use memcmp to avoid tripping over nan
    {
        sender.SetValue(args.Property(), winrt::box_value<double>(coercedValue));
        return;
    }

    winrt::get_self<AcrylicBrush>(owner)->OnPropertyChanged(args);
}
void AcrylicBrushProperties::OnPropertyChanged_CoerceToZeroOneRange_Nullable(
    winrt::DependencyObject const& sender,
    winrt::DependencyPropertyChangedEventArgs const& args)
{
    auto owner = sender.as<winrt::AcrylicBrush>();

    auto value = winrt::unbox_value<winrt::IReference<double>>(args.NewValue());
    auto coercedValue = value;
    winrt::get_self<AcrylicBrush>(owner)->CoerceToZeroOneRange_Nullable(coercedValue);
    if (value != coercedValue)
    {
        sender.SetValue(args.Property(), winrt::box_value<winrt::IReference<double>>(coercedValue));
        return;
    }

    winrt::get_self<AcrylicBrush>(owner)->OnPropertyChanged(args);
}

void AcrylicBrushProperties::AlwaysUseFallback(bool value)
{
    static_cast<AcrylicBrush*>(this)->SetValue(s_AlwaysUseFallbackProperty, ValueHelper<bool>::BoxValueIfNecessary(value));
}

bool AcrylicBrushProperties::AlwaysUseFallback()
{
    return ValueHelper<bool>::CastOrUnbox(static_cast<AcrylicBrush*>(this)->GetValue(s_AlwaysUseFallbackProperty));
}

void AcrylicBrushProperties::BackgroundSource(winrt::AcrylicBackgroundSource const& value)
{
    static_cast<AcrylicBrush*>(this)->SetValue(s_BackgroundSourceProperty, ValueHelper<winrt::AcrylicBackgroundSource>::BoxValueIfNecessary(value));
}

winrt::AcrylicBackgroundSource AcrylicBrushProperties::BackgroundSource()
{
    return ValueHelper<winrt::AcrylicBackgroundSource>::CastOrUnbox(static_cast<AcrylicBrush*>(this)->GetValue(s_BackgroundSourceProperty));
}

void AcrylicBrushProperties::TintColor(winrt::Color const& value)
{
    static_cast<AcrylicBrush*>(this)->SetValue(s_TintColorProperty, ValueHelper<winrt::Color>::BoxValueIfNecessary(value));
}

winrt::Color AcrylicBrushProperties::TintColor()
{
    return ValueHelper<winrt::Color>::CastOrUnbox(static_cast<AcrylicBrush*>(this)->GetValue(s_TintColorProperty));
}

void AcrylicBrushProperties::TintLuminosityOpacity(winrt::IReference<double> const& value)
{
    static_cast<AcrylicBrush*>(this)->CoerceToZeroOneRange_Nullable(value);
    static_cast<AcrylicBrush*>(this)->SetValue(s_TintLuminosityOpacityProperty, ValueHelper<winrt::IReference<double>>::BoxValueIfNecessary(value));
}

winrt::IReference<double> AcrylicBrushProperties::TintLuminosityOpacity()
{
    return ValueHelper<winrt::IReference<double>>::CastOrUnbox(static_cast<AcrylicBrush*>(this)->GetValue(s_TintLuminosityOpacityProperty));
}

void AcrylicBrushProperties::TintOpacity(double value)
{
    static_cast<AcrylicBrush*>(this)->CoerceToZeroOneRange(value);
    static_cast<AcrylicBrush*>(this)->SetValue(s_TintOpacityProperty, ValueHelper<double>::BoxValueIfNecessary(value));
}

double AcrylicBrushProperties::TintOpacity()
{
    return ValueHelper<double>::CastOrUnbox(static_cast<AcrylicBrush*>(this)->GetValue(s_TintOpacityProperty));
}

void AcrylicBrushProperties::TintTransitionDuration(winrt::TimeSpan const& value)
{
    static_cast<AcrylicBrush*>(this)->SetValue(s_TintTransitionDurationProperty, ValueHelper<winrt::TimeSpan>::BoxValueIfNecessary(value));
}

winrt::TimeSpan AcrylicBrushProperties::TintTransitionDuration()
{
    return ValueHelper<winrt::TimeSpan>::CastOrUnbox(static_cast<AcrylicBrush*>(this)->GetValue(s_TintTransitionDurationProperty));
}
